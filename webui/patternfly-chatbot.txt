Directory structure:
└── patternfly-chatbot/
    ├── README.md
    ├── babel.config.js
    ├── cypress.config.ts
    ├── fed-mini-modules.js
    ├── jest.config.js
    ├── jest.setup.js
    ├── LICENSE
    ├── package.json
    ├── tsconfig.json
    ├── .eslintignore
    ├── .eslintrc-md.json
    ├── .eslintrc.json
    ├── .prettierignore
    ├── .prettierrc.json
    ├── config/
    │   ├── globalSetup.js
    │   ├── setupTests.js
    │   └── webpack.cy.config.js
    ├── cypress/
    │   ├── tsconfig.json
    │   ├── fixtures/
    │   │   └── example.json
    │   └── support/
    │       ├── commands.ts
    │       ├── component-index.html
    │       ├── component.ts
    │       └── e2e.ts
    ├── packages/
    │   └── module/
    │       ├── generate-fed-package-json.js
    │       ├── generate-index.js
    │       ├── package.json
    │       ├── patternfly-a11y.config.js
    │       ├── release.config.js
    │       ├── tsconfig.cjs.json
    │       ├── tsconfig.json
    │       ├── @types/
    │       │   └── index.d.ts
    │       ├── patternfly-docs/
    │       │   ├── patternfly-docs.config.js
    │       │   ├── patternfly-docs.css.js
    │       │   ├── patternfly-docs.routes.js
    │       │   ├── patternfly-docs.source.js
    │       │   ├── content/
    │       │   │   └── extensions/
    │       │   │       └── chatbot/
    │       │   │           ├── about-chatbot.md
    │       │   │           ├── design-guidelines.md
    │       │   │           ├── images.css
    │       │   │           ├── examples/
    │       │   │           │   ├── Analytics/
    │       │   │           │   │   └── Analytics.md
    │       │   │           │   ├── demos/
    │       │   │           │   │   ├── AttachmentDemos.md
    │       │   │           │   │   ├── Chatbot.md
    │       │   │           │   │   ├── Chatbot.tsx
    │       │   │           │   │   ├── ChatbotAttachment.tsx
    │       │   │           │   │   ├── ChatbotAttachmentMenu.tsx
    │       │   │           │   │   ├── ChatbotCompact.tsx
    │       │   │           │   │   ├── ChatbotInDrawer.tsx
    │       │   │           │   │   ├── EmbeddedChatbot.tsx
    │       │   │           │   │   ├── EmbeddedComparisonChatbot.tsx
    │       │   │           │   │   └── Feedback.tsx
    │       │   │           │   ├── Messages/
    │       │   │           │   │   ├── AttachmentEdit.tsx
    │       │   │           │   │   ├── AttachmentError.tsx
    │       │   │           │   │   ├── AttachMenu.tsx
    │       │   │           │   │   ├── BotMessage.tsx
    │       │   │           │   │   ├── explore-pipeline-quickstart.ts
    │       │   │           │   │   ├── FileDetails.tsx
    │       │   │           │   │   ├── FileDetailsLabel.tsx
    │       │   │           │   │   ├── FileDropZone.tsx
    │       │   │           │   │   ├── Messages.md
    │       │   │           │   │   ├── MessageWithAttachment.tsx
    │       │   │           │   │   ├── MessageWithCustomResponseActions.tsx
    │       │   │           │   │   ├── MessageWithFeedback.tsx
    │       │   │           │   │   ├── MessageWithFeedbackTimeout.tsx
    │       │   │           │   │   ├── MessageWithQuickResponses.tsx
    │       │   │           │   │   ├── MessageWithQuickStart.tsx
    │       │   │           │   │   ├── MessageWithResponseActions.tsx
    │       │   │           │   │   ├── MessageWithSources.tsx
    │       │   │           │   │   ├── PreviewAttachment.tsx
    │       │   │           │   │   ├── UserMessage.tsx
    │       │   │           │   │   └── UserMessageWithExtraContent.tsx
    │       │   │           │   └── UI/
    │       │   │           │       ├── ChatbotContainer.tsx
    │       │   │           │       ├── ChatbotFooter.tsx
    │       │   │           │       ├── ChatbotFootnote.tsx
    │       │   │           │       ├── ChatbotHeaderBasic.tsx
    │       │   │           │       ├── ChatbotHeaderDrawer.tsx
    │       │   │           │       ├── ChatbotHeaderDrawerNavigation.tsx
    │       │   │           │       ├── ChatbotHeaderDrawerResizable.tsx
    │       │   │           │       ├── ChatbotHeaderDrawerWithActions.tsx
    │       │   │           │       ├── ChatbotHeaderDrawerWithSelection.tsx
    │       │   │           │       ├── ChatbotHeaderTitle.tsx
    │       │   │           │       ├── ChatbotMessageBar.tsx
    │       │   │           │       ├── ChatbotMessageBarAttach.tsx
    │       │   │           │       ├── ChatbotMessageBarDisabled.tsx
    │       │   │           │       ├── ChatbotMessageBarLanguage.tsx
    │       │   │           │       ├── ChatbotMessageBarStop.tsx
    │       │   │           │       ├── ChatbotModal.tsx
    │       │   │           │       ├── ChatbotToggleBasic.tsx
    │       │   │           │       ├── ChatbotWelcomeInteraction.tsx
    │       │   │           │       ├── ChatbotWelcomePrompt.tsx
    │       │   │           │       ├── CompactSettings.tsx
    │       │   │           │       ├── CustomClosedIcon.tsx
    │       │   │           │       ├── Settings.tsx
    │       │   │           │       ├── SkipToContent.tsx
    │       │   │           │       ├── SquareChatbotToggle.tsx
    │       │   │           │       ├── TermsOfUse.tsx
    │       │   │           │       ├── TermsOfUseCompact.tsx
    │       │   │           │       └── UI.md
    │       │   │           └── img/
    │       │   ├── generated/
    │       │   │   └── patternfly-ai/
    │       │   │       └── chatbot/
    │       │   │           ├── messages/
    │       │   │           │   └── demo/
    │       │   │           ├── overview/
    │       │   │           │   └── demo/
    │       │   │           └── ui/
    │       │   │               └── react/
    │       │   └── pages/
    │       │       └── index.js
    │       └── src/
    │           ├── index.ts
    │           ├── main.scss
    │           ├── __mocks__/
    │           │   ├── rehype-external-links.ts
    │           │   ├── rehype-sanitize.ts
    │           │   └── rehype-unwrap-images.tsx
    │           ├── AttachmentEdit/
    │           │   ├── AttachmentEdit.test.tsx
    │           │   ├── AttachmentEdit.tsx
    │           │   └── index.ts
    │           ├── AttachMenu/
    │           │   ├── AttachMenu.scss
    │           │   ├── AttachMenu.tsx
    │           │   └── index.ts
    │           ├── Chatbot/
    │           │   ├── Chatbot.scss
    │           │   ├── Chatbot.test.tsx
    │           │   ├── Chatbot.tsx
    │           │   └── index.ts
    │           ├── ChatbotAlert/
    │           │   ├── ChatbotAlert.scss
    │           │   ├── ChatbotAlert.test.tsx
    │           │   ├── ChatbotAlert.tsx
    │           │   └── index.ts
    │           ├── ChatbotContent/
    │           │   ├── ChatbotContent.scss
    │           │   ├── ChatbotContent.test.tsx
    │           │   ├── ChatbotContent.tsx
    │           │   └── index.ts
    │           ├── ChatbotConversationHistoryNav/
    │           │   ├── ChatbotConversationHistoryDropdown.test.tsx
    │           │   ├── ChatbotConversationHistoryDropdown.tsx
    │           │   ├── ChatbotConversationHistoryNav.scss
    │           │   ├── ChatbotConversationHistoryNav.test.tsx
    │           │   ├── ChatbotConversationHistoryNav.tsx
    │           │   ├── EmptyState.tsx
    │           │   ├── index.ts
    │           │   └── LoadingState.tsx
    │           ├── ChatbotFooter/
    │           │   ├── ChatbotFooter.scss
    │           │   ├── ChatbotFooter.test.tsx
    │           │   ├── ChatbotFooter.tsx
    │           │   ├── ChatbotFooternote.test.tsx
    │           │   ├── ChatbotFootnote.scss
    │           │   ├── ChatbotFootnote.tsx
    │           │   └── index.ts
    │           ├── ChatbotHeader/
    │           │   ├── ChatbotHeader.scss
    │           │   ├── ChatbotHeader.test.tsx
    │           │   ├── ChatbotHeader.tsx
    │           │   ├── ChatbotHeaderActions.test.tsx
    │           │   ├── ChatbotHeaderActions.tsx
    │           │   ├── ChatbotHeaderCloseButton.test.tsx
    │           │   ├── ChatbotHeaderCloseButton.tsx
    │           │   ├── ChatbotHeaderMain.test.tsx
    │           │   ├── ChatbotHeaderMain.tsx
    │           │   ├── ChatbotHeaderMenu.test.tsx
    │           │   ├── ChatbotHeaderMenu.tsx
    │           │   ├── ChatbotHeaderOptionsDropdown.test.tsx
    │           │   ├── ChatbotHeaderOptionsDropdown.tsx
    │           │   ├── ChatbotHeaderSelectorDropdown.test.tsx
    │           │   ├── ChatbotHeaderSelectorDropdown.tsx
    │           │   ├── ChatbotHeaderTitle.test.tsx
    │           │   ├── ChatbotHeaderTitle.tsx
    │           │   └── index.ts
    │           ├── ChatbotModal/
    │           │   ├── ChatbotModal.scss
    │           │   ├── ChatbotModal.test.tsx
    │           │   ├── ChatbotModal.tsx
    │           │   └── index.ts
    │           ├── ChatbotPopover/
    │           │   ├── ChatbotPopover.scss
    │           │   ├── ChatbotPopover.tsx
    │           │   └── index.ts
    │           ├── ChatbotToggle/
    │           │   ├── ChatbotToggle.scss
    │           │   ├── ChatbotToggle.test.tsx
    │           │   ├── ChatbotToggle.tsx
    │           │   └── index.ts
    │           ├── ChatbotWelcomePrompt/
    │           │   ├── ChatbotWelcomePrompt.scss
    │           │   ├── ChatbotWelcomePrompt.test.tsx
    │           │   ├── ChatbotWelcomePrompt.tsx
    │           │   ├── index.ts
    │           │   └── __snapshots__/
    │           │       └── ChatbotWelcomePrompt.test.tsx.snap
    │           ├── CodeModal/
    │           │   ├── CodeModal.scss
    │           │   ├── CodeModal.test.tsx
    │           │   ├── CodeModal.tsx
    │           │   └── index.ts
    │           ├── Compare/
    │           │   ├── Compare.scss
    │           │   ├── Compare.test.tsx
    │           │   ├── Compare.tsx
    │           │   └── index.ts
    │           ├── FileDetails/
    │           │   ├── FileDetails.scss
    │           │   ├── FileDetails.test.tsx
    │           │   ├── FileDetails.tsx
    │           │   ├── index.ts
    │           │   └── __snapshots__/
    │           │       └── FileDetails.test.tsx.snap
    │           ├── FileDetailsLabel/
    │           │   ├── FileDetailsLabel.scss
    │           │   ├── FileDetailsLabel.test.tsx
    │           │   ├── FileDetailsLabel.tsx
    │           │   ├── index.ts
    │           │   └── __snapshots__/
    │           │       └── FileDetailsLabel.test.tsx.snap
    │           ├── FileDropZone/
    │           │   ├── FileDropZone.scss
    │           │   ├── FileDropZone.test.tsx
    │           │   ├── FileDropZone.tsx
    │           │   ├── index.ts
    │           │   └── __snapshots__/
    │           │       └── FileDropZone.test.tsx.snap
    │           ├── LoadingMessage/
    │           │   ├── index.ts
    │           │   ├── LoadingMessage.test.tsx
    │           │   ├── LoadingMessage.tsx
    │           │   └── __snapshots__/
    │           │       └── LoadingMessage.test.tsx.snap
    │           ├── Message/
    │           │   ├── index.ts
    │           │   ├── Message.scss
    │           │   ├── Message.test.tsx
    │           │   ├── Message.tsx
    │           │   ├── MessageInput.tsx
    │           │   ├── MessageLoading.scss
    │           │   ├── MessageLoading.tsx
    │           │   ├── CodeBlockMessage/
    │           │   │   ├── CodeBlockMessage.scss
    │           │   │   └── CodeBlockMessage.tsx
    │           │   ├── ErrorMessage/
    │           │   │   └── ErrorMessage.tsx
    │           │   ├── ImageMessage/
    │           │   │   ├── ImageMessage.scss
    │           │   │   └── ImageMessage.tsx
    │           │   ├── LinkMessage/
    │           │   │   └── LinkMessage.tsx
    │           │   ├── ListMessage/
    │           │   │   ├── ListItemMessage.tsx
    │           │   │   ├── ListMessage.scss
    │           │   │   ├── OrderedListMessage.tsx
    │           │   │   └── UnorderedListMessage.tsx
    │           │   ├── QuickResponse/
    │           │   │   ├── QuickResponse.scss
    │           │   │   └── QuickResponse.tsx
    │           │   ├── QuickStarts/
    │           │   │   ├── FallbackImg.tsx
    │           │   │   ├── monitor-sampleapp-quickstart-with-image.ts
    │           │   │   ├── monitor-sampleapp-quickstart.ts
    │           │   │   ├── QuickStartTile.scss
    │           │   │   ├── QuickStartTile.tsx
    │           │   │   ├── QuickStartTileDescription.test.tsx
    │           │   │   ├── QuickStartTileDescription.tsx
    │           │   │   ├── QuickStartTileHeader.tsx
    │           │   │   └── types.ts
    │           │   ├── TableMessage/
    │           │   │   ├── TableMessage.scss
    │           │   │   ├── TableMessage.tsx
    │           │   │   ├── TbodyMessage.tsx
    │           │   │   ├── TdMessage.tsx
    │           │   │   ├── TheadMessage.tsx
    │           │   │   ├── ThMessage.tsx
    │           │   │   └── TrMessage.tsx
    │           │   ├── TextMessage/
    │           │   │   ├── TextMessage.scss
    │           │   │   └── TextMessage.tsx
    │           │   └── UserFeedback/
    │           │       ├── CloseButton.tsx
    │           │       ├── UserFeedback.scss
    │           │       ├── UserFeedback.test.tsx
    │           │       ├── UserFeedback.tsx
    │           │       ├── UserFeedbackComplete.test.tsx
    │           │       └── UserFeedbackComplete.tsx
    │           ├── MessageBar/
    │           │   ├── AttachButton.scss
    │           │   ├── AttachButton.test.tsx
    │           │   ├── AttachButton.tsx
    │           │   ├── index.ts
    │           │   ├── MessageBar.scss
    │           │   ├── MessageBar.test.tsx
    │           │   ├── MessageBar.tsx
    │           │   ├── MicrophoneButton.scss
    │           │   ├── MicrophoneButton.tsx
    │           │   ├── SendButton.scss
    │           │   ├── SendButton.test.tsx
    │           │   ├── SendButton.tsx
    │           │   ├── StopButton.scss
    │           │   ├── StopButton.test.tsx
    │           │   └── StopButton.tsx
    │           ├── MessageBox/
    │           │   ├── index.ts
    │           │   ├── JumpButton.scss
    │           │   ├── JumpButton.test.tsx
    │           │   ├── JumpButton.tsx
    │           │   ├── MessageBox.scss
    │           │   ├── MessageBox.test.tsx
    │           │   └── MessageBox.tsx
    │           ├── PreviewAttachment/
    │           │   ├── index.ts
    │           │   ├── PreviewAttachment.test.tsx
    │           │   └── PreviewAttachment.tsx
    │           ├── ResponseActions/
    │           │   ├── index.ts
    │           │   ├── ResponseActionButton.test.tsx
    │           │   ├── ResponseActionButton.tsx
    │           │   ├── ResponseActions.scss
    │           │   ├── ResponseActions.test.tsx
    │           │   └── ResponseActions.tsx
    │           ├── Settings/
    │           │   ├── index.ts
    │           │   ├── Settings.scss
    │           │   ├── SettingsForm.test.tsx
    │           │   └── SettingsForm.tsx
    │           ├── SourceDetailsMenuItem/
    │           │   ├── index.ts
    │           │   ├── SourceDetailsMenuItem.scss
    │           │   └── SourceDetailsMenuItem.tsx
    │           ├── SourcesCard/
    │           │   ├── index.ts
    │           │   ├── SourcesCard.scss
    │           │   ├── SourcesCard.test.tsx
    │           │   └── SourcesCard.tsx
    │           ├── TermsOfUse/
    │           │   ├── index.ts
    │           │   ├── TermsOfUse.scss
    │           │   ├── TermsOfUse.test.tsx
    │           │   └── TermsOfUse.tsx
    │           └── tracking/
    │               ├── console_tracking_provider.ts
    │               ├── index.ts
    │               ├── posthog_tracking_provider.ts
    │               ├── segment_tracking_provider.ts
    │               ├── tracking_api.ts
    │               ├── tracking_registry.ts
    │               ├── tracking_spi.ts
    │               ├── trackingProviderProxy.ts
    │               └── umami_tracking_provider.ts
    ├── scripts/
    │   └── build-packages.js
    └── .github/
        ├── upload-preview.js
        └── workflows/
            ├── build-lint-test.yml
            ├── build.yml
            ├── check-pr.yml
            ├── extensions.yml
            ├── pr-preview.yml
            ├── promote.yml
            └── release.yml

================================================
FILE: README.md
================================================
# PatternFly ChatBot
  
This PatternFly extension library provides components based on PatternFly 6 that can be used to build chatbots.

---

## Install

To use the chatbot extension in your project, run

```
npm install @patternfly/chatbot --save
```

Make sure to add the CSS imports as the last import in your index file. The extension is intended to override certain PatternFly component styles. However, if it's not the last import, you may not see these.

```
import '@patternfly/chatbot/dist/css/main.css';
```

## Contribution guide

### To add a new assistant sub-component:

1. create a folder in `src/` matching its name (for example `src/MyComponent`)
2. to the new folder add a new `.tsx` file named after the component (for example `src/MyComponent/MyComponent.tsx`)
3. to the same folder include an `index.ts` which will export the component as a default and then all necessary interfaces
4. if this file structure is not met, your component won't be exposed correctly

#### Example component:

```
import * as React from 'react';
import { Text } from '@patternfly/react-core';

// do not forget to export your component's interface
// always place the component's interface above the component itself in the code
export interface MyComponentProps {
  text: String;


// do not use the named export of your component, just a default one
const MyComponent: React.FunctionComponent<MyComponentProps> = () => {

  return (
    <Text>
      This is my new component
    </Text>
  );
};

export default MyComponent;
```

#### Index file example:

```
export { default } from './MyComponent';
export * from './MyComponent';
```

#### Component directory structure example:

```
src
|- MyComponent
   |- index.ts
   |- MyComponent.tsx
```

### Component's API rules:

- prop names comply with PatternFly components naming standards (`variant`, `onClick`, `position`, etc.)
- the API is maximally simplified and all props are provided with a description
- it is built on top of existing PatternFly types without prop omitting
- it is well documented using the PatternFly documentation (`/packages/module/patternfly-docs/content/extensions/chatbot/examples/MyComponent/MyComponent.md`) with examples of all possible use cases (`packages/module/patternfly-docs/content/extensions/chatbot/examples/MyComponent/MyComponent[...]Example.tsx`)

#### Component API definition example:

```
// when possible, extend available PatternFly types
export interface MyComponentProps extends ButtonProps {
    customLabel: Boolean
};

export const MyComponent: React.FunctionComponent<MyComponentProps> = ({ customLabel, ...props }) => ( ... );
```

#### Markdown file example:

Note: You'll need to add any imports required in a component usage file example like MyComponentExample.tsx, below, here as well.

````
---
section: extensions
subsection: ChatBot
id: MyComponent
propComponents: ['MyComponent']
---

import MyComponent from "@patternfly/chatbot/dist/dynamic/MyComponent";

## Component usage

MyComponent has been created to demo contributing to this repository.

### MyComponent component example label

```js file="./MyComponentExample.tsx"```

````

#### Component usage file example: (`MyComponentExample.tsx`)

Note: You'll need to add any imports required here in the parent folder's markdown file as well.

```
import React from 'react';

const MyComponentExample: React.FunctionComponent = () => (
  <MyComponent customLabel="My label">
);

export default BatteryLowExample;
```

### Sub-components:

When adding a component for which it is advantageous to divide it into several sub-components make sure:

- component and all its sub-components are located in separate files and directories straight under the `src/` folder
- sub-components are exported and documented separately from their parent
- parent component should provide a way to pass props to all its sub-components

The aim is to enable the user of our "complex" component to use either complete or take advantage of its sub-components and manage their composition independently.

### Testing:

When adding/making changes to a component, always make sure your code is tested:

- use React Testing Library for unit testing
- add unit tests to a `[ComponentName].test.tsx` file to your component's directory
- make sure all the core functionality is covered using Cypress component or E2E tests
- add component tests to `cypress/component/[ComponentName].cy.tsx` file and E2E tests to `cypress/e2e/[ComponentName].spec.cy.ts`
- add `ouiaId` to component props definition with a default value of the component name (for subcomponents, let's use `ComponentName-element-specification` naming convention e.g. `ouiaId="VirtualAssistant-send-button"`)

### Styling:

- for styling always use CSS
- new classNames should be named in camelCase starting with the name of a given component and following with more details clarifying its purpose/component's subsection to which the class is applied (`actionMenu`, `actionMenuDropdown`, `actionMenuDropdownToggle`, etc.)
- do not use `pf-v6-u-XXX` classes, use CSS variables in a custom class instead (styles for the utility classes are not bundled with the standard patternfly.css - it would require the consumer to import also addons.css)

---

## Building for production

- run `npm install`
- run `npm run build`

## Development

- run `npm install`
- run `npm run build`
- run `npm run start` to build and start the development server

## Testing and Linting

- run `npm run test` to run the tests
- run `npm run lint` to run the linter

## A11y testing

- run `npm run build:docs` followed by `npm run serve:docs`, then run `npm run test:a11y` in a new terminal window to run our accessibility tests. Once the accessibility tests have finished running you can run
- `npm run serve:a11y` to locally view the generated report

## Generating screenshots

From root folder:

```sh
npm install
npm run build
cd packages/module
npm run docs:build
npm run docs:serve
```

Open a new terminal tab while serving; make sure you are in package/module folder:

```sh
npm run docs:screenshots
```

These files will not be picked up by git; you'll have to look for them and add them manually.



================================================
FILE: babel.config.js
================================================
module.exports = {
  presets: [
    [ '@babel/preset-env', { targets: { node: 'current' } } ],
    [ '@babel/preset-react', { runtime: 'automatic' } ],
    '@babel/preset-flow',
    '@babel/preset-typescript'
  ]
};


================================================
FILE: cypress.config.ts
================================================
import { defineConfig } from "cypress";

export default defineConfig({
  e2e: {
    viewportHeight: 1024,
    viewportWidth: 1400,
    screenshotOnRunFailure: false,
    reporter: "junit",
    reporterOptions: {
      mochaFile: "results/my-test-output-[hash].xml",
      toConsole: true,
    },
  },

  component: {
    devServer: {
      framework: "react",
      bundler: "webpack",
      webpackConfig: require('./config/webpack.cy.config.js'),
    },
  },
});



================================================
FILE: fed-mini-modules.js
================================================
const fse = require('fs-extra');
const glob = require('glob');
const path = require('path');

const root = process.cwd();

const sourceFiles = glob
  .sync(`${root}/src/*/`)
  .map((name) => name.replace(/\/$/, ''));
  
const indexTypings = glob.sync(`${root}/src/index.d.ts`);

async function copyTypings(files, dest) {
  const cmds = [];
  files.forEach((file) => {
    const fileName = file.split('/').pop();
    cmds.push(fse.copyFile(file, `${dest}/${fileName}`));
  });
  return Promise.all(cmds);
}

async function createPackage(file) {
  const fileName = file.split('/').pop();
  const esmSource = glob.sync(`${root}/esm/${fileName}/**/index.js`)[0];
  /**
   * Prevent creating package.json for directories with no JS files (like CSS directories)
   */
  if (!esmSource) {
    return;
  }

  const destFile = `${path.resolve(root, file.split('/src/').pop())}/package.json`;

  const esmRelative = path.relative(file.replace('/src', ''), esmSource);
  const content = {
    main: 'index.js',
    module: esmRelative,
  };
  const typings = glob.sync(`${root}/src/${fileName}/*.d.ts`);
  const cmds = [];
  content.typings = 'index.d.ts';
  cmds.push(copyTypings(typings, `${root}/${fileName}`));
  cmds.push(fse.writeJSON(destFile, content));
  return Promise.all(cmds);
}

async function generatePackages(files) {
  const cmds = files.map((file) => createPackage(file));
  return Promise.all(cmds);
}

async function run(files) {
  try {
    await generatePackages(files);
    if (indexTypings.length === 1) {
      copyTypings(indexTypings, root);
    }
  } catch (error) {
    console.error(error);
    process.exit(1);
  }
}

run(sourceFiles);


================================================
FILE: jest.config.js
================================================
// Sync object
/** @type {import('@jest/types').Config.InitialOptions} */

module.exports = {
  verbose: true,
  coverageDirectory: './coverage/',
  collectCoverage: true,
  // most of these are to fix https://github.com/remarkjs/react-markdown/issues/635
  transformIgnorePatterns: [
    'node_modules/(?!@patternfly|@data-driven-forms|react-syntax-highlighter|remark-gfm|react-markdown|remark-parse|devlop|hast-util-to-jsx-runtime|comma-separated-tokens|estree-util-is-identifier-name|hast-util-whitespace|property-information|space-separated-tokens|unist-util-position|vfile-message|unist-util-stringify-position|html-url-attributes|mdast-util-from-markdown|mdast-util-to-string|micromark|decode-named-character-reference|remark-rehype|mdast-util-to-hast|trim-lines|unist-util-visit|unist-util-is|unified|bail|is-plain-obj|trough|vfile|mdast-util-gfm|ccount|mdast-util-find-and-replace|escape-string-regexp|markdown-table|mdast-util-to-markdown|zwitch|longest-streak|mdast-util-phrasing)'
    // Uncomment the below line if you face any errors with jest
    // '/node_modules/(?!@redhat-cloud-services)',
  ],
  collectCoverageFrom: [
    '<rootDir>/packages/**/src/**/*.js',
    '!<rootDir>/packages/**/stories/*',
    '!<rootDir>/packages/**/index.js',
    '!<rootDir>/packages/**/*{c|C}ontext*.js',
    '!<rootDir>/packages/components/src/Components/Table/*',
    '<rootDir>/packages/**/src/**/*.tsx'
  ],
  setupFilesAfterEnv: ['<rootDir>/config/setupTests.js', 'jest-canvas-mock'],
  testEnvironment: 'jsdom',
  testEnvironmentOptions: {
    url: 'http://localhost:5000/'
  },
  setupFiles: ['./jest.setup.js'],
  roots: ['<rootDir>/packages/'],
  // modulePathIgnorePatterns: ['<rootDir>/packages/create-crc-app/templates', '<rootDir>/packages/docs/.cache'],
  modulePathIgnorePatterns: [
    '<rootDir>/packages/*.*/dist/*.*',
    '<rootDir>/packages/*.*/public/*.*',
    '<rootDir>/packages/*.*/.cache/*.*'
  ],
  moduleNameMapper: {
    '\\.(css|scss)$': 'identity-obj-proxy',
    '^lodash-es$': 'lodash',
    customReact: 'react',
    reactRedux: 'react-redux',
    PFReactCore: '@patternfly/react-core',
    PFReactTable: '@patternfly/react-table'
  },
  globalSetup: '<rootDir>/config/globalSetup.js',
  transform: {
    '^.+\\.jsx?$': 'babel-jest',
    '^.+\\.tsx?$': ['ts-jest', { tsconfig: './packages/module/tsconfig.json' }],
    // Ensure ES modules are transformed
    '^.+\\.js$': 'babel-jest'
  }
};



================================================
FILE: jest.setup.js
================================================
const { TextEncoder } = require('util');
global.TextEncoder = TextEncoder;



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2024 Red Hat, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: package.json
================================================
{
  "name": "@patternfly/chatbot-root",
  "private": true,
  "version": "0.0.0",
  "description": "This library provides React components based on PatternFly 6 that can be used to build chatbots.",
  "license": "MIT",
  "workspaces": [
    "packages/*"
  ],
  "scripts": {
    "build": "npm run build:packages && npm run build:fed:packages",
    "build:watch": "concurrently \"npm run build:packages:watch\" \"npx wait-on packages/module/dist/esm && npm run build:fed:packages\"",
    "build:docs": "npm run docs:build -w @patternfly/chatbot",
    "build:packages": "npm run build -w @patternfly/chatbot",
    "build:packages:watch": "npm run build:watch -w @patternfly/chatbot",
    "build:fed:packages": "npm run build:fed:packages -w @patternfly/chatbot",
    "cypress:open": "cypress open",
    "cypress:run:ci:cp": "cypress run --component",
    "cypress:run:e2e": "cypress run --headless",
    "cypress:run:ci:e2e": "start-server-and-test start http://localhost:8006 cypress:run:e2e",
    "start": "concurrently \"npm run build:watch\" \"npx wait-on packages/module/dist && npm run docs:develop -w @patternfly/chatbot\"",
    "serve:docs": "npm run docs:serve -w @patternfly/chatbot",
    "clean": "npm run clean -w @patternfly/chatbot",
    "lint:js": "node --max-old-space-size=4096 node_modules/.bin/eslint packages --ext js,jsx,ts,tsx --cache",
    "lint:js:fix": "node --max-old-space-size=4096 node_modules/.bin/eslint packages --ext js,jsx,ts,tsx --cache --fix",
    "lint:md": "eslint packages --ext md --no-eslintrc --config .eslintrc-md.json --cache",
    "lint:md:fix": "eslint packages --ext md --no-eslintrc --config .eslintrc-md.json --cache --fix",
    "lint": "npm run lint:js && npm run lint:md",
    "lint:fix": "npm run lint:js:fix && npm run lint:md:fix",
    "test": "TZ=EST jest packages --passWithNoTests",
    "test:a11y": "npm run test:a11y -w @patternfly/chatbot",
    "serve:a11y": "npm run serve:a11y -w @patternfly/chatbot"
  },
  "devDependencies": {
    "@babel/core": "^7.24.0",
    "@babel/plugin-proposal-private-property-in-object": "^7.19.6",
    "@babel/preset-env": "^7.24.0",
    "@babel/preset-flow": "^7.24.0",
    "@babel/preset-react": "^7.23.3",
    "@babel/preset-typescript": "^7.23.3",
    "@octokit/rest": "^18.0.0",
    "@patternfly/documentation-framework": "6.8.2",
    "@patternfly/patternfly": "^6.1.0",
    "@patternfly/react-icons": "^6.1.0",
    "@patternfly/react-table": "^6.1.0",
    "@swc/core": "1.3.96",
    "@testing-library/dom": "^9.3.4",
    "@testing-library/jest-dom": "^6.4.2",
    "@testing-library/react": "^14.2.1",
    "@testing-library/user-event": "14.5.2",
    "@types/jest": "^29.5.12",
    "@typescript-eslint/eslint-plugin": "^5.62.0",
    "@typescript-eslint/parser": "^5.62.0",
    "babel-jest": "^29.7.0",
    "babel-polyfill": "6.26.0",
    "chokidar": "^3.6.0",
    "concurrently": "^8.2.2",
    "cypress": "^13.7.1",
    "eslint": "^8.57.0",
    "eslint-config-prettier": "9.1.0",
    "eslint-config-standard-with-typescript": "^23.0.0",
    "eslint-plugin-import": "^2.29.1",
    "eslint-plugin-markdown": "^1.0.2",
    "eslint-plugin-n": "^15.7.0",
    "eslint-plugin-prettier": "^5.1.3",
    "eslint-plugin-promise": "^6.1.1",
    "eslint-plugin-react": "^7.33.2",
    "eslint-plugin-react-hooks": "^4.6.0",
    "fs-extra": "^11.2.0",
    "glob": "^10.3.10",
    "identity-obj-proxy": "^3.0.0",
    "jest": "^29.7.0",
    "jest-canvas-mock": "^2.5.2",
    "jest-environment-jsdom": "^29.7.0",
    "prettier": "3.2.5",
    "react": "^18",
    "react-dom": "^18",
    "rimraf": "^5.0.5",
    "sass": "^1.72.0",
    "sass-loader": "^14.1.1",
    "serve": "^14.2.1",
    "start-server-and-test": "^2.0.3",
    "surge": "^0.23.1",
    "swc-loader": "0.2.3",
    "ts-jest": "29.1.2",
    "wait-on": "^7.2.0",
    "whatwg-fetch": "^3.6.20"
  },
  "overrides": {
    "puppeteer": "^23.6.1",
    "puppeteer-cluster": "^0.24.0"
  },
  "dependencies": {
    "react-dropzone": "^14.2.3"
  },
  "packageManager": "yarn@4.5.0+sha512.837566d24eec14ec0f5f1411adb544e892b3454255e61fdef8fd05f3429480102806bac7446bc9daff3896b01ae4b62d00096c7e989f1596f2af10b927532f39"
}



================================================
FILE: tsconfig.json
================================================
{
    "compilerOptions": {
      /* Visit https://aka.ms/tsconfig.json to read more about this file */
  
      /* Basic Options */
      // "incremental": true,                         /* Enable incremental compilation */
      "target": "es2015" /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', 'ES2021', or 'ESNEXT'. */,
      "module": "es2015" /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */,
      // "lib": [],                                   /* Specify library files to be included in the compilation. */
      // "allowJs": true,                             /* Allow javascript files to be compiled. */
      // "checkJs": true,                             /* Report errors in .js files. */
      "jsx": "react" /* Specify JSX code generation: 'preserve', 'react-native', 'react', 'react-jsx' or 'react-jsxdev'. */,
      "declaration": true /* Generates corresponding '.d.ts' file. */,
      // "declarationMap": true,                      /* Generates a sourcemap for each corresponding '.d.ts' file. */
      // "sourceMap": true,                           /* Generates corresponding '.map' file. */
      // "outFile": "./",                             /* Concatenate and emit output to single file. */
      "outDir": "./dist" /* Redirect output structure to the directory. */,
      "rootDir": "./cypress" /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */,
      // "composite": true,                           /* Enable project compilation */
      // "tsBuildInfoFile": "./",                     /* Specify file to store incremental compilation information */
      // "removeComments": true,                      /* Do not emit comments to output. */
      // "noEmit": true,                              /* Do not emit outputs. */
      // "importHelpers": true,                       /* Import emit helpers from 'tslib'. */
      // "downlevelIteration": true,                  /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */
      // "isolatedModules": true,                     /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */
  
      /* Strict Type-Checking Options */
      "strict": true /* Enable all strict type-checking options. */,
      "noImplicitAny": false,                       /* Raise error on expressions and declarations with an implied 'any' type. */
      // "strictNullChecks": true,                    /* Enable strict null checks. */
      // "strictFunctionTypes": true,                 /* Enable strict checking of function types. */
      // "strictBindCallApply": true,                 /* Enable strict 'bind', 'call', and 'apply' methods on functions. */
      // "strictPropertyInitialization": true,        /* Enable strict checking of property initialization in classes. */
      // "noImplicitThis": true,                      /* Raise error on 'this' expressions with an implied 'any' type. */
      // "alwaysStrict": true,                        /* Parse in strict mode and emit "use strict" for each source file. */
  
      /* Additional Checks */
      // "noUnusedLocals": true,                      /* Report errors on unused locals. */
      // "noUnusedParameters": true,                  /* Report errors on unused parameters. */
      // "noImplicitReturns": true,                   /* Report error when not all code paths in function return a value. */
      // "noFallthroughCasesInSwitch": true,          /* Report errors for fallthrough cases in switch statement. */
      // "noUncheckedIndexedAccess": true,            /* Include 'undefined' in index signature results */
      // "noImplicitOverride": true,                  /* Ensure overriding members in derived classes are marked with an 'override' modifier. */
      // "noPropertyAccessFromIndexSignature": true,  /* Require undeclared properties from index signatures to use element accesses. */
  
      /* Module Resolution Options */
      "moduleResolution": "node" /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */,
      // "baseUrl": "./",                             /* Base directory to resolve non-absolute module names. */
      // "paths": {},                                 /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */
      // "rootDirs": [],                              /* List of root folders whose combined content represents the structure of the project at runtime. */
      // "typeRoots": [],                             /* List of folders to include type definitions from. */
      // "types": [],                                 /* Type declaration files to be included in compilation. */
      // "allowSyntheticDefaultImports": true,        /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */
      "esModuleInterop": true /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */,
      // "preserveSymlinks": true,                    /* Do not resolve the real path of symlinks. */
      // "allowUmdGlobalAccess": true,                /* Allow accessing UMD globals from modules. */
  
      /* Source Map Options */
      // "sourceRoot": "",                            /* Specify the location where debugger should locate TypeScript files instead of source locations. */
      // "mapRoot": "",                               /* Specify the location where debugger should locate map files instead of generated locations. */
      // "inlineSourceMap": true,                     /* Emit a single file with source maps instead of having a separate file. */
      // "inlineSources": true,                       /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */
  
      /* Experimental Options */
      // "experimentalDecorators": true,              /* Enables experimental support for ES7 decorators. */
      // "emitDecoratorMetadata": true,               /* Enables experimental support for emitting type metadata for decorators. */
  
      /* Advanced Options */
      "skipLibCheck": true /* Skip type checking of declaration files. */,
      "forceConsistentCasingInFileNames": true /* Disallow inconsistently-cased references to the same file. */
    },
    "include": ["./cypress/**/*"],
  }


================================================
FILE: .eslintignore
================================================
# Javascript builds
node_modules
dist
tsc_out
.out
.changelog
.DS_Store
coverage
.cache
.tmp
.eslintcache
generated
__tests__

# package managers
lerna-debug.log

# IDEs and editors
.idea
.project
.classpath
.c9
*.launch
.settings
*.sublime-workspace
.history
.vscode
.yo-rc.json

# IDE - VSCode
.vscode
# For vim
*.swp

public


================================================
FILE: .eslintrc-md.json
================================================
{
  "plugins": [
    "markdown",
    "react"
  ],
  "parserOptions": {
    "ecmaVersion": 9,
    "sourceType": "module",
    "ecmaFeatures": {
      "jsx": true
    }
  },
  "settings": {
    "react": {
      "version": "16.4.0"
    }
  },
  "rules": {
    "eol-last": 2,
    "spaced-comment": 2,
    "no-unused-vars": 0,
    "no-this-before-super": 2,
    "react/jsx-uses-react": "error",
    "react/jsx-uses-vars": "error",
    "react/no-unknown-property": 2,
    "react/jsx-no-undef": 2
  }
}


================================================
FILE: .eslintrc.json
================================================
{
  "env": {
    "browser": true,
    "node": true,
    "es6": true
  },
  "extends": [
    "eslint:recommended",
    "plugin:react/recommended",
    "plugin:react-hooks/recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:prettier/recommended"
  ],
  "overrides": [
    {
      "files": ["**/patternfly-docs/pages/*"],
      "rules": {
        "arrow-body-style": "off"
      }
    }
  ],
  "parserOptions": {
    "ecmaVersion": "latest",
    "sourceType": "module",
    "ecmaFeatures": {
      "jsx": true
    }
  },
  "settings": {
    "react": {
      "version": "detect"
    }
  },
  "plugins": ["react", "react-hooks", "@typescript-eslint"],
  "rules": {
    "@typescript-eslint/adjacent-overload-signatures": "error",
    "@typescript-eslint/array-type": "error",
    "@typescript-eslint/consistent-type-assertions": "error",
    "@typescript-eslint/consistent-type-definitions": "error",
    "@typescript-eslint/no-misused-new": "error",
    "@typescript-eslint/no-namespace": "error",
    "@typescript-eslint/no-unused-vars": [
      "error",
      {
        "argsIgnorePattern": "^_"
      }
    ],
    "@typescript-eslint/prefer-for-of": "error",
    "@typescript-eslint/prefer-function-type": "error",
    "@typescript-eslint/prefer-namespace-keyword": "error",
    "@typescript-eslint/unified-signatures": "error",
    "@typescript-eslint/no-var-requires": "off",
    "arrow-body-style": "error",
    "camelcase": [
      "error",
      {
        "ignoreDestructuring": true
      }
    ],
    "constructor-super": "error",
    "curly": "error",
    "dot-notation": "error",
    "eqeqeq": ["error", "smart"],
    "guard-for-in": "error",
    "indent": ["error", 2, {"SwitchCase":  1}],
    "max-classes-per-file": ["error", 1],
    "no-nested-ternary": "error",
    "no-bitwise": "error",
    "no-caller": "error",
    "no-cond-assign": "error",
    "no-console": "error",
    "no-debugger": "error",
    "no-empty": "error",
    "no-eval": "error",
    "no-new-wrappers": "error",
    "no-undef-init": "error",
    "no-unsafe-finally": "error",
    "no-unused-expressions": [
      "error",
      {
        "allowTernary": true,
        "allowShortCircuit": true
      }
    ],
    "no-unused-labels": "error",
    "no-var": "error",
    "object-shorthand": "error",
    "object-curly-spacing": ["error", "always"],
    "one-var": ["error", "never"],
    "prefer-const": "error",
    "radix": ["error", "as-needed"],
    "react/prop-types": 0,
    "react/display-name": 0,
    "react-hooks/exhaustive-deps": "warn",
    "react/no-unescaped-entities": ["error", { "forbid": [">", "}"] }],
    "spaced-comment": "error",
    "use-isnan": "error"
  }
}



================================================
FILE: .prettierignore
================================================
# Javascript builds
node_modules
dist
tsc_out
.out
.changelog
.DS_Store
coverage
.cache
.tmp
.eslintcache
generated

# package managers
lerna-debug.log

# IDEs and editors
.idea
.project
.classpath
.c9
*.launch
.settings
*.sublime-workspace
.history
.vscode
.yo-rc.json

# IDE - VSCode
.vscode
# For vim
*.swp

public


================================================
FILE: .prettierrc.json
================================================
{
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "none",
  "useTabs": false,
  "printWidth": 120
}



================================================
FILE: config/globalSetup.js
================================================

module.exports = async () => {
  process.env.TZ = 'UTC';
};


================================================
FILE: config/setupTests.js
================================================
/* eslint-disable no-unused-vars */
import 'whatwg-fetch';
import 'babel-polyfill';
import '@testing-library/jest-dom';

global.SVGPathElement = function () {};

global.MutationObserver = class {
  constructor(callback) {}
  disconnect() {}
  observe(element, initObject) {}
};

global.window.insights = {
  ...(window.insights || {}),
  chrome: {
    ...((window.insights && window.insights.chrome) || {}),
    auth: {
      ...((window.insights && window.insights.chrome && window.insights.chrome) || {}),
      getUser: () =>
        new Promise((res) =>
          res({
            identity: {
              // eslint-disable-next-line camelcase
              account_number: '0',
              type: 'User',
              user: {
                // eslint-disable-next-line camelcase
                is_org_admin: true,
              },
            },
          })
        ),
    },
    getUserPermissions: () => new Promise((res) => res([])),
    isBeta: () => false,
  },
};
jest.mock('react', () => ({
  ...jest.requireActual('react'),
  useLayoutEffect: jest.requireActual('react').useEffect,
}));
Element.prototype.scrollTo = () => {};


================================================
FILE: config/webpack.cy.config.js
================================================
const path = require('path');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

/** @type { import("webpack").Configuration } */
const JSConfig = {
  module: {
    rules: [
      {
        test: /\.(js|ts)x?$/,
        exclude: /node_modules/,
        use: {
          loader: 'swc-loader',
          options: {
            jsc: {
              parser: {
                syntax: 'typescript',
                tsx: true
              }
            }
          }
        }
      },
      {
        test: /\.s?[ac]ss$/,
        use: [
          MiniCssExtractPlugin.loader,
          'css-loader',
          {
            loader: 'sass-loader',
            options: {
              sourceMap: true
            }
          }
        ]
      },
      {
        test: /\.(jpe?g|svg|png|gif|ico|eot|ttf|woff2?)(\?v=\d+\.\d+\.\d+)?$/i,
        type: 'asset/resource'
      }
    ]
  },
  resolve: {
    extensions: ['.tsx', '.ts', '.js']
  },
  output: {
    filename: 'bundle.js',
    hashFunction: 'xxhash64',
    path: path.resolve(__dirname, 'dist')
  },
  cache: {
    type: 'filesystem',
    buildDependencies: {
      config: [__filename]
    },
    cacheDirectory: path.resolve(__dirname, '../.cypress-cache')
  },
  stats: {
    errorDetails: true
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: '[name].[contenthash].css'
    })
  ]
};

module.exports = JSConfig;



================================================
FILE: cypress/tsconfig.json
================================================
{
  "compilerOptions": {
    "sourceMap": false,
    "noImplicitAny": true,
    "module": "esnext",
    "target": "esnext",
    "jsx": "react",
    "moduleResolution": "node",
    "removeComments": false,
    "strict": true,
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "baseUrl": "./",
    "types": ["cypress", "node"]
  },
  "include": ["./**/*.ts", "./**/*.tsx"],
  "exclude": [
    "../src/**/*.test.ts",
    "../src/**/*.test.tsx",
    "../src/**/*.spec.tsx",
    "../src/**/*.spec.ts",
    "../src/**/__mocks__/**/*.ts",
    "../src/**/__mocks__/**/*.tx",
  ]
}



================================================
FILE: cypress/fixtures/example.json
================================================
{
  "name": "Using fixtures to represent data",
  "email": "hello@cypress.io",
  "body": "Fixtures are a great way to mock data for responses to routes"
}



================================================
FILE: cypress/support/commands.ts
================================================
// / <reference types="cypress" />
// ***********************************************
// This example commands.ts shows you how to
// create various custom commands and overwrite
// existing commands.
//
// For more comprehensive examples of custom
// commands please read more here:
// https://on.cypress.io/custom-commands
// ***********************************************
//
//
// -- This is a parent command --
// Cypress.Commands.add('login', (email, password) => { ... })
//
//
// -- This is a child command --
// Cypress.Commands.add('drag', { prevSubject: 'element'}, (subject, options) => { ... })
//
//
// -- This is a dual command --
// Cypress.Commands.add('dismiss', { prevSubject: 'optional'}, (subject, options) => { ... })
//
//
// -- This will overwrite an existing command --
// Cypress.Commands.overwrite('visit', (originalFn, url, options) => { ... })
//
// declare global {
//   namespace Cypress {
//     interface Chainable {
//       login(email: string, password: string): Chainable<void>
//       drag(subject: string, options?: Partial<TypeOptions>): Chainable<Element>
//       dismiss(subject: string, options?: Partial<TypeOptions>): Chainable<Element>
//       visit(originalFn: CommandOriginalFn, url: string, options: Partial<VisitOptions>): Chainable<Element>
//     }
//   }
// }


================================================
FILE: cypress/support/component-index.html
================================================
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>Components App</title>
  </head>
  <body>
    <div data-cy-root></div>
  </body>
</html>


================================================
FILE: cypress/support/component.ts
================================================
/* eslint-disable @typescript-eslint/no-namespace */
// ***********************************************************
// This example support/component.ts is processed and
// loaded automatically before your test files.
//
// This is a great place to put global configuration and
// behavior that modifies Cypress.
//
// You can change the location of this file or turn off
// automatically serving support files with the
// 'supportFile' configuration option.
//
// You can read more here:
// https://on.cypress.io/configuration
// ***********************************************************

// Import commands.js using ES2015 syntax:
import './commands'

// Alternatively you can use CommonJS syntax:
// require('./commands')

import { mount } from 'cypress/react18'

// Patternfly
import '@patternfly/patternfly/patternfly.css';
// Patternfly utilities
import '@patternfly/patternfly/patternfly-addons.css';
// Global theme CSS
import '@patternfly/documentation-framework/global.css';

// Augment the Cypress namespace to include type definitions for
// your custom command.
// Alternatively, can be defined in cypress/support/component.d.ts
// with a <reference path="./component" /> at the top of your spec.
declare global {
  namespace Cypress {
    interface Chainable {
      mount: typeof mount
    }
  }
}

Cypress.Commands.add('mount', mount)

// Example use:
// cy.mount(<MyComponent />)


================================================
FILE: cypress/support/e2e.ts
================================================
// ***********************************************************
// This example support/e2e.ts is processed and
// loaded automatically before your test files.
//
// This is a great place to put global configuration and
// behavior that modifies Cypress.
//
// You can change the location of this file or turn off
// automatically serving support files with the
// 'supportFile' configuration option.
//
// You can read more here:
// https://on.cypress.io/configuration
// ***********************************************************

// Import commands.js using ES2015 syntax:
import './commands'

// Alternatively you can use CommonJS syntax:
// require('./commands')


================================================
FILE: packages/module/generate-fed-package-json.js
================================================
const fse = require('fs-extra');
const glob = require('glob');
const path = require('path');

const root = process.cwd();

const sourceFiles = glob.sync(`${root}/src/*/`).map((name) => name.replace(/\/$/, ''));

const indexTypings = glob.sync(`${root}/src/index.d.ts`);

const ENV_AGNOSTIC_ROOT = `${root}/dist/dynamic`;

async function copyTypings(files, dest) {
  const cmds = [];
  files.forEach((file) => {
    const fileName = file.split('/').pop();
    cmds.push(fse.copyFile(file, `${dest}/${fileName}`));
  });
  return Promise.all(cmds);
}

async function createPackage(file) {
  const fileName = file.split('/').pop();
  const esmSource = glob.sync(`${root}/dist/esm/${fileName}/**/index.js`)[0];
  const cjsSource = glob.sync(`${root}/dist/cjs/${fileName}/**/index.js`)[0];
  const typingsSource = glob.sync(`${root}/dist/esm/${fileName}/**/index.d.ts`)[0];
  /**
   * Prevent creating package.json for directories with no JS files (like CSS directories)
   */
  if (!esmSource) {
    return;
  }

  const destDir = path.resolve(`${ENV_AGNOSTIC_ROOT}`, fileName);
  const destFile = `${destDir}/package.json`;

  // ensure the directory exists
  fse.ensureDirSync(destDir);

  const esmRelative = path.relative(file, esmSource).replace('/dist', '');
  const cjsRelative = path.relative(file, cjsSource).replace('/dist', '');
  const tsRelative = path.relative(file, typingsSource).replace('/dist', '');
  const content = {
    main: cjsRelative,
    module: esmRelative
  };
  const typings = glob.sync(`${root}/src/${fileName}/*.d.ts`);
  const cmds = [];
  content.typings = tsRelative;
  cmds.push(copyTypings(typings, `${root}/dist/${fileName}`));
  cmds.push(fse.writeJSON(destFile, content));
  return Promise.all(cmds);
}

async function generatePackages(files) {
  // ensure the dynamic root exists
  fse.ensureDirSync(path.resolve(ENV_AGNOSTIC_ROOT));
  const cmds = files.map((file) => createPackage(file));
  return Promise.all(cmds);
}

async function run(files) {
  try {
    await generatePackages(files);
    if (indexTypings.length === 1) {
      copyTypings(indexTypings, root);
    }
  } catch (error) {
    // eslint-disable-next-line no-console
    console.error(error);
    process.exit(1);
  }
}

run(sourceFiles);



================================================
FILE: packages/module/generate-index.js
================================================
const fse = require('fs-extra');
const glob = require('glob');
const path = require('path');

const root = process.cwd();

const ENV_AGNOSTIC_ROOT = `${root}/src`;

const sourceFiles = glob.sync(path.resolve(__dirname, './src/*/index.ts'));

async function generateIndex(files) {
  // ensure the dynamic root exists
  fse.ensureDirSync(path.resolve(ENV_AGNOSTIC_ROOT));

  const destFile = `${ENV_AGNOSTIC_ROOT}/index.ts`;

  const stream = fse.createWriteStream(destFile);
  stream.once('open', () => {
    stream.write('// this file is autogenerated by generate-index.js, modifying it manually will have no effect\n');

    files.forEach((file) => {
      const name = file.replace('/index.ts', '').split('/').pop();
      stream.write(`\nexport { default as ${name} } from './${name}';\n`);
      stream.write(`export * from './${name}';\n`);
    });
    stream.end();
  });

  return Promise.resolve();
}

async function run(files) {
  try {
    await generateIndex(files);
  } catch (error) {
    // eslint-disable-next-line no-console
    console.error(error);
    process.exit(1);
  }
}

run(sourceFiles);



================================================
FILE: packages/module/package.json
================================================
{
  "name": "@patternfly/chatbot",
  "version": "1.0.0",
  "description": "This library provides React components based on PatternFly 6 that can be used to build chatbots.",
  "main": "dist/cjs/index.js",
  "module": "dist/esm/index.js",
  "scripts": {
    "build": "sass src/main.scss dist/css/main.css && npm run build:index && npm run build:js && npm run build:esm && npm run build:fed:packages",
    "build:watch": "npm run build:js && npm run build:esm -- --watch && npm run build:fed:packages -- --watch",
    "build:esm": "tsc --build --verbose ./tsconfig.json",
    "build:fed:packages": "node generate-fed-package-json.js",
    "build:js": "tsc -p tsconfig.cjs.json",
    "build:index": "node generate-index.js",
    "clean": "rimraf dist",
    "docs:develop": "pf-docs-framework start",
    "docs:build": "pf-docs-framework build all --output public",
    "docs:serve": "pf-docs-framework serve public --port 5001",
    "docs:screenshots": "pf-docs-framework screenshots --urlPrefix http://localhost:5001",
    "test:a11y": "patternfly-a11y --config patternfly-a11y.config",
    "serve:a11y": "serve coverage"
  },
  "repository": "git+https://github.com/patternfly/chatbot.git",
  "author": "Red Hat",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/patternfly/chatbot/issues"
  },
  "homepage": "https://github.com/patternfly/chatbot#readme",
  "publishConfig": {
    "access": "public",
    "tag": "prerelease"
  },
  "dependencies": {
    "@patternfly/react-core": "^6.1.0",
    "@patternfly/react-code-editor": "^6.1.0",
    "@patternfly/react-icons": "^6.1.0",
    "@patternfly/react-table": "^6.1.0",
    "@segment/analytics-next": "^1.76.0",
    "posthog-js": "^1.194.4",
    "clsx": "^2.1.0",
    "framer-motion": "^11.3.28",
    "react-markdown": "^9.0.1",
    "react-syntax-highlighter": "^15.5.0",
    "remark-gfm": "^4.0.0",
    "rehype-unwrap-images": "^1.0.0",
    "rehype-external-links": "^3.0.0",
    "rehype-sanitize": "^6.0.0",
    "path-browserify": "^1.0.1"
  },
  "peerDependencies": {
    "react": "^17 || ^18",
    "react-dom": "^17 || ^18"
  },
  "devDependencies": {
    "@patternfly/documentation-framework": "6.8.2",
    "@patternfly/patternfly": "^6.1.0",
    "@patternfly/patternfly-a11y": "^5.0.0",
    "@types/dom-speech-recognition": "^0.0.4",
    "@types/react": "^18.2.61",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "rimraf": "^2.7.1",
    "typescript": "^5.3.3",
    "@octokit/rest": "^18.0.0",
    "victory-core": "^37.1.1",
    "victory-scatter": "^37.1.1",
    "victory-pie": "^37.1.1",
    "victory-stack": "^37.1.1",
    "victory-legend": "^37.1.1",
    "victory-line": "^37.1.1",
    "victory-group": "^37.1.1",
    "victory-voronoi-container": "^37.1.1",
    "victory-create-container": "^37.1.1",
    "victory-cursor-container": "^37.1.1",
    "victory-tooltip": "^37.1.1",
    "victory-bar": "^37.1.1"
  },
  "overrides": {
    "puppeteer": "^23.6.1",
    "puppeteer-cluster": "^0.24.0"
  }
}



================================================
FILE: packages/module/patternfly-a11y.config.js
================================================
const { fullscreenRoutes } = require('@patternfly/documentation-framework/routes');

/**
 * Wait for a selector before running axe
 *
 * @param page page from puppeteer
 */
async function waitFor(page) {
  await page.waitForSelector('#root > *');
}

const urls = Object.keys(fullscreenRoutes)
  .map((key) => (fullscreenRoutes[key].isFullscreenOnly ? key : fullscreenRoutes[key].path.replace(/\/react$/, '')))
  .reduce((result, item) => (result.includes(item) ? result : [...result, item]), []);

module.exports = {
  prefix: 'http://localhost:5001',
  waitFor,
  crawl: false,
  urls: [...urls],
  ignoreRules: [
    'color-contrast',
    'landmark-no-duplicate-main',
    'landmark-main-is-top-level',
    'scrollable-region-focusable'
  ].join(','),
  ignoreIncomplete: true
};



================================================
FILE: packages/module/release.config.js
================================================
module.exports = {
  branches: [
    'do-not-delete',
    { name: 'main', channel: 'prerelease', prerelease: 'prerelease' },
    { name: 'v5', channel: 'prerelease-5', range: '5.x' }
  ],
  analyzeCommits: {
    preset: 'angular'
  },
  plugins: [
    '@semantic-release/commit-analyzer',
    '@semantic-release/release-notes-generator',
    '@semantic-release/github',
    '@semantic-release/npm'
  ],
  tagFormat: 'prerelease-v${version}',
  dryRun: false
};



================================================
FILE: packages/module/tsconfig.cjs.json
================================================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist/cjs",
    "module": "commonjs"
  }
}
  


================================================
FILE: packages/module/tsconfig.json
================================================
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig.json to read more about this file */

    /* Basic Options */
    // "incremental": true,                         /* Enable incremental compilation */
    "target": "es2015" /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', 'ES2021', or 'ESNEXT'. */,
    "module": "es2015" /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */,
    // "lib": [],                                   /* Specify library files to be included in the compilation. */
    // "allowJs": true,                             /* Allow javascript files to be compiled. */
    // "checkJs": true,                             /* Report errors in .js files. */
    "jsx": "react" /* Specify JSX code generation: 'preserve', 'react-native', 'react', 'react-jsx' or 'react-jsxdev'. */,
    "declaration": true /* Generates corresponding '.d.ts' file. */,
    // "declarationMap": true,                      /* Generates a sourcemap for each corresponding '.d.ts' file. */
    // "sourceMap": true,                           /* Generates corresponding '.map' file. */
    // "outFile": "./",                             /* Concatenate and emit output to single file. */
    "outDir": "./dist/esm" /* Redirect output structure to the directory. */,
    "rootDir": "./src" /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */,
    // "composite": true,                           /* Enable project compilation */
    // "tsBuildInfoFile": "./",                     /* Specify file to store incremental compilation information */
    // "removeComments": true,                      /* Do not emit comments to output. */
    // "noEmit": true,                              /* Do not emit outputs. */
    // "importHelpers": true,                       /* Import emit helpers from 'tslib'. */
    // "downlevelIteration": true,                  /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */
    // "isolatedModules": true,                     /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */

    /* Strict Type-Checking Options */
    "strict": true /* Enable all strict type-checking options. */,
    "noImplicitAny": false,                       /* Raise error on expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,                    /* Enable strict null checks. */
    // "strictFunctionTypes": true,                 /* Enable strict checking of function types. */
    // "strictBindCallApply": true,                 /* Enable strict 'bind', 'call', and 'apply' methods on functions. */
    // "strictPropertyInitialization": true,        /* Enable strict checking of property initialization in classes. */
    // "noImplicitThis": true,                      /* Raise error on 'this' expressions with an implied 'any' type. */
    // "alwaysStrict": true,                        /* Parse in strict mode and emit "use strict" for each source file. */

    /* Additional Checks */
    // "noUnusedLocals": true,                      /* Report errors on unused locals. */
    // "noUnusedParameters": true,                  /* Report errors on unused parameters. */
    // "noImplicitReturns": true,                   /* Report error when not all code paths in function return a value. */
    // "noFallthroughCasesInSwitch": true,          /* Report errors for fallthrough cases in switch statement. */
    // "noUncheckedIndexedAccess": true,            /* Include 'undefined' in index signature results */
    // "noImplicitOverride": true,                  /* Ensure overriding members in derived classes are marked with an 'override' modifier. */
    // "noPropertyAccessFromIndexSignature": true,  /* Require undeclared properties from index signatures to use element accesses. */

    /* Module Resolution Options */
    "moduleResolution": "node" /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */,
    // "baseUrl": "./",                             /* Base directory to resolve non-absolute module names. */
    // "paths": {},                                 /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */
    // "rootDirs": [],                              /* List of root folders whose combined content represents the structure of the project at runtime. */
    // "typeRoots": [],                             /* List of folders to include type definitions from. */
    // "types": [],                                 /* Type declaration files to be included in compilation. */
    // "allowSyntheticDefaultImports": true,        /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */
    "esModuleInterop": true /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */,
    // "preserveSymlinks": true,                    /* Do not resolve the real path of symlinks. */
    // "allowUmdGlobalAccess": true,                /* Allow accessing UMD globals from modules. */

    /* Source Map Options */
    // "sourceRoot": "",                            /* Specify the location where debugger should locate TypeScript files instead of source locations. */
    // "mapRoot": "",                               /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSourceMap": true,                     /* Emit a single file with source maps instead of having a separate file. */
    // "inlineSources": true,                       /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */

    /* Experimental Options */
    // "experimentalDecorators": true,              /* Enables experimental support for ES7 decorators. */
    // "emitDecoratorMetadata": true,               /* Enables experimental support for emitting type metadata for decorators. */

    /* Advanced Options */
    "skipLibCheck": true /* Skip type checking of declaration files. */,
    "forceConsistentCasingInFileNames": true /* Disallow inconsistently-cased references to the same file. */
  },
  "include": ["./src/*", "./src/**/*", "./cypress/**/*"],
}



================================================
FILE: packages/module/@types/index.d.ts
================================================
/* eslint-disable @typescript-eslint/no-explicit-any */
declare module '*.svg' {
  const value: any;
  export = value;
}
declare module '*.png' {
  const value: any;
  export = value;
}



================================================
FILE: packages/module/patternfly-docs/patternfly-docs.config.js
================================================
// This module is shared between NodeJS and babelled ES5
module.exports = {
  sideNavItems: [{ section: 'PatternFly-AI' }],
  topNavItems: [],
  hasDarkThemeSwitcher: true,
  hasRTLSwitcher: true,
  port: 8006
};



================================================
FILE: packages/module/patternfly-docs/patternfly-docs.css.js
================================================
// Patternfly
import '@patternfly/patternfly/patternfly.css';
// Patternfly utilities
import '@patternfly/patternfly/patternfly-addons.css';
// Global theme CSS
import '@patternfly/documentation-framework/global.css';

// Add your extension CSS below
import '@patternfly/chatbot/dist/css/main.css';



================================================
FILE: packages/module/patternfly-docs/patternfly-docs.routes.js
================================================
// This module is shared between NodeJS and babelled ES5
const isClient = Boolean(process.env.NODE_ENV);

module.exports = {
  '/': {
    SyncComponent: isClient && require('./pages/index').default
  },
  '/404': {
    SyncComponent: isClient && require('@patternfly/documentation-framework/pages/404/index').default,
    title: '404 Error'
  }
};



================================================
FILE: packages/module/patternfly-docs/patternfly-docs.source.js
================================================
const path = require('path');

module.exports = (sourceMD, sourceProps) => {
  // Parse source content for props so that we can display them
  const propsIgnore = ['**/*.test.tsx', '**/examples/*.tsx'];
  const extensionPath = path.join(__dirname, '../src');
  sourceProps(path.join(extensionPath, '/**/*.tsx'), propsIgnore);

  // Parse md files
  const contentBase = path.join(__dirname, './content');
  sourceMD(path.join(contentBase, 'extensions/**/*.md'), 'PatternFly-AI');

  /**
    If you want to parse content from node_modules instead of providing a relative/absolute path,
    you can do something similar to this:
    const extensionPath = require
      .resolve('@patternfly/react-log-viewer/package.json')
      .replace('package.json', 'src');
    sourceProps(path.join(extensionPath, '/**\/*.tsx'), propsIgnore);
    sourceMD(path.join(extensionPath, '../patternfly-docs/**\/examples/*.md'), 'react');
    sourceMD(path.join(extensionPath, '../patternfly-docs/**\/demos/*.md'), 'react-demos');
    sourceMD(path.join(extensionPath, '../patternfly-docs/**\/design-guidelines/*.md'), 'design-guidelines');
  */
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/about-chatbot.md
================================================
---
section: PatternFly-AI
subsection: ChatBot
id: Overview
sortValue: 1
source: About
---

**Note:** The PatternFly ChatBot extension lives in its own package [`@patternfly/chatbot`](https://www.npmjs.com/package/@patternfly/chatbot)

It is important to leverage AI in a way that improves the experiences of your users. In alignment with our [AI principles](/patternfly-ai/about-ai#ai-principles) and [ethical design guidelines,](/patternfly-ai/ai-guidelines) we've created this ChatBot extension. The PatternFly ChatBot contains a React implementation of an AI ChatBot, to provide your users with access to convenient and persistent help.

_Only use this ChatBot when it adds value to your users' experiences._ Don't use it simply for the sake of novelty&mdash;your users will only be excited to interact with a new ChatBot feature if it directly helps them reach their goals.

## ChatBot demos

To illustrate the capabilities of the ChatBot, including more complex interaction patterns, we've created these demos: 
- [Basic ChatBot](/patternfly-ai/chatbot/overview/demo#basic-chatbot)
- [Embedded ChatBot](/patternfly-ai/chatbot/overview/demo#embedded-chatbot)
- [Comparing ChatBots](/patternfly-ai/chatbot/overview/demo/#comparing-chatbots)
- [Message feedback](/patternfly-ai/chatbot/messages/demo#message-feedback)
- [ChatBot attachments via file upload](/patternfly-ai/chatbot/messages/demo#attach-via-upload-button-in-message-bar)
- [ChatBot attachments via built-in menu](/patternfly-ai/chatbot/messages/demo#attach-via-menu-of-options-in-message-bar)

To learn how to write for ChatBot experiences, refer to our [conversation design guidelines](/patternfly-ai/conversation-design/#writing-for-chatbots).

To learn how to design ChatBot experiences, [refer to the design guidelines](/patternfly-ai/chatbot/overview/design-guidelines).

Explore our documentation, which covers both ChatBot UI components and message-related components:
- UI
    - [Structural elements](/patternfly-ai/chatbot/ui#structure)
    - [Toggle](/patternfly-ai/chatbot/ui#toggle)
    - [Header](/patternfly-ai/chatbot/ui#header)
    - [Footer](/patternfly-ai/chatbot/ui#footer)
    - [Navigation](/patternfly-ai/chatbot/ui#navigation)
    - [Modals](/patternfly-ai/chatbot/ui#modals)
- Messages
    - [Bot and user messages](/patternfly-ai/chatbot/messages)
    - [File attachments](/patternfly-ai/chatbot/messages#attachments)
- Analytics support
    - [Overview](/patternfly-ai/chatbot/analytics)
  

We will continue to grow and evolve our ChatBot. If you notice a bug or have any suggestions, feel free to file an issue in our [GitHub repository!](https://github.com/patternfly/chatbot/issues) Make sure to check if there is already a pre-existing issue before creating a new one.



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/design-guidelines.md
================================================
---
section: PatternFly-AI
subsection: ChatBot
id: Overview
sortValue: 1
source: design-guidelines
---

import "./images.css"

## Elements 

<div class="ws-docs-content-img">
![Main elements of a ChatBot.](./img/chatbot-elements.svg)
</div>

1. **Container:** The window that contains the entire ChatBot experience and all of its components.
1. **Header:** A persistent region at the top of the ChatBot window that contains navigation, branding, and actions.
1. **History menu:** A menu that contains a conversation history of previous chats.
1. **Options menu:** A menu that contains settings that are relevant to your product. This typically includes display options (more details in the [ChatBot variations section](#variations)) and other general settings (more details in the [ChatBot settings and preferences section](#chatbot-settings-and-preferences)).
1. **Messages:** Elements of the conversation between a ChatBot and user. More details can be found in the [message guidelines](#messages).
1. **Attachments:** Details about files that a user has uploaded to the ChatBot.
1. **Footer:** A persistent region at the bottom of the ChatBot window that contains the message bar and the footnote.
1. **Footnote (optional):** A persistent, short message that contains any legal disclaimers or important information about the ChatBot. Footnotes are optional, but strongly recommended. More details can be found in the [footnote guidelines](#footnotes).
1. **Toggle:** The button that allows users to open and close the ChatBot window. When the ChatBot is opened, the toggle should appear below the ChatBot window. The toggle shape and icon can be customized as needed, as shown in these [ChatBot toggle examples](/patternfly-ai/chatbot/ui#custom-toggle-icon). More details can be found in the [guidelines for accessing a ChatBot](#accessing-a-chatbot).

### Messages

<div class="ws-docs-content-img">
![A basic user message, bot message, and quick reply buttons.](./img/message-elements.svg)
</div>

1. **User message:** Messages that the user has sent to the ChatBot.
1. **Bot message:** Messages from the ChatBot, which are marked with an "AI" label to communicate the use of AI to users. You should choose a descriptive name for your ChatBot.
1. **Avatar:** Representative image for your ChatBot and the user. ChatBot avatars should align with your product's brand and any existing brand standards.
1. **Name:** Identifier for your ChatBot and the user. Choose a name for your ChatBot that users can easily identify as a bot.
1. **Timestamp:** The relative or absolute time that a message was sent.
1. **Label:** Labels ChatBot messages as "AI."
1. **Quick responses:** Programmable, clickable actions that allow users to quickly answer questions from the ChatBot.
1. **Message actions:** Actions that allow users to interact with a bot message. These typically include providing feedback, copying, sharing, or reading aloud, but [custom message actions](/patternfly-ai/chatbot/messages#custom-message-actions) are also supported. More details for the feedback actions can be found in the [message feedback](#message-feedback) section.

#### Welcome message

At the start of a new chat, you should welcome your users to the ChatBot with a greeting.

If you have user details from their account information, you can personalize this greeting with their username or name. If you don't have this information, or if you'd prefer to not use their personal details, you should instead introduce the ChatBot: 

<div class="ws-docs-content-img">
![Welcome messages.](./img/welcome-message.svg)
</div>

To help users get started quickly, it can also be helpful to include welcome prompts. When selected, these prompts will become the user's first message to the ChatBot, which the bot will immediately begin to reply to. To avoid overloading your users, present no more than 3 prompts at a time.

<div class="ws-docs-content-img">
![Welcome message with prompts.](./img/welcome-elements.svg)
</div>

#### Source tiles

A ChatBot can share relevant sources with users, like documentation that could provide the information a user is searching for. These sources will be contained in a single tile, which users can paginate through and select to navigate to other resources. 

To provide users with enough context, sources should have descriptive titles and descriptions. The title is limited to 1 line and the body is limited to 2 lines.

<div class="ws-docs-content-img">
![Bot message that include multiple source tiles.](./img/source-tile.svg)
</div>

#### Quick start tiles

A ChatBot can share a link to a [quick start](/extensions/quick-starts) that will help users complete a given task. Users can either select **Start** or the tile's title to initiate the linked quick start.

<div class="ws-docs-content-img">
![Bot message that links a quick start tile.](./img/chatbot-quickstarts-tile.svg)
</div>

Selecting the quick start title, or the "Start" link can be configured to launch the quick start in a new window, as an interactive bot conversation within the ChatBot window, or as a separate tab within the ChatBot drawer (as shown in this [quick start/ChatBot concept demo](https://quickstart-chatbot-demo.surge.sh/?quickstart=install-app-and-associate-pipeline)).

### Message actions 

To allow users to interact with bot messages, utilize message actions. Refer to [the message actions React example](/patternfly-ai/chatbot/messages#message-actions) for an interactive visual.

The following actions can be used for some of the most common interactions:

<div class="ws-docs-content-img">
![Default message response actions.](./img/message-responses.svg)
</div>

1. **Feedback (good response):** Applies a positive rating to the message.
1. **Feedback (bad response):** Applies a negative rating to the message.
1. **Copy:** Copies the message content to the clipboard.
1. **Listen:** Reads the message content out loud.

You can also use [custom message actions](/patternfly-ai/chatbot/messages#custom-message-actions) as needed for your particular use case. When using custom actions, be sure to add a tooltip that describes the effect that the action will have. For more information, view [our tooltips guidelines](/ux-writing/tooltips). 

#### Message feedback

A commonly used message response action is rating, which allows users to give feedback on the quality or helpfulness of a bot message. These actions include a thumbs-up icon, for a positive rating, and a thumbs-down icon, for a negative one:

<div class="ws-docs-content-img">
![A pointer clicking on an action button for a bot message.](./img/message-feedback.svg)
</div>

When users select either of these icons, you should present them with either:

1. A thank-you card that confirms a user's response was received. Even if you don't use a feedback form, you should still display the thank-you card, so that users can be confident their rating went through.
<br />
<br />
    <div class="ws-docs-content-img" style="width:75%">
    ![A card displayed beneath a bot message which communicates that feedback was successfully received.](./img/thank-you-card.svg)
    </div>
1. A feedback form that collects more details.
<br />
<br />
    <div class="ws-docs-content-img" style="width:75%">
    ![A form beneath a bot message asking for more details about a user's feedback.](./img/feedback-form.svg)
    </div>

    1. **Close button (optional):** Closes the feedback form. The original feedback response should still be collected.
    1. **Quick responses:** Options for users to provide more context around their rating. Customize these to make the most sense for your product. You can present positive and negative options based on the response type originally selected.
    1. **Text area (optional):** Allows users to provide additional written detail if they'd like.
    1. **Submit button:** Submits the feedback form and triggers the   thank-you card.

### Message bar

To message the ChatBot, users can type directly into the message bar in the footer or click any included actions.

<div class="ws-docs-content-img">
![Elements of a message bar, including input actions.](./img/message-bar-elements.svg)
</div>

1. **Attach button:** Allows users to upload files from their computer.
1. **Use microphone button:** Supports speech recognition to allow users to use voice input. This feature is currently only available in Chrome and Safari.
1. **Send button:** Allows users to send a typed message. This button should be disabled until a user has input text.

When a user chooses to use speech input via the microphone button, the button will display a pulsing animation to indicate that the ChatBot is listening to the user (as shown in [this speech recognition example](/patternfly-ai/chatbot/ui#message-bar-with-speech-recognition-and-file-attachment)).

<div class="ws-docs-content-img">
![Animation phases of the listening button in the message bar.](./img/listening-pulse.svg)
</div>

When a bot is responding (or "streaming") to the user, a stop button will be displayed as the only action in the message bar. Selecting this button will halt the bot's message where it's at.

<div class="ws-docs-content-img">
![Stop button in the message bar.](./img/stop-button.svg)
</div>

### Footnotes

The footnote provides a persistent space to display messaging about your product's Terms and Conditions, which focus on the rules of using the service, and Privacy Policy, which focuses on the handling of personal data.

Though footnotes are not required, they are highly recommended to ensure legal compliance, establish user trust, and clearly define the usage guidelines and data handling practices.

When users select the footnote, you can display a popover that provides more information than would fit in the footnote:

<div class="ws-docs-content-img">
![Selected footnote, with an informative popover.](./img/footnote.svg)
</div>

## Usage

When ChatBots are designed to meet the needs of your users, they can improve the overall UX of your product by offering convenient, efficient, and persistent support. When your ChatBot cannot find an answer for your users, you must provide them with a method to contact human support.

Before building a ChatBot, make sure that you have justified it as an appropriate solution by asking yourself these questions:

- What are the users’ goals?
- How in-depth is the assistance the user will need?
- Does human assistance better serve your users?
- How is a ChatBot superior to online documentation, contextual support or wizards?
- What data sources or abilities can this ChatBot leverage to assist your users?

Do not create a ChatBot simply for the sake of novelty.

### When to use a ChatBot

Use a ChatBot to offer your users on-demand help at any time, including:

- Technical support and troubleshooting.
- Product information and documentation.
- Sales and product recommendations.
- Training and onboarding.
- System monitoring and alerts.
- Community engagement.
- Feedback collection and surveys.

### When not to use a ChatBot

Do not use a ChatBot when:

- A task could be accomplished more efficiently through the UI.
- A process is very complex or could take a long time.
- A real human is needed for sensitive or emotional topics.

## Behavior

### Accessing a ChatBot

The ChatBot toggle is the access point for users&mdash;place it in either of the following UI locations: 
- **Floating toggle:** Consistently located in the bottom-right corner of the screen, this persistent button overlays other page content. Use if a masthead toggle would overcomplicate a masthead that already has many utilities.
- **Masthead toggle:** A button that's integrated as a masthead utility. Use this location if a floating toggle would obscure important content.

To help users further identify the toggle, add a "Launch ChatBot" tooltip. You can swap "ChatBot" in the tooltip for your bot's unique name.

<div class="ws-docs-content-img">
![Tooltips for ChatBot toggle.](./img/toggle-tooltips.svg)
</div>

Whichever method you choose, it is critical to be consistent with the toggle location and refer to the following the additional guidelines for each. 

#### Floating toggle
When users click the toggle, the ChatBot window opens and the toggle will change to display an "angle down" icon to indicate that clicking the toggle again will minimize the ChatBot. Users can select the toggle at any point in their journey to open and close the ChatBot as needed.

<div class="ws-docs-content-img">
![2 toggles with open and closed icons.](./img/chatbot-toggle.svg)
</div>

When there is an unread message from the ChatBot, a notification badge should be placed on the toggle.

<div class="ws-docs-content-img">
![Toggle with notification badge.](./img/chatbot-toggle-notification.svg)
</div>

If necessary for brand consistency, you can customize the toggle shape and icon.

<div class="ws-docs-content-img">
![Different toggle shapes and icons.](./img/toggle-customizations.svg)
</div>

#### Masthead toggle 

When the ChatBot toggle is a masthead utility, use the fa-comments icon:

<div class="ws-docs-content-img">
![ChatBot toggle in a masthead.](./img/masthead-toggle.svg)
</div>

The exception to this is if you have a specific icon that aligns with your product or ChatBot branding.

When there is an unread message from the ChatBot, a notification count should be displayed, and the badge should be styled as unread.

<div class="ws-docs-content-img">
![ChatBot toggle in a masthead with a notification count.](./img/masthead-toggle-notification.svg)
</div>

### Launching a ChatBot from page content

If a UI element within the page content is an AI/ChatBot-supported feature, the ChatBot should be launched when users select the clearly-identified action. These kinds of actions should display your ChatBot's logo beside a label that clearly communicates the intention of the AI action.

<div class="ws-docs-content-img">
![Menu item for an AI action that launches a ChatBot.](./img/ai-action-inpage.svg)
</div>

When a ChatBot is launches via an AI-supported action, the action should be sent as a user message once the ChatBot opens.  

<div class="ws-docs-content-img">
![User message in ChatBot for an AI action command.](./img/ai-action-message.svg)
</div>

### Starting a new conversation 

Each time a user begins a new conversation, display a [welcome message, with prompts](#welcome-message) that help them learn what the ChatBot can help with.

As much as possible, the suggested prompts should consider the user’s location in the service or application, or the situation their project is undergoing. 

### Using the conversation history menu

The ChatBot history menu contains a log of a users' previous chats. Clicking the menu icon opens a side drawer in the ChatBot window.

By clicking into the history menu, users can search through previous conversations and perform additional actions, such as sharing a conversation with others.

<div class="ws-docs-content-img">
![Conversation history with an options menu opened on a previous conversation.](./img/conversation-history.svg)
</div>

When the conversation history is still loading, display skeleton items:

<div class="ws-docs-content-img">
![Chat history items loading.](./img/loading-state.svg)
</div>

If there's an error loading the conversation history, display an error screen with steps for resolving the error:

<div class="ws-docs-content-img">
![Error state in chat history.](./img/error-state.svg)
</div>

### ChatBot settings and preferences

Users can access ChatBot settings and preferences via the options menu.

<div class="ws-docs-content-img">
![ChatBot options menu dropdown.](./img/settings-menu.svg)
</div>

Within the settings menu, users can select their preferences for a variety of ChatBot features, like theme or language. You can also support additional content management here, like adding or deleting chats. This menu can be customized to meet the needs of your ChatBot's users.

<div class="ws-docs-content-img">
![ChatBot global settings menu.](./img/chatbot-settings.svg)
</div>

### Attaching files

Using [the attach button](/patternfly-ai/chatbot/overview/design-guidelines#message-bar) in the message bar, users can [attach files](/patternfly-ai/chatbot/messages#file-attachments) to their message to share with the ChatBot.

The attach button can follow a couple of patterns, including:

- Opening the file explorer for a user's operating system
- Opening a menu with attachment options that are chosen by designers and developers

<div class="ws-docs-content-img">
![Menu with file attachment options.](./img/attachment-menu.svg)
</div>

When users attach a file to a message that they're drafting, it will be displayed in the ChatBot footer, above the message bar. This allows them to remove an attachment before sending if necessary:

<div class="ws-docs-content-img">
![Attachment in message bar, before a user has sent the message.](./img/attachment-unsent.svg)
</div>

If a message attachment is successful, a label with the file details will be displayed in the message:

<div class="ws-docs-content-img">
![File attached to user message.](./img/attached-file.svg)
</div>

Users can select the file label to either preview or edit their attachment, as shown in these [attachment examples](/patternfly-ai/chatbot/messages#attachment-preview).

If a message attachment fails, an error message should share the reason for failure:

<div class="ws-docs-content-img">
![Error alert for failed attachment.](./img/attachment-error.svg)
</div>

## Variations

### Display modes

There are a few display modes that users can choose when interacting with a ChatBot.

<div class="ws-docs-content-img">
![Menu of display options.](./img/display-menu.svg)
</div>

1. **Overlay:** The default display mode, which floats the ChatBot window on top of a product's UI. In overlay mode, the ChatBot can be opened and minimized with the toggle.

<div class="ws-docs-content-img">
![ChatBot in overlay mode.](./img/overlay.svg)
</div>

2. **Docked:** Anchors the ChatBot to the side of the page, on top of the page content. 

<div class="ws-docs-content-img">
![ChatBot in docked mode.](./img/docked.svg)
</div>

3. **Embedded:** Places the ChatBot within a product as its own page. An embedded ChatBot could be displayed in the product's navigation menu.

<div class="ws-docs-content-img">
![ChatBot embedded in a product.](./img/embedded.svg)
</div>

4. **Full screen:** Fills the screen with the ChatBot window.

<div class="ws-docs-content-img">
![ChatBot in full-screen mode.](./img/fullscreen.svg)
</div>

5. **Inline drawer**: A ChatBot that can fit and perform within a drawer. This drawer can look different for each product, but will often be placed to the side of the page, inline with the page content.

<div class="ws-docs-content-img">
![ChatBot in drawer mode.](./img/drawer.svg)
</div>

### Layouts

ChatBot supports a side-by-side [comparison layout](/patternfly-ai/chatbot/overview/demo#comparing-chatbots), which allows users to compare 2 chats at once. This can be helpful to let users understand how different models respond to the same prompt.

<div class="ws-docs-content-img">
![2 ChatBots in comparison mode.](./img/comparison.svg)
</div>

## Placement

Your users will expect your ChatBot to be in a reliable, permanent location. Overlay displays are placed in the bottom right of the screen by default. If you're using a full screen or embedded ChatBot, stick to a consistent access location, like a button in the masthead or an item in the navigation menu.

Refer to the additional guidelines for [accessing a ChatBot](#accessing-a-chatbot).

## Content considerations

For guidance on writing ChatBot content, refer to our [conversation design guidelines](/patternfly-ai/conversation-design).

## Accessibility

Although accessibility has been integrated into the design of our ChatBot components, it is important to ensure that your implementation is inclusive of all users. For more guidance, refer to [our accessibility guidelines](/accessibility/about-accessibility).



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/images.css
================================================
.ws-docs-content-img {
    text-align: center;
    margin-inline: auto;
    width: 100%;
    max-width: 700px;
}


================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/Analytics/Analytics.md
================================================
---
# Sidenav top-level section
# should be the same for all markdown files
section: PatternFly-AI
subsection: ChatBot
# Sidenav secondary level section
# should be the same for all markdown files
id: Analytics
source: Analytics
# Tab (react | react-demos | html | html-demos | design-guidelines | accessibility)
# If you use typescript, the name of the interface to display props for
# These are found through the sourceProps function provided in patternfly-docs.source.js
sortValue: 60
---

import "../../images.css"

To gain more insight into the ways that your users interact with your ChatBot, you can add support for **analytics**. To add analytics tracking, you can refer to this guide and configure tracking for the interactions you care about most.

## Elements

This following diagram shows the main components of ChatBot analytics tracking code, as well as the flow of information between components:

<div class="ws-docs-content-img">
![Main elements of the tracking code.](../../img/chatbot-analytics.svg)
</div>

The user code (1) first calls the static `getTrackingProviders()` method (3) which initializes the tracking providers (4). This returns an instance of the `trackingAPI` (2), which can then subsequently be used to emit analytics events.

Note that user code only interacts with:

- `trackingAPI` (including `identify`, `trackPageview`, `trackSingleItem`)
- `TrackingRegistry` (including `getTrackingProviders`)

## Usage

### Setup

1. Before you can use the `trackingAPI`, you must first supply the API keys of the respective providers. To enable a provider, it must be added to the `activeProviders` property:

```nolive
const initProps: InitProps = {
  verbose: false,
  activeProviders: ['Segment', 'Umami', 'Posthog', 'Console' ], 
  segmentKey: 'TODO-key', // TODO add your key here
//  segmentCdn: 'https://my.org/cdn',  // Set up segment cdn (optional)
//  segmentIntegrations: { // Provide Segment integrations (optional)
//          'Segment.io': {
//            apiHost: 'my.api.host/api/v1',
//            protocol: 'https'
//          }
        },

  posthogKey: 'TODO-key',
  umamiKey: 'TODO-umami-key',
  umamiHostUrl: 'http://localhost:3000', // TODO where is your JS provider?
  'umami-data-domains': 'TODO umami data domain',
  something: 'test',
};
```

- **Note:** To enable output debugging via the web-browser console, set the `verbose` key to `true`. By default, this is set to `false`.

1. Once this is done, you can create an instance of the `trackingAPI` and start sending events.

   ```nolive
   const trackingAPI = getTrackingProviders(initProps);
   ```

1. One of your first events should identify the user in some way, such as a UUID that stays consistent for the same user.

```nolive
const trackingAPI = getTrackingProviders(initProps);
trackingAPI.identify('user-123'); // TODO get real user id
// Track the page that is currently visited. Best put into a react effect (see below)
trackingAPI.trackPageView();
// Track a single Event
trackingAPI.trackSingleItem("MyEvent", { response: 'Good response' })
```

#### Tracking providers

Only providers with a matching entry in the `InitProps.activeProviders` array will be started and used.

Possible values are:
* Umami
* Posthog
* Segment
* Console


##### Modifying providers

If you know upfront that you only want to use 1 of the supported providers, you can modify `getTrackingProviders()` and remove all other providers in the providers array.

When using the providers, you might need to add additional dependencies to your package.json file:

```nolive
"dependencies": {
  "@segment/analytics-next": "^1.76.0",
  "posthog-js": "^1.194.4"
```

Depending on your local setup, this might not be necessary. For example, if you pull the ChatBot codebase as a dependency into your project, you don't need to add it as an additional dependency in your package.json.

##### Adding providers

To add another analytics provider, you need to implement 2 interfaces, `TrackingSpi` and `trackingApi`.

1. It is easiest to start by copying the `ConsoleTrackingProvider`
1. Add an entry for your new provider to the `Providers` enum in `tracking_spi.ts`
1. Once you are happy enough with the implementation, add it to the array of providers in `getTrackingProviders()`

### Page flow tracking

To understand how users move through their ChatBot journey, you can track their page flow.

To add tracking to each page view, use the `trackPageView()` method.

```nolive
import React from 'react';
import { useLocation } from 'react-router-dom';

export const useTrackPageFlow = (): void => {
  const { pathname } = useLocation();

  // notify url change events
  React.useEffect(() => {
    trackingAPI.trackPageView();
  }, [pathname]);
};
```

### Event tracking

To get more specific insight into how users are interacting with the UI, you can track single events, including button clicks, form submissions, and so on.

To add tracking to an interaction of your choice, use the `trackSingleItem` method.

```nolive
trackingAPI.trackSingleItem(eventName, propertyDict)
```

This method takes 2 parameters:

- `eventName`: The unique name of the event. To differentiate different events that use the same name, you'll need to add an additional property.
- `propertyDict`: A dict with key-value pairs that represent important properties of the event. If there are none, this value can be empty.

#### Form submissions

Only add tracking to the form itself, not the button that opens the form. You should track both successful and failed form submissions, as well as cancelled forms

```nolive
trackingAPI.trackSingleItem(Event_Name, {
    outcome: << submit , cancel >>,
    success? : boolean,
    error? : string,
    <properties>, string/number/boolean } )
```

Parameters to pass with the `trackSingleItem` method can include:

- `outcome`: Communicates if the form was submitted or cancelled.
- `success`: Used for a "submit" outcome to communicate if the submission was successful for not in the backend.
- `error`: Used for a "submit" outcome to communicate the error message associated with a failed submission. Try to remove extraneous parts of the message, like part of a container-name.
- `properties`: Any additional properties from the form, to be tracked for analytics.
  - Use your judgement to determine what will be useful for your analytics.
  - Highly specific data, like names provided by the user or description text input, should not be tracked.
  - Less personal data, like deployment replica count or memory server size, is more likely to help you understand your users.

## Examples

To better understand the analytics tracking process, here are 3 examples of what you could see in an analytics tool.

For all 3 tools, consider the following example, where the user has started a ChatBot and taken actions 1-5 in order:

<div class="ws-docs-content-img" style="width:60%">
![Events done in the ChatBot](../../img/analytics-example.svg)
</div>

1. Selected a model
2. Sent a question
3. Received a response from the model
4. Clicked the "thumbs up" button
5. Closed the ChatBot window

This pattern of actions will be applied to the following 3 analytics tools.

1. Segment

   - [Segment](https://segment.com/) shows all user events in its source debugger:

     <div class="ws-docs-content-img" style="width:70%">
     ![Events displayed in the Segment debugger](../../img/segment.svg)
     </div>

     - 1-5: User actions with the newest event at the top.
     - 6-7: You can also see the results of `identify` (6) and `trackPageView` (7).
     - If you clicked on an event, you would also see the properties.

   - **Note**: When using the Segment provider, you may also want to set the `segmentCdn` and `segmentIntegrations` initialization properties.

1. Umami

   - In [Umami](https://umami.is/), events are visible within **Website** / **Events**.
   - The list is similar to Segment, with different formatting:

     <div class="ws-docs-content-img">
     ![Events in Umami](../../img/umami.svg)
     </div>

     - 1-5: User actions with the newest event at the top.

1. PostHog

   - In [PostHog](https://posthog.com/), events are located in the **Activity** section.
   - PostHog integrates deeper in the provided code, so there are more default events tracked:

     <div class="ws-docs-content-img">
     ![Events in PostHog](../../img/posthog.svg)
     </div>

     - 1-5: User actions with the newest event at the top.



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/demos/AttachmentDemos.md
================================================
---
# Sidenav top-level section
# should be the same for all markdown files
section: PatternFly-AI
subsection: ChatBot
# Sidenav secondary level section
# should be the same for all markdown files
id: Messages
# Tab (react | react-demos | html | html-demos | design-guidelines | accessibility)
source: demo
sourceLink: https://github.com/patternfly/chatbot/blob/main/packages/module/patternfly-docs/content/extensions/chatbot/examples/demos/demos.md
---

import ChatbotToggle from '@patternfly/chatbot/dist/dynamic/ChatbotToggle';
import Chatbot, { ChatbotDisplayMode } from '@patternfly/chatbot/dist/dynamic/Chatbot';
import ChatbotContent from '@patternfly/chatbot/dist/dynamic/ChatbotContent';
import ChatbotWelcomePrompt from '@patternfly/chatbot/dist/dynamic/ChatbotWelcomePrompt';
import ChatbotFooter, { ChatbotFootnote } from '@patternfly/chatbot/dist/dynamic/ChatbotFooter';
import MessageBar from '@patternfly/chatbot/dist/dynamic/MessageBar';
import MessageBox from '@patternfly/chatbot/dist/dynamic/MessageBox';
import Message from '@patternfly/chatbot/dist/dynamic/Message';
import FileDropZone from '@patternfly/chatbot/dist/dynamic/FileDropZone';
import FileDetailsLabel from '@patternfly/chatbot/dist/dynamic/FileDetailsLabel';
import SourceDetailsMenuItem from '@patternfly/chatbot/dist/dynamic/SourceDetailsMenuItem';
import PreviewAttachment from '@patternfly/chatbot/dist/dynamic/PreviewAttachment';
import AttachmentEdit from '@patternfly/chatbot/dist/dynamic/AttachmentEdit';
import { BellIcon, CalendarAltIcon, ClipboardIcon, CodeIcon, UploadIcon } from '@patternfly/react-icons';
import { useDropzone } from 'react-dropzone';
import PFHorizontalLogoColor from '../UI/PF-HorizontalLogo-Color.svg';
import PFHorizontalLogoReverse from '../UI/PF-HorizontalLogo-Reverse.svg';
import ChatbotHeader, {
ChatbotHeaderMenu,
ChatbotHeaderMain,
ChatbotHeaderTitle,
ChatbotHeaderActions,
ChatbotHeaderSelectorDropdown,
ChatbotHeaderOptionsDropdown
} from '@patternfly/chatbot/dist/dynamic/ChatbotHeader';
import ChatbotAlert from '@patternfly/chatbot/dist/dynamic/ChatbotAlert';
import ExpandIcon from '@patternfly/react-icons/dist/esm/icons/expand-icon';
import OpenDrawerRightIcon from '@patternfly/react-icons/dist/esm/icons/open-drawer-right-icon';
import OutlinedWindowRestoreIcon from '@patternfly/react-icons/dist/esm/icons/outlined-window-restore-icon';
import PFIconLogoColor from '../UI/PF-IconLogo-Color.svg';
import PFIconLogoReverse from '../UI/PF-IconLogo-Reverse.svg';
import userAvatar from '../Messages/user_avatar.svg';
import patternflyAvatar from '../Messages/patternfly_avatar.jpg';

## Demos

### Message feedback

When a user selects a positive or negative message action, you can display a message feedback card that acknowledges their response and provides space for additional written feedback. These cards can be manually dismissed via the close button and the thank-you card can be configured to time out automatically.

The following example demonstrates a full feedback flow, which accepts written feedback submission and displays a thank you card.

It also demonstrates how to handle focus appropriately for accessibility. The card will be focused when it appears in the DOM. When the card closes, place the focus back on the launching button. To provide additional context on what the button controls, you can also add `aria-expanded` and `aria-controls` attributes to the feedback buttons.

It is also important to announce when new content appears onscreen for accessibility purposes. `isLiveRegion` is set to true by default on `<Message>` so it will make appropriate announcements for you when the feedback card appears.

```js file="./Feedback.tsx"

```

### Attach via upload button in message bar

This demo displays unique attachment features, including:

1. [`<ChatbotContent>` and `<MessageBox>`](/patternfly-ai/chatbot/ui#content-and-message-box) components that contain:
   - An initial [user `<Message>`](/patternfly-ai/chatbot/messages#user-messages) with an attachment.
   - The ability to preview or edit the attachment using the [`<PreviewAttachment>` and `<AttachmentEdit>` components.](/patternfly-ai/chatbot/messages##file-attachments)
   - A [PatternFly `<Alert>`](/components/alert), customized to be sticky within the ChatBot window, which provides success or error messages for attachments.
2. `<ChatbotContent>` and `<ChatbotFooter>`, wrapped in a `<FileDropZone>` component to support drag and drop attachments. The footer also:
   - Displays attached files, using a [`<FileDetailsLabel>`](/patternfly-ai/chatbot/messages#attachment-label) component.
   - Demonstrates custom handling of file uploads, using the `handleAttach` in `<MessageBar>` and `handleFileDrop` in `<FileDropZone>`.

This demo includes broader ChatBot features, including:

1. A [`<ChatbotToggle>`](/patternfly-ai/chatbot/ui#toggle) that controls the [`<Chatbot>`](/patternfly-ai/chatbot/ui#container) container.
2. A [`<ChatbotHeader>`](/patternfly-ai/chatbot/ui#header) that updates based on the display mode, with sub-components (including a `<ChatbotHeaderTitle>`).
3. The ability to swap display modes via the `<ChatbotHeaderOptionsDropdown>`
4. A `<ChatbotContent>` and [`<MessageBox>`](/patternfly-ai/chatbot/uir#content-and-message-box) with:
   - A `<ChatbotWelcomePrompt>`
   - The ability to preview or edit the attachment.
   - An initial bot message
5. A [`<ChatbotFooter>`](/patternfly-ai/chatbot/ui#footer) with a [`<ChatbotFootnote>`](/patternfly-ai/chatbot/ui#footnote-with-popover) and a `<MessageBar>`

```js file="./ChatbotAttachment.tsx" isFullscreen

```

### Attach via menu of options in message bar

This demo displays unique attachment features, including:

1. [`<ChatbotContent>` and `<MessageBox>`](/patternfly-ai/chatbot/ui#content-and-message-box) components that contain:
   - A PatternFly [`<Alert>`](/components/alert) to provide success or error messages for attachments.
2. `<ChatbotContent>` and `<ChatbotFooter>`, wrapped in a `<FileDropZone>` component to support drag and drop attachments. The footer also:

   - Displays attached files, using a [`<FileDetailsLabel>`](/patternfly-ai/chatbot/ui#attachment-label) component.
   - Demonstrates custom handling of file uploads, using the `handleAttach` in `<MessageBar>` and `handleFileDrop` in `<FileDropZone>`.
   - Demonstrates how to define the `attachMenuProps` in the `<MessageBar>` to create a menu that allows users to select the source of an item they're attaching.

This demo includes broader ChatBot features, including:

1. A [`<ChatbotToggle>`](/patternfly-ai/chatbot/ui#toggle) that controls the [`<Chatbot>`](/patternfly-ai/chatbot/ui#container) container.
2. A `<ChatbotContent>` and [`<MessageBox>`](/patternfly-ai/chatbot/ui#content-and-message-box) with:
   - A `<ChatbotWelcomePrompt>`
   - An initial user message and initial bot message
3. A [`<ChatbotFooter>`](/patternfly-ai/chatbot/ui#footer) with a [`<ChatbotFootnote>`](/patternfly-ai/chatbot/ui#footnote-with-popover) and a `<MessageBar>`

```js file="./ChatbotAttachmentMenu.tsx" isFullscreen

```



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/demos/Chatbot.md
================================================
---
# Sidenav top-level section
# should be the same for all markdown files
section: PatternFly-AI
subsection: ChatBot
# Sidenav secondary level section
# should be the same for all markdown files
id: Overview
# Tab (react | react-demos | html | html-demos | design-guidelines | accessibility)
source: demo
# If you use typescript, the name of the interface to display props for
# These are found through the sourceProps function provided in patternfly-docs.source.js
propComponents:
  [
    'Chatbot',
    'ChatbotToggle',
    'ChatbotContent',
    'ChatbotWelcomePrompt',
    'ChatbotFooter',
    'MessageBar',
    'ChatbotFootnote',
    'MessageBox',
    'Message',
    'MessageBarWithAttachMenuProps',
    'CompareProps'
  ]
sortValue: 2
---

import ChatbotToggle from '@patternfly/chatbot/dist/dynamic/ChatbotToggle';
import Chatbot, { ChatbotDisplayMode } from '@patternfly/chatbot/dist/dynamic/Chatbot';
import ChatbotContent from '@patternfly/chatbot/dist/dynamic/ChatbotContent';
import ChatbotWelcomePrompt from '@patternfly/chatbot/dist/dynamic/ChatbotWelcomePrompt';
import ChatbotFooter, { ChatbotFootnote } from '@patternfly/chatbot/dist/dynamic/ChatbotFooter';
import MessageBar from '@patternfly/chatbot/dist/dynamic/MessageBar';
import MessageBox from '@patternfly/chatbot/dist/dynamic/MessageBox';
import Message from '@patternfly/chatbot/dist/dynamic/Message';
import Compare from '@patternfly/chatbot/dist/dynamic/Compare';
import ChatbotConversationHistoryNav from '@patternfly/chatbot/dist/dynamic/ChatbotConversationHistoryNav';

import ChatbotHeader, {
ChatbotHeaderMain,
ChatbotHeaderMenu,
ChatbotHeaderTitle,
ChatbotHeaderActions,
ChatbotHeaderSelectorDropdown,
ChatbotHeaderOptionsDropdown
} from '@patternfly/chatbot/dist/dynamic/ChatbotHeader';

import ExpandIcon from '@patternfly/react-icons/dist/esm/icons/expand-icon';
import OpenDrawerRightIcon from '@patternfly/react-icons/dist/esm/icons/open-drawer-right-icon';
import OutlinedWindowRestoreIcon from '@patternfly/react-icons/dist/esm/icons/outlined-window-restore-icon';
import { BarsIcon } from '@patternfly/react-icons/dist/esm/icons/bars-icon';
import PFHorizontalLogoColor from '../UI/PF-HorizontalLogo-Color.svg';
import PFHorizontalLogoReverse from '../UI/PF-HorizontalLogo-Reverse.svg';
import PFIconLogoColor from '../UI/PF-IconLogo-Color.svg';
import PFIconLogoReverse from '../UI/PF-IconLogo-Reverse.svg';
import userAvatar from '../Messages/user_avatar.svg';
import patternflyAvatar from '../Messages/patternfly_avatar.jpg';
import { getTrackingProviders } from "@patternfly/chatbot/dist/dynamic/tracking";

### Basic ChatBot

This demo displays a basic ChatBot, which includes:

1. The [`<ChatbotToggle>`](/patternfly-ai/chatbot/ui#toggle) that controls the [`<Chatbot>` container.](/patternfly-ai/chatbot/ui#container)
2. A [`<ChatbotHeader>`](/patternfly-ai/chatbot/ui#header) with all built sub-components laid out, including a `<ChatbotHeaderTitle>` that changes its presentation depending on the display mode.
3. The ability to swap display modes via `<ChatbotHeaderOptionsDropdown>`
4. [`<ChatbotContent>` and `<MessageBox>`](/patternfly-ai/chatbot/ui#content-and-message-box) with:

- A `<ChatbotWelcomePrompt>`
- An initial [user `<Message>`](/patternfly-ai/chatbot/messages#user-messages) and an initial bot message with [message actions.](/patternfly-ai/chatbot/messages#message-actions)
- Logic for enabling auto-scrolling to the most recent message whenever a new message is sent or received using a `scrollToBottomRef`

5. A [`<ChatbotFooter>`](/patternfly-ai/chatbot/ui#footer) with a [`<ChatbotFootNote>`](/patternfly-ai/chatbot/ui#footnote-with-popover) and a `<MessageBar>` that contains the abilities of:

- [Speech to text.](/patternfly-ai/chatbot/ui#message-bar-with-speech-recognition-and-file-attachment)
- Sending a message to the ChatBot.
- Receiving a response from a backend AI tool with a loading message state.

6. A [`<ChatbotConversationHistoryNav>`](/patternfly-ai/chatbot/ui#navigation) toggled open and closed by the `<ChatbotHeaderMenu`> in the `<ChatbotHeader>`.

7. A "Skip to chatbot" button that allows you to skip to the chatbot content via the [PatternFly skip to content component](/patternfly-ai/chatbot/ui#skip-to-content). To display this button you must tab into the main window.

```js file="./Chatbot.tsx" isFullscreen

```

### Compact ChatBot

This demo displays a basic compact ChatBot

```js file="./ChatbotCompact.tsx" isFullscreen

```

### Embedded ChatBot

This demo displays an embedded ChatBot. Embedded ChatBots are meant to be placed within a page in your product. This demo includes:

1. A [PatternFly page](/components/page) with a sidebar, "Skip to chatbot" button, and masthead. To display the "Skip to chatbot" button you must tab into the main window.
2. A [`<Chatbot>`](/patternfly-ai/chatbot/ui#container) container.
3. A [`<ChatbotHeader>`](/patternfly-ai/chatbot/ui#header) with all built sub-components laid out, including a `<ChatbotHeaderTitle>`
4. [`<ChatbotContent>` and `<MessageBox>`](/patternfly-ai/chatbot/ui#content-and-message-box) with:
   - A `<ChatbotWelcomePrompt>`
   - An initial [user `<Message>`](/patternfly-ai/chatbot/messages#user-messages) and an initial bot message with [message actions.](/patternfly-ai/chatbot/messages/#message-actions)
   - Logic for enabling auto-scrolling to the most recent message whenever a new message is sent or received using a `scrollToBottomRef`
5. A [`<ChatbotFooter>`](/patternfly-ai/chatbot/ui#footer) with a [`<ChatbotFootNote>`](/patternfly-ai/chatbot/ui#footnote-with-popover) and a `<MessageBar>` that contains the abilities of:
   - [Speech to text.](/patternfly-ai/chatbot/ui#message-bar-with-speech-recognition-and-file-attachment)
   - Sending a message to the ChatBot.
   - Receiving a response from a backend AI tool with a loading message state.
6. A [`<ChatbotConversationHistoryNav>`](/patternfly-ai/chatbot/ui#navigation) that can be toggled by the `<ChatbotHeaderMenu`> in the `<ChatbotHeader>`.

```js file="./EmbeddedChatbot.tsx" isFullscreen

```

### Inline drawer ChatBot

This demo displays a ChatBot in a static, inline drawer. This demo includes:

1. An empty [PatternFly page](/components/page) with a sidebar and masthead.
2. A [basic ChatBot](#basic-chatbot), placed beside the page content. It does not overlay the page content, cannot be minimized, and does not allow you to change the display mode by default.

**Note:** The inline drawer ChatBot is built to fit and perform within a drawer, but the implementation of the drawer is up to you. This drawer can look different for each product, but will often be placed to the side of the page, inline with the page content.

```js file="./ChatbotInDrawer.tsx" isFullscreen

```

### Comparing ChatBots

To let users compare how different ChatBots respond to the same prompt, you can add multiple ChatBots within the same window. The following demo illustrates a comparison view pattern that allows users to toggle between different conversations in a single ChatBot window.
<br /><br />
Your code structure should look like this:

```noLive
<Page ... >
  <div className="pf-chatbot__compare-container">
    <Compare ... />
    <ChatbotFooter ... >
      <MessageBar ... />
    </ChatbotFooter>
  </div>
</Page>
```

```js file="./EmbeddedComparisonChatbot.tsx" isFullscreen

```



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/demos/Chatbot.tsx
================================================
import React from 'react';

import { Bullseye, Brand, DropdownList, DropdownItem, DropdownGroup, SkipToContent } from '@patternfly/react-core';

import ChatbotToggle from '@patternfly/chatbot/dist/dynamic/ChatbotToggle';
import Chatbot, { ChatbotDisplayMode } from '@patternfly/chatbot/dist/dynamic/Chatbot';
import ChatbotContent from '@patternfly/chatbot/dist/dynamic/ChatbotContent';
import ChatbotWelcomePrompt from '@patternfly/chatbot/dist/dynamic/ChatbotWelcomePrompt';
import ChatbotFooter, { ChatbotFootnote } from '@patternfly/chatbot/dist/dynamic/ChatbotFooter';
import MessageBar from '@patternfly/chatbot/dist/dynamic/MessageBar';
import MessageBox from '@patternfly/chatbot/dist/dynamic/MessageBox';
import Message, { MessageProps } from '@patternfly/chatbot/dist/dynamic/Message';
import ChatbotConversationHistoryNav, {
  Conversation
} from '@patternfly/chatbot/dist/dynamic/ChatbotConversationHistoryNav';
import ChatbotHeader, {
  ChatbotHeaderMenu,
  ChatbotHeaderMain,
  ChatbotHeaderTitle,
  ChatbotHeaderActions,
  ChatbotHeaderSelectorDropdown,
  ChatbotHeaderOptionsDropdown
} from '@patternfly/chatbot/dist/dynamic/ChatbotHeader';

import ExpandIcon from '@patternfly/react-icons/dist/esm/icons/expand-icon';
import OpenDrawerRightIcon from '@patternfly/react-icons/dist/esm/icons/open-drawer-right-icon';
import OutlinedWindowRestoreIcon from '@patternfly/react-icons/dist/esm/icons/outlined-window-restore-icon';

import PFHorizontalLogoColor from '../UI/PF-HorizontalLogo-Color.svg';
import PFHorizontalLogoReverse from '../UI/PF-HorizontalLogo-Reverse.svg';
import PFIconLogoColor from '../UI/PF-IconLogo-Color.svg';
import PFIconLogoReverse from '../UI/PF-IconLogo-Reverse.svg';
import userAvatar from '../Messages/user_avatar.svg';
import patternflyAvatar from '../Messages/patternfly_avatar.jpg';
import { getTrackingProviders } from '@patternfly/chatbot/dist/dynamic/tracking';
import { InitProps } from '@patternfly/chatbot/dist/dynamic/tracking';
import '@patternfly/react-core/dist/styles/base.css';
import '@patternfly/chatbot/dist/css/main.css';

const footnoteProps = {
  label: 'ChatBot uses AI. Check for mistakes.',
  popover: {
    title: 'Verify information',
    description: `While ChatBot strives for accuracy, AI is experimental and can make mistakes. We cannot guarantee that all information provided by ChatBot is up to date or without error. You should always verify responses using reliable sources, especially for crucial information and decision making.`,
    bannerImage: {
      src: 'https://cdn.dribbble.com/userupload/10651749/file/original-8a07b8e39d9e8bf002358c66fce1223e.gif',
      alt: 'Example image for footnote popover'
    },
    cta: {
      label: 'Dismiss',
      onClick: () => {
        alert('Do something!');
      }
    },
    link: {
      label: 'View AI policy',
      url: 'https://www.redhat.com/'
    }
  }
};

const markdown = `A paragraph with *emphasis* and **strong importance**.

> A block quote with ~strikethrough~ and a URL: https://reactjs.org.

Here is an inline code - \`() => void\`

Here is some YAML code:

~~~yaml
apiVersion: helm.openshift.io/v1beta1/
kind: HelmChartRepository
metadata:
  name: azure-sample-repo0oooo00ooo
spec:
  connectionConfig:
  url: https://raw.githubusercontent.com/Azure-Samples/helm-charts/master/docs
~~~

Here is some JavaScript code:

~~~js
import React from 'react';

const MessageLoading = () => (
  <div className="pf-chatbot__message-loading">
    <span className="pf-chatbot__message-loading-dots">
      <span className="pf-v6-screen-reader">Loading message</span>
    </span>
  </div>
);

export default MessageLoading;

~~~
`;

// It's important to set a date and timestamp prop since the Message components re-render.
// The timestamps re-render with them.
const date = new Date();

const initProps: InitProps = {
  verbose: false,
  segmentKey: 'TODO-key', // TODO add your key here
  posthogKey: 'TODO-key',
  umamiKey: 'TODO-key',
  umamiHostUrl: 'http://localhost:3000', // TODO where is your Umami installation?
  console: true,
  something: 'test'
};

const tracking = getTrackingProviders(initProps);
tracking.identify('user-123', { superUser: true }); // TODO get real user id + properties
tracking.trackPageView(window.location.href);

const actionEventName = 'MessageAction';
const initialMessages: MessageProps[] = [
  {
    id: '1',
    role: 'user',
    content: 'Hello, can you give me an example of what you can do?',
    name: 'User',
    avatar: userAvatar,
    timestamp: date.toLocaleString(),
    avatarProps: { isBordered: true }
  },
  {
    id: '2',
    role: 'bot',
    content: markdown,
    name: 'Bot',
    avatar: patternflyAvatar,
    timestamp: date.toLocaleString(),
    actions: {
      positive: { onClick: () => tracking.trackSingleItem(actionEventName, { response: 'Good response' }) },
      negative: { onClick: () => tracking.trackSingleItem(actionEventName, { response: 'Bad response' }) },
      copy: { onClick: () => tracking.trackSingleItem(actionEventName, { response: 'Copy' }) },
      share: { onClick: () => tracking.trackSingleItem(actionEventName, { response: 'Share' }) },
      listen: { onClick: () => tracking.trackSingleItem(actionEventName, { response: 'Listen' }) }
    }
  }
];

const welcomePrompts = [
  {
    title: 'Set up account',
    message: 'Choose the necessary settings and preferences for your account.'
  },
  {
    title: 'Troubleshoot issue',
    message: 'Find documentation and instructions to resolve your issue.'
  }
];

const initialConversations = {
  Today: [{ id: '1', text: 'Hello, can you give me an example of what you can do?' }],
  'This month': [
    {
      id: '2',
      text: 'Enterprise Linux installation and setup'
    },
    { id: '3', text: 'Troubleshoot system crash' }
  ],
  March: [
    { id: '4', text: 'Ansible security and updates' },
    { id: '5', text: 'Red Hat certification' },
    { id: '6', text: 'Lightspeed user documentation' }
  ],
  February: [
    { id: '7', text: 'Crashing pod assistance' },
    { id: '8', text: 'OpenShift AI pipelines' },
    { id: '9', text: 'Updating subscription plan' },
    { id: '10', text: 'Red Hat licensing options' }
  ],
  January: [
    { id: '11', text: 'RHEL system performance' },
    { id: '12', text: 'Manage user accounts' }
  ]
};

const actionEvent2 = 'ActionEvent2';
export const ChatbotDemo: React.FunctionComponent = () => {
  const [chatbotVisible, setChatbotVisible] = React.useState<boolean>(true);
  const [displayMode, setDisplayMode] = React.useState<ChatbotDisplayMode>(ChatbotDisplayMode.default);
  const [messages, setMessages] = React.useState<MessageProps[]>(initialMessages);
  const [selectedModel, setSelectedModel] = React.useState('Granite 7B');
  const [isSendButtonDisabled, setIsSendButtonDisabled] = React.useState(false);
  const [isDrawerOpen, setIsDrawerOpen] = React.useState(false);
  const [conversations, setConversations] = React.useState<Conversation[] | { [key: string]: Conversation[] }>(
    initialConversations
  );
  const [announcement, setAnnouncement] = React.useState<string>();
  const scrollToBottomRef = React.useRef<HTMLDivElement>(null);
  const toggleRef = React.useRef<HTMLButtonElement>(null);
  const chatbotRef = React.useRef<HTMLDivElement>(null);
  const historyRef = React.useRef<HTMLButtonElement>(null);

  // Auto-scrolls to the latest message
  React.useEffect(() => {
    // don't scroll the first load - in this demo, we know we start with two messages
    if (messages.length > 2) {
      scrollToBottomRef.current?.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages]);

  const onSelectModel = (
    _event: React.MouseEvent<Element, MouseEvent> | undefined,
    value: string | number | undefined
  ) => {
    setSelectedModel(value as string);
    tracking.trackSingleItem('ModelSelected', { model: value });
  };

  const onSelectDisplayMode = (
    _event: React.MouseEvent<Element, MouseEvent> | undefined,
    value: string | number | undefined
  ) => {
    setDisplayMode(value as ChatbotDisplayMode);
  };

  // you will likely want to come up with your own unique id function; this is for demo purposes only
  const generateId = () => {
    const id = Date.now() + Math.random();
    return id.toString();
  };

  const handleSend = (message: string) => {
    setIsSendButtonDisabled(true);
    tracking.trackSingleItem('UserInputReceived', { text: message });
    const newMessages: MessageProps[] = [];
    // We can't use structuredClone since messages contains functions, but we can't mutate
    // items that are going into state or the UI won't update correctly
    messages.forEach((message) => newMessages.push(message));
    // It's important to set a timestamp prop since the Message components re-render.
    // The timestamps re-render with them.
    const date = new Date();
    newMessages.push({
      id: generateId(),
      role: 'user',
      content: message,
      name: 'User',
      avatar: userAvatar,
      timestamp: date.toLocaleString(),
      avatarProps: { isBordered: true }
    });
    newMessages.push({
      id: generateId(),
      role: 'bot',
      content: 'API response goes here',
      name: 'Bot',
      isLoading: true,
      avatar: patternflyAvatar,
      timestamp: date.toLocaleString()
    });
    setMessages(newMessages);
    // make announcement to assistive devices that new messages have been added
    setAnnouncement(`Message from User: ${message}. Message from Bot is loading.`);

    // this is for demo purposes only; in a real situation, there would be an API response we would wait for
    setTimeout(() => {
      const loadedMessages: MessageProps[] = [];
      // We can't use structuredClone since messages contains functions, but we can't mutate
      // items that are going into state or the UI won't update correctly
      newMessages.forEach((message) => loadedMessages.push(message));
      loadedMessages.pop();
      loadedMessages.push({
        id: generateId(),
        role: 'bot',
        content: 'API response goes here',
        name: 'Bot',
        isLoading: false,
        avatar: patternflyAvatar,
        timestamp: date.toLocaleString(),
        actions: {
          positive: { onClick: () => tracking.trackSingleItem(actionEvent2, { response: 'Good response' }) },
          negative: { onClick: () => tracking.trackSingleItem(actionEvent2, { response: 'Bad response' }) },
          copy: { onClick: () => tracking.trackSingleItem(actionEvent2, { response: 'Copy' }) },
          share: { onClick: () => tracking.trackSingleItem(actionEvent2, { response: 'Share' }) },
          listen: { onClick: () => tracking.trackSingleItem(actionEvent2, { response: 'Listen' }) }
        }
      });
      setMessages(loadedMessages);
      // make announcement to assistive devices that new message has loaded
      setAnnouncement(`Message from Bot: API response goes here`);
      tracking.trackSingleItem('BotResponded', { undefined });
      setIsSendButtonDisabled(false);
    }, 5000);
  };

  const findMatchingItems = (targetValue: string) => {
    let filteredConversations = Object.entries(initialConversations).reduce((acc, [key, items]) => {
      const filteredItems = items.filter((item) => item.text.toLowerCase().includes(targetValue.toLowerCase()));
      if (filteredItems.length > 0) {
        acc[key] = filteredItems;
      }
      return acc;
    }, {});

    // append message if no items are found
    if (Object.keys(filteredConversations).length === 0) {
      filteredConversations = [{ id: '13', noIcon: true, text: 'No results found' }];
    }
    return filteredConversations;
  };

  const horizontalLogo = (
    <Bullseye>
      <Brand className="show-light" src={PFHorizontalLogoColor} alt="PatternFly" />
      <Brand className="show-dark" src={PFHorizontalLogoReverse} alt="PatternFly" />
    </Bullseye>
  );

  const iconLogo = (
    <>
      <Brand className="show-light" src={PFIconLogoColor} alt="PatternFly" />
      <Brand className="show-dark" src={PFIconLogoReverse} alt="PatternFly" />
    </>
  );

  const handleSkipToContent = (e) => {
    e.preventDefault();
    /* eslint-disable indent */
    switch (displayMode) {
      case ChatbotDisplayMode.default:
        if (!chatbotVisible && toggleRef.current) {
          toggleRef.current.focus();
        }
        if (chatbotVisible && chatbotRef.current) {
          chatbotRef.current.focus();
        }
        break;

      case ChatbotDisplayMode.docked:
        if (chatbotRef.current) {
          chatbotRef.current.focus();
        }
        break;
      default:
        if (historyRef.current) {
          historyRef.current.focus();
        }
        break;
    }
    /* eslint-enable indent */
  };

  return (
    <>
      <SkipToContent onClick={handleSkipToContent} href="#">
        Skip to chatbot
      </SkipToContent>
      <ChatbotToggle
        tooltipLabel="Chatbot"
        isChatbotVisible={chatbotVisible}
        onToggleChatbot={function () {
          setChatbotVisible(!chatbotVisible);
          tracking.trackSingleItem('Chatbot Visible', { isVisible: !chatbotVisible }); // TODO correct?
        }}
        id="chatbot-toggle"
        ref={toggleRef}
      />
      <Chatbot isVisible={chatbotVisible} displayMode={displayMode} ref={chatbotRef}>
        <ChatbotConversationHistoryNav
          displayMode={displayMode}
          onDrawerToggle={() => {
            setIsDrawerOpen(!isDrawerOpen);
            setConversations(initialConversations);
          }}
          isDrawerOpen={isDrawerOpen}
          setIsDrawerOpen={setIsDrawerOpen}
          activeItemId="1"
          // eslint-disable-next-line no-console
          onSelectActiveItem={(e, selectedItem) => console.log(`Selected history item with id ${selectedItem}`)}
          conversations={conversations}
          onNewChat={() => {
            setIsDrawerOpen(!isDrawerOpen);
            setMessages([]);
            setConversations(initialConversations);
          }}
          handleTextInputChange={(value: string) => {
            if (value === '') {
              setConversations(initialConversations);
            }
            // this is where you would perform search on the items in the drawer
            // and update the state
            const newConversations: { [key: string]: Conversation[] } = findMatchingItems(value);
            setConversations(newConversations);
          }}
          drawerContent={
            <>
              <ChatbotHeader>
                <ChatbotHeaderMain>
                  <ChatbotHeaderMenu
                    ref={historyRef}
                    aria-expanded={isDrawerOpen}
                    onMenuToggle={() => setIsDrawerOpen(!isDrawerOpen)}
                  />
                  <ChatbotHeaderTitle
                    displayMode={displayMode}
                    showOnFullScreen={horizontalLogo}
                    showOnDefault={iconLogo}
                  ></ChatbotHeaderTitle>
                </ChatbotHeaderMain>
                <ChatbotHeaderActions>
                  <ChatbotHeaderSelectorDropdown value={selectedModel} onSelect={onSelectModel}>
                    <DropdownList>
                      <DropdownItem value="Granite 7B" key="granite">
                        Granite 7B
                      </DropdownItem>
                      <DropdownItem value="Llama 3.0" key="llama">
                        Llama 3.0
                      </DropdownItem>
                      <DropdownItem value="Mistral 3B" key="mistral">
                        Mistral 3B
                      </DropdownItem>
                    </DropdownList>
                  </ChatbotHeaderSelectorDropdown>
                  <ChatbotHeaderOptionsDropdown onSelect={onSelectDisplayMode}>
                    <DropdownGroup label="Display mode">
                      <DropdownList>
                        <DropdownItem
                          value={ChatbotDisplayMode.default}
                          key="switchDisplayOverlay"
                          icon={<OutlinedWindowRestoreIcon aria-hidden />}
                          isSelected={displayMode === ChatbotDisplayMode.default}
                        >
                          <span>Overlay</span>
                        </DropdownItem>
                        <DropdownItem
                          value={ChatbotDisplayMode.docked}
                          key="switchDisplayDock"
                          icon={<OpenDrawerRightIcon aria-hidden />}
                          isSelected={displayMode === ChatbotDisplayMode.docked}
                        >
                          <span>Dock to window</span>
                        </DropdownItem>
                        <DropdownItem
                          value={ChatbotDisplayMode.fullscreen}
                          key="switchDisplayFullscreen"
                          icon={<ExpandIcon aria-hidden />}
                          isSelected={displayMode === ChatbotDisplayMode.fullscreen}
                        >
                          <span>Fullscreen</span>
                        </DropdownItem>
                      </DropdownList>
                    </DropdownGroup>
                  </ChatbotHeaderOptionsDropdown>
                </ChatbotHeaderActions>
              </ChatbotHeader>
              <ChatbotContent>
                {/* Update the announcement prop on MessageBox whenever a new message is sent
                 so that users of assistive devices receive sufficient context  */}
                <MessageBox announcement={announcement}>
                  <ChatbotWelcomePrompt
                    title="Hi, ChatBot User!"
                    description="How can I help you today?"
                    prompts={welcomePrompts}
                  />
                  {/* This code block enables scrolling to the top of the last message.
                  You can instead choose to move the div with scrollToBottomRef on it below
                  the map of messages, so that users are forced to scroll to the bottom.
                  If you are using streaming, you will want to take a different approach;
                  see: https://github.com/patternfly/chatbot/issues/201#issuecomment-2400725173 */}
                  {messages.map((message, index) => {
                    if (index === messages.length - 1) {
                      return (
                        <>
                          <div ref={scrollToBottomRef}></div>
                          <Message key={message.id} {...message} />
                        </>
                      );
                    }
                    return <Message key={message.id} {...message} />;
                  })}
                </MessageBox>
              </ChatbotContent>
              <ChatbotFooter>
                <MessageBar
                  onSendMessage={handleSend}
                  hasMicrophoneButton
                  isSendButtonDisabled={isSendButtonDisabled}
                />
                <ChatbotFootnote {...footnoteProps} />
              </ChatbotFooter>
            </>
          }
        ></ChatbotConversationHistoryNav>
      </Chatbot>
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/demos/ChatbotAttachment.tsx
================================================
import React from 'react';
import ChatbotToggle from '@patternfly/chatbot/dist/dynamic/ChatbotToggle';
import Chatbot, { ChatbotDisplayMode } from '@patternfly/chatbot/dist/dynamic/Chatbot';
import ChatbotContent from '@patternfly/chatbot/dist/dynamic/ChatbotContent';
import ChatbotWelcomePrompt from '@patternfly/chatbot/dist/dynamic/ChatbotWelcomePrompt';
import ChatbotFooter, { ChatbotFootnote } from '@patternfly/chatbot/dist/dynamic/ChatbotFooter';
import MessageBar from '@patternfly/chatbot/dist/dynamic/MessageBar';
import MessageBox from '@patternfly/chatbot/dist/dynamic/MessageBox';
import Message, { MessageProps } from '@patternfly/chatbot/dist/dynamic/Message';
import FileDropZone from '@patternfly/chatbot/dist/dynamic/FileDropZone';
import { Brand, Bullseye, DropdownGroup, DropdownItem, DropdownList, DropEvent } from '@patternfly/react-core';
import FileDetailsLabel from '@patternfly/chatbot/dist/dynamic/FileDetailsLabel';
import PreviewAttachment from '@patternfly/chatbot/dist/dynamic/PreviewAttachment';
import AttachmentEdit from '@patternfly/chatbot/dist/dynamic/AttachmentEdit';
import ChatbotHeader, {
  ChatbotHeaderMenu,
  ChatbotHeaderTitle,
  ChatbotHeaderActions,
  ChatbotHeaderOptionsDropdown,
  ChatbotHeaderMain
} from '@patternfly/chatbot/dist/dynamic/ChatbotHeader';
import ChatbotAlert from '@patternfly/chatbot/dist/dynamic/ChatbotAlert';
import ExpandIcon from '@patternfly/react-icons/dist/esm/icons/expand-icon';
import OpenDrawerRightIcon from '@patternfly/react-icons/dist/esm/icons/open-drawer-right-icon';
import OutlinedWindowRestoreIcon from '@patternfly/react-icons/dist/esm/icons/outlined-window-restore-icon';
import PFHorizontalLogoColor from '../UI/PF-HorizontalLogo-Color.svg';
import PFHorizontalLogoReverse from '../UI/PF-HorizontalLogo-Reverse.svg';
import PFIconLogoColor from '../UI/PF-IconLogo-Color.svg';
import PFIconLogoReverse from '../UI/PF-IconLogo-Reverse.svg';
import userAvatar from '../Messages/user_avatar.svg';
import patternflyAvatar from '../Messages/patternfly_avatar.jpg';
import '@patternfly/react-core/dist/styles/base.css';
import '@patternfly/chatbot/dist/css/main.css';

interface ModalData {
  code: string;
  fileName: string;
}

export const BasicDemo: React.FunctionComponent = () => {
  const onAttachmentClose = (event, name, id) => {
    const updatedMessages: MessageProps[] = [];
    messages.map((message) => {
      if (message.attachments) {
        const filteredAttachments = message.attachments.filter((attachment) => attachment.id !== id);
        message.attachments = filteredAttachments;
        updatedMessages.push(message);
      } else {
        updatedMessages.push(message);
      }
    });
    setMessages(updatedMessages);
  };

  const onAttachmentClick = () => {
    setCurrentModalData({ fileName: 'auth-operator.yml', code: 'test' });
    setIsEditModalOpen(false);
    setIsPreviewModalOpen(true);
  };

  const initialMessages: MessageProps[] = [
    {
      role: 'user',
      content: "I'm referring to this attachment for added context in our conversation.",
      name: 'User',
      avatar: userAvatar,
      avatarProps: { isBordered: true },
      attachments: [{ name: 'auth-operator.yml', id: '1', onClick: onAttachmentClick, onClose: onAttachmentClose }]
    },
    {
      role: 'bot',
      content: 'Great, I can reference this attachment throughout our conversation.',
      avatar: patternflyAvatar,
      name: 'Bot'
    }
  ];

  const [error, setError] = React.useState<string>();
  const [chatbotVisible, setChatbotVisible] = React.useState<boolean>(true);
  const [file, setFile] = React.useState<File>();
  const [isLoadingFile, setIsLoadingFile] = React.useState<boolean>(false);
  const [messages, setMessages] = React.useState<MessageProps[]>(initialMessages);
  const [isPreviewModalOpen, setIsPreviewModalOpen] = React.useState<boolean>(false);
  const [isEditModalOpen, setIsEditModalOpen] = React.useState<boolean>(false);
  const [currentModalData, setCurrentModalData] = React.useState<ModalData>();
  const [showAlert, setShowAlert] = React.useState<boolean>(false);
  const [displayMode, setDisplayMode] = React.useState<ChatbotDisplayMode>(ChatbotDisplayMode.default);

  const onSelectDisplayMode = (
    _event: React.MouseEvent<Element, MouseEvent> | undefined,
    value: string | number | undefined
  ) => {
    setDisplayMode(value as ChatbotDisplayMode);
  };

  const handleSend = (message) => alert(message);

  // Attachments
  // --------------------------------------------------------------------------
  // example of how you can read a text file
  const readFile = (file: File) =>
    new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = () => reject(reader.error);
      reader.readAsDataURL(file);
      // you can use reader.readAsText(file) for human-readable file types;
    });

  // handle file drop/selection
  const handleFile = (fileArr: File[]) => {
    setIsLoadingFile(true);
    // any custom validation you may want
    if (fileArr.length > 1) {
      setShowAlert(true);
      setFile(undefined);
      setError('Uploaded more than one file.');
      return;
    }
    // this is 25MB in bytes; size is in bytes
    if (fileArr[0].size > 25000000) {
      setShowAlert(true);
      setFile(undefined);
      setError('File is larger than 25MB.');
      return;
    }

    readFile(fileArr[0])
      .then((data) => {
        // eslint-disable-next-line no-console
        console.log(data);
        setFile(fileArr[0]);
        setShowAlert(false);
        setError(undefined);
        // this is just for demo purposes, to make the loading state really obvious
        setTimeout(() => {
          setIsLoadingFile(false);
        }, 1000);
      })
      .catch((error: DOMException) => {
        setError(`Failed to read file: ${error.message}`);
      });
  };

  const handleFileDrop = (event: DropEvent, data: File[]) => {
    handleFile(data);
  };

  const handleAttach = (data: File[]) => {
    handleFile(data);
  };

  const onClose = () => {
    setFile(undefined);
  };

  const horizontalLogo = (
    <Bullseye>
      <Brand className="show-light" src={PFHorizontalLogoColor} alt="PatternFly" />
      <Brand className="show-dark" src={PFHorizontalLogoReverse} alt="PatternFly" />
    </Bullseye>
  );

  const iconLogo = (
    <>
      <Brand className="show-light" src={PFIconLogoColor} alt="PatternFly" />
      <Brand className="show-dark" src={PFIconLogoReverse} alt="PatternFly" />
    </>
  );

  return (
    <>
      <ChatbotToggle
        tooltipLabel="Chatbot"
        isChatbotVisible={chatbotVisible}
        onToggleChatbot={() => {
          setChatbotVisible(!chatbotVisible);
          setIsEditModalOpen(false);
          setIsPreviewModalOpen(false);
        }}
      />
      <Chatbot isVisible={chatbotVisible} displayMode={displayMode}>
        <ChatbotHeader>
          <ChatbotHeaderMain>
            <ChatbotHeaderMenu onMenuToggle={() => alert('Menu toggle clicked')} />
            <ChatbotHeaderTitle displayMode={displayMode} showOnFullScreen={horizontalLogo} showOnDefault={iconLogo} />
          </ChatbotHeaderMain>
          <ChatbotHeaderActions>
            <ChatbotHeaderOptionsDropdown onSelect={onSelectDisplayMode}>
              <DropdownGroup label="Display mode">
                <DropdownList>
                  <DropdownItem
                    value={ChatbotDisplayMode.default}
                    key="switchDisplayOverlay"
                    icon={<OutlinedWindowRestoreIcon aria-hidden />}
                    isSelected={displayMode === ChatbotDisplayMode.default}
                  >
                    <span>Overlay</span>
                  </DropdownItem>
                  <DropdownItem
                    value={ChatbotDisplayMode.docked}
                    key="switchDisplayDock"
                    icon={<OpenDrawerRightIcon aria-hidden />}
                    isSelected={displayMode === ChatbotDisplayMode.docked}
                  >
                    <span>Dock to window</span>
                  </DropdownItem>
                  <DropdownItem
                    value={ChatbotDisplayMode.fullscreen}
                    key="switchDisplayFullscreen"
                    icon={<ExpandIcon aria-hidden />}
                    isSelected={displayMode === ChatbotDisplayMode.fullscreen}
                  >
                    <span>Fullscreen</span>
                  </DropdownItem>
                </DropdownList>
              </DropdownGroup>
            </ChatbotHeaderOptionsDropdown>
          </ChatbotHeaderActions>
        </ChatbotHeader>
        <FileDropZone onFileDrop={handleFileDrop} displayMode={displayMode}>
          <ChatbotContent>
            <MessageBox>
              {showAlert && (
                <ChatbotAlert
                  variant="danger"
                  onClose={() => {
                    setShowAlert(false);
                    setError(undefined);
                  }}
                  title="File upload failed"
                >
                  {error}
                </ChatbotAlert>
              )}
              <ChatbotWelcomePrompt title="Hi, ChatBot User!" description="How can I help you today?" />
              {messages.map((message) => (
                <Message key={message.name} {...message} />
              ))}
            </MessageBox>
          </ChatbotContent>
          <ChatbotFooter>
            {file && (
              <div>
                <FileDetailsLabel fileName={file.name} isLoading={isLoadingFile} onClose={onClose} />
              </div>
            )}
            <MessageBar onSendMessage={handleSend} hasAttachButton handleAttach={handleAttach} />
            <ChatbotFootnote label="ChatBot uses AI. Check for mistakes." />
          </ChatbotFooter>
        </FileDropZone>
      </Chatbot>
      {currentModalData && (
        <PreviewAttachment
          code={currentModalData?.code}
          fileName={currentModalData?.fileName}
          isModalOpen={isPreviewModalOpen}
          onEdit={() => {
            setIsPreviewModalOpen(false);
            setIsEditModalOpen(true);
          }}
          onDismiss={() => setCurrentModalData(undefined)}
          handleModalToggle={() => setIsPreviewModalOpen(false)}
          displayMode={displayMode}
        />
      )}
      {currentModalData && (
        <AttachmentEdit
          code={currentModalData?.code}
          fileName={currentModalData?.fileName}
          isModalOpen={isEditModalOpen}
          onSave={() => {
            setIsEditModalOpen(false);
          }}
          onCancel={() => setCurrentModalData(undefined)}
          handleModalToggle={() => setIsEditModalOpen(false)}
          displayMode={displayMode}
        />
      )}
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/demos/ChatbotAttachmentMenu.tsx
================================================
import React from 'react';
import ChatbotToggle from '@patternfly/chatbot/dist/dynamic/ChatbotToggle';
import Chatbot from '@patternfly/chatbot/dist/dynamic/Chatbot';
import ChatbotContent from '@patternfly/chatbot/dist/dynamic/ChatbotContent';
import ChatbotWelcomePrompt from '@patternfly/chatbot/dist/dynamic/ChatbotWelcomePrompt';
import ChatbotFooter, { ChatbotFootnote } from '@patternfly/chatbot/dist/dynamic/ChatbotFooter';
import MessageBar from '@patternfly/chatbot/dist/dynamic/MessageBar';
import MessageBox from '@patternfly/chatbot/dist/dynamic/MessageBox';
import Message, { MessageProps } from '@patternfly/chatbot/dist/dynamic/Message';
import FileDropZone from '@patternfly/chatbot/dist/dynamic/FileDropZone';
import SourceDetailsMenuItem from '@patternfly/chatbot/dist/dynamic/SourceDetailsMenuItem';
import ChatbotAlert from '@patternfly/chatbot/dist/dynamic/ChatbotAlert';
import { Divider, DropdownGroup, DropdownItem, DropdownList, DropEvent } from '@patternfly/react-core';
import FileDetailsLabel from '@patternfly/chatbot/dist/dynamic/FileDetailsLabel';
import { BellIcon, CalendarAltIcon, ClipboardIcon, CodeIcon, UploadIcon } from '@patternfly/react-icons';
import { useDropzone } from 'react-dropzone';
import userAvatar from '../Messages/user_avatar.svg';
import patternflyAvatar from '../Messages/patternfly_avatar.jpg';
import '@patternfly/react-core/dist/styles/base.css';
import '@patternfly/chatbot/dist/css/main.css';

const initialMenuItems = [
  <DropdownList key="list-1">
    <DropdownItem value="auth-operator Pod" id="0" className="pf-chatbot-source-details-dropdown-item">
      <SourceDetailsMenuItem
        icon={
          <svg width="24" height="25" viewBox="0 0 24 25" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path
              d="M0 12.5C0 5.87258 5.37258 0.5 12 0.5C18.6274 0.5 24 5.87258 24 12.5C24 19.1274 18.6274 24.5 12 24.5C5.37258 24.5 0 19.1274 0 12.5Z"
              fill="currentColor"
            />
            <g clipPath="url(#clip0_3280_27488)">
              <path
                d="M8.25 8.75C8.25 7.92266 8.92266 7.25 9.75 7.25H12C14.0719 7.25 15.75 8.92812 15.75 11C15.75 13.0719 14.0719 14.75 12 14.75H9.75V17C9.75 17.4148 9.41484 17.75 9 17.75C8.58516 17.75 8.25 17.4148 8.25 17V14V8.75ZM9.75 13.25H12C13.2422 13.25 14.25 12.2422 14.25 11C14.25 9.75781 13.2422 8.75 12 8.75H9.75V13.25Z"
                fill="white"
              />
            </g>
            <defs>
              <clipPath id="clip0_3280_27488">
                <rect width="7.5" height="12" fill="white" transform="translate(8.25 6.5)" />
              </clipPath>
            </defs>
          </svg>
        }
        name="auth-operator"
        type="Pod"
      />
    </DropdownItem>
  </DropdownList>,
  <DropdownGroup key="group2">
    <DropdownList>
      <DropdownItem value="Alerts" id="1" icon={<BellIcon />}>
        Alerts
      </DropdownItem>
      <DropdownItem value="Events" id="2" icon={<CalendarAltIcon />}>
        Events
      </DropdownItem>
      <DropdownItem value="Logs" id="3" icon={<ClipboardIcon />}>
        Logs
      </DropdownItem>
      <DropdownItem value="YAML - Status" id="4" icon={<CodeIcon />}>
        YAML - Status
      </DropdownItem>
      <DropdownItem value="YAML - All contents" id="5" icon={<CodeIcon />}>
        YAML - All contents
      </DropdownItem>
    </DropdownList>
  </DropdownGroup>
];

const messages: MessageProps[] = [
  {
    role: 'user',
    content: 'Hello, can you give me an example of what you can do?',
    name: 'User',
    avatar: userAvatar,
    avatarProps: { isBordered: true }
  },
  {
    role: 'bot',
    content: 'I sure can!',
    name: 'Bot',
    avatar: patternflyAvatar
  }
];

export const AttachmentMenuDemo: React.FunctionComponent = () => {
  const [chatbotVisible, setChatbotVisible] = React.useState<boolean>(true);
  const [file, setFile] = React.useState<File>();
  const [isLoadingFile, setIsLoadingFile] = React.useState<boolean>(false);
  const [userFacingMenuItems, setUserFacingMenuItems] = React.useState<React.ReactNode>([]);
  const [error, setError] = React.useState<string>();
  const [showAlert, setShowAlert] = React.useState<boolean>(false);
  const [isOpen, setIsOpen] = React.useState<boolean>(false);

  const { open, getInputProps } = useDropzone({
    onDropAccepted: (files: File[]) => {
      setIsLoadingFile(true);
      setIsOpen(false);
      // any custom validation you may want
      if (files.length > 1) {
        setShowAlert(true);
        setFile(undefined);
        setError('Uploaded more than one file.');
        return;
      }
      // this is 25MB in bytes; size is in bytes
      if (files[0].size > 25000000) {
        setShowAlert(true);
        setFile(undefined);
        setError('File is larger than 25MB.');
        return;
      }

      setFile(files[0]);
      setShowAlert(false);
      setError(undefined);
      // this is just for demo purposes, to make the loading state really obvious
      setTimeout(() => {
        setIsLoadingFile(false);
      }, 1000);
    }
  });

  const handleSend = (message) => alert(message);

  // Attachments
  // --------------------------------------------------------------------------
  const handleFileDrop = (event: DropEvent, data: File[]) => {
    setFile(data[0]);
    setIsLoadingFile(true);
    setTimeout(() => {
      setIsLoadingFile(false);
    }, 1000);
  };

  const onClose = () => {
    setFile(undefined);
  };

  // Attachmenu menu
  // --------------------------------------------------------------------------
  const uploadMenuItems = [
    <Divider key="divider" />,
    <DropdownList key="list-2">
      <DropdownItem
        onClick={() => {
          open();
          setIsOpen(!isOpen);
        }}
        key="upload"
        value="upload"
        id="upload"
        icon={<UploadIcon />}
      >
        Upload from computer
      </DropdownItem>
    </DropdownList>
  ];

  const onToggleClick = () => {
    setUserFacingMenuItems(initialMenuItems.concat(uploadMenuItems));
  };

  const findMatchingElements = (elements: React.ReactNode[], targetValue: string) => {
    let matchingElements = [] as React.ReactNode[];

    elements.forEach((element) => {
      if (React.isValidElement(element)) {
        // Check if the element's value matches the targetValue
        if (element.props.value && element.props.value.toLowerCase().includes(targetValue.toLowerCase())) {
          matchingElements.push(React.cloneElement(element, { key: element.props.value }));
        }

        // Recursively check the element's children
        const children = React.Children.toArray(element.props.children);
        matchingElements = matchingElements.concat(findMatchingElements(children, targetValue));
      }
    });

    return matchingElements;
  };

  const onTextChange = (textValue: string) => {
    if (textValue === '') {
      setUserFacingMenuItems(initialMenuItems.concat(uploadMenuItems));
      return;
    }

    const newMenuItems = findMatchingElements(initialMenuItems, textValue);
    // this is necessary because the React nodes we find traversing the recursive search
    // aren't correctly wrapped in a DropdownList. This leads to problems with the
    // auth-operator item where it winds up floating in a bad place in the DOM and never
    // gets removed
    setUserFacingMenuItems(
      <>
        <DropdownList>
          {newMenuItems.length === 0 ? (
            <DropdownItem key="no-items">No results found</DropdownItem>
          ) : (
            newMenuItems.map((item) => item)
          )}
        </DropdownList>
        {uploadMenuItems.map((item) => item)}
      </>
    );
  };

  // Main return statement
  // --------------------------------------------------------------------------
  return (
    <>
      {/* this is required for react-dropzone to work in Safari and Firefox */}
      <input {...getInputProps()} hidden />
      <ChatbotToggle
        tooltipLabel="Chatbot"
        isChatbotVisible={chatbotVisible}
        onToggleChatbot={() => setChatbotVisible(!chatbotVisible)}
      />
      <Chatbot isVisible={chatbotVisible}>
        <FileDropZone onFileDrop={handleFileDrop}>
          <>
            <ChatbotContent>
              <MessageBox>
                {showAlert && (
                  <ChatbotAlert
                    variant="danger"
                    onClose={() => {
                      setShowAlert(false);
                      setError(undefined);
                    }}
                    title="File upload failed"
                  >
                    {error}
                  </ChatbotAlert>
                )}
                <ChatbotWelcomePrompt title="Hi, ChatBot User!" description="How can I help you today?" />
                {messages.map((message) => (
                  <Message key={message.name} {...message} />
                ))}
              </MessageBox>
            </ChatbotContent>
            <ChatbotFooter>
              {file && (
                <div>
                  <FileDetailsLabel fileName={file.name} isLoading={isLoadingFile} onClose={onClose} />
                </div>
              )}
              <MessageBar
                onSendMessage={handleSend}
                attachMenuProps={{
                  isAttachMenuOpen: isOpen,
                  setIsAttachMenuOpen: setIsOpen,
                  attachMenuItems: userFacingMenuItems,
                  onAttachMenuSelect: (_ev, value) => {
                    // eslint-disable-next-line no-console
                    console.log('selected', value);
                  },
                  attachMenuInputPlaceholder: 'Search cluster resources...',
                  onAttachMenuInputChange: onTextChange,
                  onAttachMenuToggleClick: onToggleClick
                }}
              />
              <ChatbotFootnote label="ChatBot uses AI. Check for mistakes." />
            </ChatbotFooter>
          </>
        </FileDropZone>
      </Chatbot>
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/demos/ChatbotCompact.tsx
================================================
import React from 'react';

import { Bullseye, Brand, DropdownList, DropdownItem, DropdownGroup, SkipToContent } from '@patternfly/react-core';

import ChatbotToggle from '@patternfly/chatbot/dist/dynamic/ChatbotToggle';
import Chatbot, { ChatbotDisplayMode } from '@patternfly/chatbot/dist/dynamic/Chatbot';
import ChatbotContent from '@patternfly/chatbot/dist/dynamic/ChatbotContent';
import ChatbotWelcomePrompt from '@patternfly/chatbot/dist/dynamic/ChatbotWelcomePrompt';
import ChatbotFooter, { ChatbotFootnote } from '@patternfly/chatbot/dist/dynamic/ChatbotFooter';
import MessageBar from '@patternfly/chatbot/dist/dynamic/MessageBar';
import MessageBox from '@patternfly/chatbot/dist/dynamic/MessageBox';
import Message, { MessageProps } from '@patternfly/chatbot/dist/dynamic/Message';
import ChatbotConversationHistoryNav, {
  Conversation
} from '@patternfly/chatbot/dist/dynamic/ChatbotConversationHistoryNav';
import ChatbotHeader, {
  ChatbotHeaderMenu,
  ChatbotHeaderMain,
  ChatbotHeaderTitle,
  ChatbotHeaderActions,
  ChatbotHeaderSelectorDropdown,
  ChatbotHeaderOptionsDropdown
} from '@patternfly/chatbot/dist/dynamic/ChatbotHeader';

import ExpandIcon from '@patternfly/react-icons/dist/esm/icons/expand-icon';
import OpenDrawerRightIcon from '@patternfly/react-icons/dist/esm/icons/open-drawer-right-icon';
import OutlinedWindowRestoreIcon from '@patternfly/react-icons/dist/esm/icons/outlined-window-restore-icon';

import PFHorizontalLogoColor from '../UI/PF-HorizontalLogo-Color.svg';
import PFHorizontalLogoReverse from '../UI/PF-HorizontalLogo-Reverse.svg';
import PFIconLogoColor from '../UI/PF-IconLogo-Color.svg';
import PFIconLogoReverse from '../UI/PF-IconLogo-Reverse.svg';
import userAvatar from '../Messages/user_avatar.svg';
import patternflyAvatar from '../Messages/patternfly_avatar.jpg';

const footnoteProps = {
  label: 'ChatBot uses AI. Check for mistakes.',
  popover: {
    title: 'Verify information',
    description: `While ChatBot strives for accuracy, AI is experimental and can make mistakes. We cannot guarantee that all information provided by ChatBot is up to date or without error. You should always verify responses using reliable sources, especially for crucial information and decision making.`,
    bannerImage: {
      src: 'https://cdn.dribbble.com/userupload/10651749/file/original-8a07b8e39d9e8bf002358c66fce1223e.gif',
      alt: 'Example image for footnote popover'
    },
    cta: {
      label: 'Dismiss',
      onClick: () => {
        alert('Do something!');
      }
    },
    link: {
      label: 'View AI policy',
      url: 'https://www.redhat.com/'
    }
  }
};

const markdown = `A paragraph with *emphasis* and **strong importance**.

> A block quote with ~strikethrough~ and a URL: https://reactjs.org.

Here is an inline code - \`() => void\`

Here is some YAML code:

~~~yaml
apiVersion: helm.openshift.io/v1beta1/
kind: HelmChartRepository
metadata:
  name: azure-sample-repo0oooo00ooo
spec:
  connectionConfig:
  url: https://raw.githubusercontent.com/Azure-Samples/helm-charts/master/docs
~~~

Here is some JavaScript code:

~~~js
import React from 'react';

const MessageLoading = () => (
  <div className="pf-chatbot__message-loading">
    <span className="pf-chatbot__message-loading-dots">
      <span className="pf-v6-screen-reader">Loading message</span>
    </span>
  </div>
);

export default MessageLoading;

~~~
`;

// It's important to set a date and timestamp prop since the Message components re-render.
// The timestamps re-render with them.
const date = new Date();

const initialMessages: MessageProps[] = [
  {
    id: '1',
    role: 'user',
    content: 'Hello, can you give me an example of what you can do?',
    name: 'User',
    avatar: userAvatar,
    timestamp: date.toLocaleString(),
    avatarProps: { isBordered: true }
  },
  {
    id: '2',
    role: 'bot',
    content: markdown,
    name: 'Bot',
    avatar: patternflyAvatar,
    timestamp: date.toLocaleString(),
    actions: {
      // eslint-disable-next-line no-console
      positive: { onClick: () => console.log('Good response') },
      // eslint-disable-next-line no-console
      negative: { onClick: () => console.log('Bad response') },
      // eslint-disable-next-line no-console
      copy: { onClick: () => console.log('Copy') },
      // eslint-disable-next-line no-console
      share: { onClick: () => console.log('Share') },
      // eslint-disable-next-line no-console
      listen: { onClick: () => console.log('Listen') }
    }
  }
];

const welcomePrompts = [
  {
    title: 'Set up account',
    message: 'Choose the necessary settings and preferences for your account.'
  },
  {
    title: 'Troubleshoot issue',
    message: 'Find documentation and instructions to resolve your issue.'
  }
];

const initialConversations = {
  Today: [{ id: '1', text: 'Hello, can you give me an example of what you can do?' }],
  'This month': [
    {
      id: '2',
      text: 'Enterprise Linux installation and setup'
    },
    { id: '3', text: 'Troubleshoot system crash' }
  ],
  March: [
    { id: '4', text: 'Ansible security and updates' },
    { id: '5', text: 'Red Hat certification' },
    { id: '6', text: 'Lightspeed user documentation' }
  ],
  February: [
    { id: '7', text: 'Crashing pod assistance' },
    { id: '8', text: 'OpenShift AI pipelines' },
    { id: '9', text: 'Updating subscription plan' },
    { id: '10', text: 'Red Hat licensing options' }
  ],
  January: [
    { id: '11', text: 'RHEL system performance' },
    { id: '12', text: 'Manage user accounts' }
  ]
};

export const ChatbotDemo: React.FunctionComponent = () => {
  const [chatbotVisible, setChatbotVisible] = React.useState<boolean>(true);
  const [displayMode, setDisplayMode] = React.useState<ChatbotDisplayMode>(ChatbotDisplayMode.default);
  const [messages, setMessages] = React.useState<MessageProps[]>(initialMessages);
  const [selectedModel, setSelectedModel] = React.useState('Granite 7B');
  const [isSendButtonDisabled, setIsSendButtonDisabled] = React.useState(false);
  const [isDrawerOpen, setIsDrawerOpen] = React.useState(false);
  const [conversations, setConversations] = React.useState<Conversation[] | { [key: string]: Conversation[] }>(
    initialConversations
  );
  const [announcement, setAnnouncement] = React.useState<string>();
  const scrollToBottomRef = React.useRef<HTMLDivElement>(null);
  const toggleRef = React.useRef<HTMLButtonElement>(null);
  const chatbotRef = React.useRef<HTMLDivElement>(null);
  const historyRef = React.useRef<HTMLButtonElement>(null);

  // Auto-scrolls to the latest message
  React.useEffect(() => {
    // don't scroll the first load - in this demo, we know we start with two messages
    if (messages.length > 2) {
      scrollToBottomRef.current?.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages]);

  const onSelectModel = (
    _event: React.MouseEvent<Element, MouseEvent> | undefined,
    value: string | number | undefined
  ) => {
    setSelectedModel(value as string);
  };

  const onSelectDisplayMode = (
    _event: React.MouseEvent<Element, MouseEvent> | undefined,
    value: string | number | undefined
  ) => {
    setDisplayMode(value as ChatbotDisplayMode);
  };

  // you will likely want to come up with your own unique id function; this is for demo purposes only
  const generateId = () => {
    const id = Date.now() + Math.random();
    return id.toString();
  };

  const handleSend = (message: string) => {
    setIsSendButtonDisabled(true);
    const newMessages: MessageProps[] = [];
    // We can't use structuredClone since messages contains functions, but we can't mutate
    // items that are going into state or the UI won't update correctly
    messages.forEach((message) => newMessages.push(message));
    // It's important to set a timestamp prop since the Message components re-render.
    // The timestamps re-render with them.
    const date = new Date();
    newMessages.push({
      id: generateId(),
      role: 'user',
      content: message,
      name: 'User',
      avatar: userAvatar,
      timestamp: date.toLocaleString(),
      avatarProps: { isBordered: true }
    });
    newMessages.push({
      id: generateId(),
      role: 'bot',
      content: 'API response goes here',
      name: 'Bot',
      isLoading: true,
      avatar: patternflyAvatar,
      timestamp: date.toLocaleString()
    });
    setMessages(newMessages);
    // make announcement to assistive devices that new messages have been added
    setAnnouncement(`Message from User: ${message}. Message from Bot is loading.`);

    // this is for demo purposes only; in a real situation, there would be an API response we would wait for
    setTimeout(() => {
      const loadedMessages: MessageProps[] = [];
      // We can't use structuredClone since messages contains functions, but we can't mutate
      // items that are going into state or the UI won't update correctly
      newMessages.forEach((message) => loadedMessages.push(message));
      loadedMessages.pop();
      loadedMessages.push({
        id: generateId(),
        role: 'bot',
        content: 'API response goes here',
        name: 'Bot',
        isLoading: false,
        avatar: patternflyAvatar,
        timestamp: date.toLocaleString(),
        actions: {
          // eslint-disable-next-line no-console
          positive: { onClick: () => console.log('Good response') },
          // eslint-disable-next-line no-console
          negative: { onClick: () => console.log('Bad response') },
          // eslint-disable-next-line no-console
          copy: { onClick: () => console.log('Copy') },
          // eslint-disable-next-line no-console
          share: { onClick: () => console.log('Share') },
          // eslint-disable-next-line no-console
          listen: { onClick: () => console.log('Listen') }
        }
      });
      setMessages(loadedMessages);
      // make announcement to assistive devices that new message has loaded
      setAnnouncement(`Message from Bot: API response goes here`);
      setIsSendButtonDisabled(false);
    }, 5000);
  };

  const findMatchingItems = (targetValue: string) => {
    let filteredConversations = Object.entries(initialConversations).reduce((acc, [key, items]) => {
      const filteredItems = items.filter((item) => item.text.toLowerCase().includes(targetValue.toLowerCase()));
      if (filteredItems.length > 0) {
        acc[key] = filteredItems;
      }
      return acc;
    }, {});

    // append message if no items are found
    if (Object.keys(filteredConversations).length === 0) {
      filteredConversations = [{ id: '13', noIcon: true, text: 'No results found' }];
    }
    return filteredConversations;
  };

  const horizontalLogo = (
    <Bullseye>
      <Brand className="show-light" src={PFHorizontalLogoColor} alt="PatternFly" />
      <Brand className="show-dark" src={PFHorizontalLogoReverse} alt="PatternFly" />
    </Bullseye>
  );

  const iconLogo = (
    <>
      <Brand className="show-light" src={PFIconLogoColor} alt="PatternFly" />
      <Brand className="show-dark" src={PFIconLogoReverse} alt="PatternFly" />
    </>
  );

  const handleSkipToContent = (e) => {
    e.preventDefault();
    /* eslint-disable indent */
    switch (displayMode) {
      case ChatbotDisplayMode.default:
        if (!chatbotVisible && toggleRef.current) {
          toggleRef.current.focus();
        }
        if (chatbotVisible && chatbotRef.current) {
          chatbotRef.current.focus();
        }
        break;

      case ChatbotDisplayMode.docked:
        if (chatbotRef.current) {
          chatbotRef.current.focus();
        }
        break;
      default:
        if (historyRef.current) {
          historyRef.current.focus();
        }
        break;
    }
    /* eslint-enable indent */
  };

  return (
    <>
      <SkipToContent onClick={handleSkipToContent} href="#">
        Skip to chatbot
      </SkipToContent>
      <ChatbotToggle
        tooltipLabel="Chatbot"
        isChatbotVisible={chatbotVisible}
        onToggleChatbot={function () {
          setChatbotVisible(!chatbotVisible);
        }}
        id="chatbot-toggle"
        ref={toggleRef}
      />
      <Chatbot isCompact isVisible={chatbotVisible} displayMode={displayMode} ref={chatbotRef}>
        <ChatbotConversationHistoryNav
          displayMode={displayMode}
          onDrawerToggle={() => {
            setIsDrawerOpen(!isDrawerOpen);
            setConversations(initialConversations);
          }}
          isDrawerOpen={isDrawerOpen}
          setIsDrawerOpen={setIsDrawerOpen}
          activeItemId="1"
          // eslint-disable-next-line no-console
          onSelectActiveItem={(e, selectedItem) => console.log(`Selected history item with id ${selectedItem}`)}
          conversations={conversations}
          onNewChat={() => {
            setIsDrawerOpen(!isDrawerOpen);
            setMessages([]);
            setConversations(initialConversations);
          }}
          handleTextInputChange={(value: string) => {
            if (value === '') {
              setConversations(initialConversations);
            }
            // this is where you would perform search on the items in the drawer
            // and update the state
            const newConversations: { [key: string]: Conversation[] } = findMatchingItems(value);
            setConversations(newConversations);
          }}
          isCompact
          drawerContent={
            <>
              <ChatbotHeader>
                <ChatbotHeaderMain>
                  <ChatbotHeaderMenu
                    ref={historyRef}
                    aria-expanded={isDrawerOpen}
                    onMenuToggle={() => setIsDrawerOpen(!isDrawerOpen)}
                    isCompact
                  />
                  <ChatbotHeaderTitle
                    displayMode={displayMode}
                    showOnFullScreen={horizontalLogo}
                    showOnDefault={iconLogo}
                  ></ChatbotHeaderTitle>
                </ChatbotHeaderMain>
                <ChatbotHeaderActions>
                  <ChatbotHeaderSelectorDropdown value={selectedModel} onSelect={onSelectModel} isCompact>
                    <DropdownList>
                      <DropdownItem value="Granite 7B" key="granite">
                        Granite 7B
                      </DropdownItem>
                      <DropdownItem value="Llama 3.0" key="llama">
                        Llama 3.0
                      </DropdownItem>
                      <DropdownItem value="Mistral 3B" key="mistral">
                        Mistral 3B
                      </DropdownItem>
                    </DropdownList>
                  </ChatbotHeaderSelectorDropdown>
                  <ChatbotHeaderOptionsDropdown onSelect={onSelectDisplayMode} isCompact>
                    <DropdownGroup label="Display mode">
                      <DropdownList>
                        <DropdownItem
                          value={ChatbotDisplayMode.default}
                          key="switchDisplayOverlay"
                          icon={<OutlinedWindowRestoreIcon aria-hidden />}
                          isSelected={displayMode === ChatbotDisplayMode.default}
                        >
                          <span>Overlay</span>
                        </DropdownItem>
                        <DropdownItem
                          value={ChatbotDisplayMode.docked}
                          key="switchDisplayDock"
                          icon={<OpenDrawerRightIcon aria-hidden />}
                          isSelected={displayMode === ChatbotDisplayMode.docked}
                        >
                          <span>Dock to window</span>
                        </DropdownItem>
                        <DropdownItem
                          value={ChatbotDisplayMode.fullscreen}
                          key="switchDisplayFullscreen"
                          icon={<ExpandIcon aria-hidden />}
                          isSelected={displayMode === ChatbotDisplayMode.fullscreen}
                        >
                          <span>Fullscreen</span>
                        </DropdownItem>
                      </DropdownList>
                    </DropdownGroup>
                  </ChatbotHeaderOptionsDropdown>
                </ChatbotHeaderActions>
              </ChatbotHeader>
              <ChatbotContent>
                {/* Update the announcement prop on MessageBox whenever a new message is sent
                 so that users of assistive devices receive sufficient context  */}
                <MessageBox announcement={announcement}>
                  <ChatbotWelcomePrompt
                    title="Hi, ChatBot User!"
                    description="How can I help you today?"
                    prompts={welcomePrompts}
                    isCompact
                  />
                  {/* This code block enables scrolling to the top of the last message.
                  You can instead choose to move the div with scrollToBottomRef on it below
                  the map of messages, so that users are forced to scroll to the bottom.
                  If you are using streaming, you will want to take a different approach;
                  see: https://github.com/patternfly/chatbot/issues/201#issuecomment-2400725173 */}
                  {messages.map((message, index) => {
                    if (index === messages.length - 1) {
                      return (
                        <>
                          <div ref={scrollToBottomRef}></div>
                          <Message key={message.id} {...message} />
                        </>
                      );
                    }
                    return <Message key={message.id} {...message} />;
                  })}
                </MessageBox>
              </ChatbotContent>
              <ChatbotFooter isCompact>
                <MessageBar
                  onSendMessage={handleSend}
                  hasMicrophoneButton
                  isSendButtonDisabled={isSendButtonDisabled}
                  isCompact
                />
                <ChatbotFootnote {...footnoteProps} />
              </ChatbotFooter>
            </>
          }
        ></ChatbotConversationHistoryNav>
      </Chatbot>
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/demos/ChatbotInDrawer.tsx
================================================
import React from 'react';

import {
  Brand,
  DropdownList,
  DropdownItem,
  Page,
  Masthead,
  MastheadMain,
  MastheadBrand,
  MastheadLogo,
  PageSidebarBody,
  PageSidebar,
  MastheadToggle,
  PageToggleButton,
  SkipToContent,
  Drawer,
  DrawerContent,
  DrawerContentBody,
  DrawerPanelContent
} from '@patternfly/react-core';

import Chatbot, { ChatbotDisplayMode } from '@patternfly/chatbot/dist/dynamic/Chatbot';
import ChatbotContent from '@patternfly/chatbot/dist/dynamic/ChatbotContent';
import ChatbotWelcomePrompt from '@patternfly/chatbot/dist/dynamic/ChatbotWelcomePrompt';
import ChatbotFooter, { ChatbotFootnote } from '@patternfly/chatbot/dist/dynamic/ChatbotFooter';
import MessageBar from '@patternfly/chatbot/dist/dynamic/MessageBar';
import MessageBox from '@patternfly/chatbot/dist/dynamic/MessageBox';
import Message, { MessageProps } from '@patternfly/chatbot/dist/dynamic/Message';
import ChatbotConversationHistoryNav, {
  Conversation
} from '@patternfly/chatbot/dist/dynamic/ChatbotConversationHistoryNav';
import ChatbotHeader, {
  ChatbotHeaderMenu,
  ChatbotHeaderMain,
  ChatbotHeaderTitle,
  ChatbotHeaderActions,
  ChatbotHeaderSelectorDropdown
} from '@patternfly/chatbot/dist/dynamic/ChatbotHeader';
import PFIconLogoColor from '../UI/PF-IconLogo-Color.svg';
import PFIconLogoReverse from '../UI/PF-IconLogo-Reverse.svg';
import { BarsIcon } from '@patternfly/react-icons';
import userAvatar from '../Messages/user_avatar.svg';
import patternflyAvatar from '../Messages/patternfly_avatar.jpg';
import '@patternfly/react-core/dist/styles/base.css';
import '@patternfly/chatbot/dist/css/main.css';

const footnoteProps = {
  label: 'ChatBot uses AI. Check for mistakes.',
  popover: {
    title: 'Verify accuracy',
    description: `While ChatBot strives for accuracy, there's always a possibility of errors. It's a good practice to verify critical information from reliable sources, especially if it's crucial for decision-making or actions.`,
    bannerImage: {
      src: 'https://cdn.dribbble.com/userupload/10651749/file/original-8a07b8e39d9e8bf002358c66fce1223e.gif',
      alt: 'Example image for footnote popover'
    },
    cta: {
      label: 'Got it',
      onClick: () => {
        alert('Do something!');
      }
    },
    link: {
      label: 'Learn more',
      url: 'https://www.redhat.com/'
    }
  }
};

const markdown = `A paragraph with *emphasis* and **strong importance**.

> A block quote with ~strikethrough~ and a URL: https://reactjs.org.

Here is an inline code - \`() => void\`

Here is some YAML code:

~~~yaml
apiVersion: helm.openshift.io/v1beta1/
kind: HelmChartRepository
metadata:
  name: azure-sample-repo0oooo00ooo
spec:
  connectionConfig:
  url: https://raw.githubusercontent.com/Azure-Samples/helm-charts/master/docs
~~~

Here is some JavaScript code:

~~~js
import React from 'react';

const MessageLoading = () => (
  <div className="pf-chatbot__message-loading">
    <span className="pf-chatbot__message-loading-dots">
      <span className="pf-v6-screen-reader">Loading message</span>
    </span>
  </div>
);

export default MessageLoading;

~~~
`;

// It's important to set a date and timestamp prop since the Message components re-render.
// The timestamps re-render with them.
const date = new Date();

const initialMessages: MessageProps[] = [
  {
    id: '1',
    role: 'user',
    content: 'Hello, can you give me an example of what you can do?',
    name: 'User',
    avatar: userAvatar,
    timestamp: date.toLocaleString(),
    avatarProps: { isBordered: true }
  },
  {
    id: '2',
    role: 'bot',
    content: markdown,
    name: 'Bot',
    avatar: patternflyAvatar,
    timestamp: date.toLocaleString(),
    actions: {
      // eslint-disable-next-line no-console
      positive: { onClick: () => console.log('Good response') },
      // eslint-disable-next-line no-console
      negative: { onClick: () => console.log('Bad response') },
      // eslint-disable-next-line no-console
      copy: { onClick: () => console.log('Copy') },
      // eslint-disable-next-line no-console
      share: { onClick: () => console.log('Share') },
      // eslint-disable-next-line no-console
      listen: { onClick: () => console.log('Listen') }
    }
  }
];

const welcomePrompts = [
  {
    title: 'Topic 1',
    message: 'Helpful prompt for Topic 1'
  },
  {
    title: 'Topic 2',
    message: 'Helpful prompt for Topic 2'
  }
];

const initialConversations = {
  Today: [{ id: '1', text: 'Hello, can you give me an example of what you can do?' }],
  'This month': [
    {
      id: '2',
      text: 'Enterprise Linux installation and setup'
    },
    { id: '3', text: 'Troubleshoot system crash' }
  ],
  March: [
    { id: '4', text: 'Ansible security and updates' },
    { id: '5', text: 'Red Hat certification' },
    { id: '6', text: 'Lightspeed user documentation' }
  ],
  February: [
    { id: '7', text: 'Crashing pod assistance' },
    { id: '8', text: 'OpenShift AI pipelines' },
    { id: '9', text: 'Updating subscription plan' },
    { id: '10', text: 'Red Hat licensing options' }
  ],
  January: [
    { id: '11', text: 'RHEL system performance' },
    { id: '12', text: 'Manage user accounts' }
  ]
};

export const EmbeddedChatbotDemo: React.FunctionComponent = () => {
  const [messages, setMessages] = React.useState<MessageProps[]>(initialMessages);
  const [selectedModel, setSelectedModel] = React.useState('Granite 7B');
  const [isSendButtonDisabled, setIsSendButtonDisabled] = React.useState(false);
  const [isDrawerOpen, setIsDrawerOpen] = React.useState(false);
  const [conversations, setConversations] = React.useState<Conversation[] | { [key: string]: Conversation[] }>(
    initialConversations
  );
  const [isSidebarOpen, setIsSidebarOpen] = React.useState(false);
  const [announcement, setAnnouncement] = React.useState<string>();
  const scrollToBottomRef = React.useRef<HTMLDivElement>(null);
  const historyRef = React.useRef<HTMLButtonElement>(null);
  const drawerRef = React.useRef<HTMLDivElement>();

  const displayMode = ChatbotDisplayMode.drawer;
  const isExpanded = true;

  const onExpand = () => {
    drawerRef.current && drawerRef.current.focus();
  };

  // Auto-scrolls to the latest message
  React.useEffect(() => {
    // don't scroll the first load - in this demo, we know we start with two messages
    if (messages.length > 2) {
      scrollToBottomRef.current?.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages]);

  const onSelectModel = (
    _event: React.MouseEvent<Element, MouseEvent> | undefined,
    value: string | number | undefined
  ) => {
    setSelectedModel(value as string);
  };

  // you will likely want to come up with your own unique id function; this is for demo purposes only
  const generateId = () => {
    const id = Date.now() + Math.random();
    return id.toString();
  };

  const handleSend = (message: string) => {
    setIsSendButtonDisabled(true);
    const newMessages: MessageProps[] = [];
    // We can't use structuredClone since messages contains functions, but we can't mutate
    // items that are going into state or the UI won't update correctly
    messages.forEach((message) => newMessages.push(message));
    // It's important to set a timestamp prop since the Message components re-render.
    // The timestamps re-render with them.
    const date = new Date();
    newMessages.push({
      id: generateId(),
      role: 'user',
      content: message,
      name: 'User',
      avatar: userAvatar,
      timestamp: date.toLocaleString(),
      avatarProps: { isBordered: true }
    });
    newMessages.push({
      id: generateId(),
      role: 'bot',
      content: 'API response goes here',
      name: 'Bot',
      avatar: patternflyAvatar,
      isLoading: true,
      timestamp: date.toLocaleString()
    });
    setMessages(newMessages);
    // make announcement to assistive devices that new messages have been added
    setAnnouncement(`Message from User: ${message}. Message from Bot is loading.`);

    // this is for demo purposes only; in a real situation, there would be an API response we would wait for
    setTimeout(() => {
      const loadedMessages: MessageProps[] = [];
      // we can't use structuredClone since messages contains functions, but we can't mutate
      // items that are going into state or the UI won't update correctly
      newMessages.forEach((message) => loadedMessages.push(message));
      loadedMessages.pop();
      loadedMessages.push({
        id: generateId(),
        role: 'bot',
        content: 'API response goes here',
        name: 'Bot',
        avatar: patternflyAvatar,
        isLoading: false,
        actions: {
          // eslint-disable-next-line no-console
          positive: { onClick: () => console.log('Good response') },
          // eslint-disable-next-line no-console
          negative: { onClick: () => console.log('Bad response') },
          // eslint-disable-next-line no-console
          copy: { onClick: () => console.log('Copy') },
          // eslint-disable-next-line no-console
          share: { onClick: () => console.log('Share') },
          // eslint-disable-next-line no-console
          listen: { onClick: () => console.log('Listen') }
        },
        timestamp: date.toLocaleString()
      });
      setMessages(loadedMessages);
      // make announcement to assistive devices that new message has loaded
      setAnnouncement(`Message from Bot: API response goes here`);
      setIsSendButtonDisabled(false);
    }, 5000);
  };

  const findMatchingItems = (targetValue: string) => {
    let filteredConversations = Object.entries(initialConversations).reduce((acc, [key, items]) => {
      const filteredItems = items.filter((item) => item.text.toLowerCase().includes(targetValue.toLowerCase()));
      if (filteredItems.length > 0) {
        acc[key] = filteredItems;
      }
      return acc;
    }, {});

    // append message if no items are found
    if (Object.keys(filteredConversations).length === 0) {
      filteredConversations = [{ id: '13', noIcon: true, text: 'No results found' }];
    }
    return filteredConversations;
  };

  const iconLogo = (
    <>
      <Brand className="show-light" src={PFIconLogoColor} alt="PatternFly" />
      <Brand className="show-dark" src={PFIconLogoReverse} alt="PatternFly" />
    </>
  );
  const masthead = (
    <Masthead>
      <MastheadMain>
        <MastheadToggle>
          <PageToggleButton
            variant="plain"
            aria-label="Global navigation"
            isSidebarOpen={isSidebarOpen}
            onSidebarToggle={() => setIsSidebarOpen(!isSidebarOpen)}
            id="fill-nav-toggle"
          >
            <BarsIcon />
          </PageToggleButton>
        </MastheadToggle>
        <MastheadBrand>
          <MastheadLogo href="https://patternfly.org" target="_blank">
            Logo
          </MastheadLogo>
        </MastheadBrand>
      </MastheadMain>
    </Masthead>
  );

  const sidebar = (
    <PageSidebar isSidebarOpen={isSidebarOpen} id="fill-sidebar">
      <PageSidebarBody>Navigation</PageSidebarBody>
    </PageSidebar>
  );

  const skipToChatbot = (event: React.MouseEvent) => {
    event.preventDefault();
    if (historyRef.current) {
      historyRef.current.focus();
    }
  };

  const skipToContent = (
    /* You can also add a SkipToContent for your main content here */
    <SkipToContent href="#" onClick={skipToChatbot}>
      Skip to chatbot
    </SkipToContent>
  );

  const chatbot = (
    <Chatbot displayMode={displayMode}>
      <ChatbotConversationHistoryNav
        displayMode={displayMode}
        onDrawerToggle={() => {
          setIsDrawerOpen(!isDrawerOpen);
          setConversations(initialConversations);
        }}
        isDrawerOpen={isDrawerOpen}
        setIsDrawerOpen={setIsDrawerOpen}
        activeItemId="1"
        // eslint-disable-next-line no-console
        onSelectActiveItem={(e, selectedItem) => console.log(`Selected history item with id ${selectedItem}`)}
        conversations={conversations}
        onNewChat={() => {
          setIsDrawerOpen(!isDrawerOpen);
          setMessages([]);
          setConversations(initialConversations);
        }}
        handleTextInputChange={(value: string) => {
          if (value === '') {
            setConversations(initialConversations);
          }
          // this is where you would perform search on the items in the drawer
          // and update the state
          const newConversations: { [key: string]: Conversation[] } = findMatchingItems(value);
          setConversations(newConversations);
        }}
        drawerContent={
          <>
            <ChatbotHeader>
              <ChatbotHeaderMain>
                <ChatbotHeaderMenu
                  ref={historyRef}
                  aria-expanded={isDrawerOpen}
                  onMenuToggle={() => setIsDrawerOpen(!isDrawerOpen)}
                />
                <ChatbotHeaderTitle>{iconLogo}</ChatbotHeaderTitle>
              </ChatbotHeaderMain>
              <ChatbotHeaderActions>
                <ChatbotHeaderSelectorDropdown value={selectedModel} onSelect={onSelectModel}>
                  <DropdownList>
                    <DropdownItem value="Granite 7B" key="granite">
                      Granite 7B
                    </DropdownItem>
                    <DropdownItem value="Llama 3.0" key="llama">
                      Llama 3.0
                    </DropdownItem>
                    <DropdownItem value="Mistral 3B" key="mistral">
                      Mistral 3B
                    </DropdownItem>
                  </DropdownList>
                </ChatbotHeaderSelectorDropdown>
              </ChatbotHeaderActions>
            </ChatbotHeader>
            <ChatbotContent>
              {/* Update the announcement prop on MessageBox whenever a new message is sent
                 so that users of assistive devices receive sufficient context  */}
              <MessageBox announcement={announcement}>
                <ChatbotWelcomePrompt
                  title="Hello, Chatbot User"
                  description="How may I help you today?"
                  prompts={welcomePrompts}
                />
                {/* This code block enables scrolling to the top of the last message.
                  You can instead choose to move the div with scrollToBottomRef on it below 
                  the map of messages, so that users are forced to scroll to the bottom.
                  If you are using streaming, you will want to take a different approach; 
                  see: https://github.com/patternfly/chatbot/issues/201#issuecomment-2400725173 */}
                {messages.map((message, index) => {
                  if (index === messages.length - 1) {
                    return (
                      <>
                        <div ref={scrollToBottomRef}></div>
                        <Message key={message.id} {...message} />
                      </>
                    );
                  }
                  return <Message key={message.id} {...message} />;
                })}
              </MessageBox>
            </ChatbotContent>
            <ChatbotFooter>
              <MessageBar onSendMessage={handleSend} hasMicrophoneButton isSendButtonDisabled={isSendButtonDisabled} />
              <ChatbotFootnote {...footnoteProps} />
            </ChatbotFooter>
          </>
        }
      ></ChatbotConversationHistoryNav>
    </Chatbot>
  );

  const panelContent = <DrawerPanelContent>{chatbot}</DrawerPanelContent>;

  return (
    <Drawer isExpanded={isExpanded} isInline onExpand={onExpand}>
      <DrawerContent panelContent={panelContent}>
        <DrawerContentBody>
          <Page skipToContent={skipToContent} masthead={masthead} sidebar={sidebar} isContentFilled></Page>
        </DrawerContentBody>
      </DrawerContent>
    </Drawer>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/demos/EmbeddedChatbot.tsx
================================================
import React from 'react';

import {
  Bullseye,
  Brand,
  DropdownList,
  DropdownItem,
  Page,
  Masthead,
  MastheadMain,
  MastheadBrand,
  MastheadLogo,
  PageSidebarBody,
  PageSidebar,
  MastheadToggle,
  PageToggleButton,
  SkipToContent
} from '@patternfly/react-core';

import Chatbot, { ChatbotDisplayMode } from '@patternfly/chatbot/dist/dynamic/Chatbot';
import ChatbotContent from '@patternfly/chatbot/dist/dynamic/ChatbotContent';
import ChatbotWelcomePrompt from '@patternfly/chatbot/dist/dynamic/ChatbotWelcomePrompt';
import ChatbotFooter, { ChatbotFootnote } from '@patternfly/chatbot/dist/dynamic/ChatbotFooter';
import MessageBar from '@patternfly/chatbot/dist/dynamic/MessageBar';
import MessageBox from '@patternfly/chatbot/dist/dynamic/MessageBox';
import Message, { MessageProps } from '@patternfly/chatbot/dist/dynamic/Message';
import ChatbotConversationHistoryNav, {
  Conversation
} from '@patternfly/chatbot/dist/dynamic/ChatbotConversationHistoryNav';
import ChatbotHeader, {
  ChatbotHeaderMenu,
  ChatbotHeaderMain,
  ChatbotHeaderTitle,
  ChatbotHeaderActions,
  ChatbotHeaderSelectorDropdown
} from '@patternfly/chatbot/dist/dynamic/ChatbotHeader';

import PFHorizontalLogoColor from '../UI/PF-HorizontalLogo-Color.svg';
import PFHorizontalLogoReverse from '../UI/PF-HorizontalLogo-Reverse.svg';
import { BarsIcon } from '@patternfly/react-icons';
import userAvatar from '../Messages/user_avatar.svg';
import patternflyAvatar from '../Messages/patternfly_avatar.jpg';
import '@patternfly/react-core/dist/styles/base.css';
import '@patternfly/chatbot/dist/css/main.css';

const footnoteProps = {
  label: 'ChatBot uses AI. Check for mistakes.',
  popover: {
    title: 'Verify information',
    description: `While ChatBot strives for accuracy, AI is experimental and can make mistakes. We cannot guarantee that all information provided by ChatBot is up to date or without error. You should always verify responses using reliable sources, especially for crucial information and decision making.`,
    bannerImage: {
      src: 'https://cdn.dribbble.com/userupload/10651749/file/original-8a07b8e39d9e8bf002358c66fce1223e.gif',
      alt: 'Example image for footnote popover'
    },
    cta: {
      label: 'Dismiss',
      onClick: () => {
        alert('Do something!');
      }
    },
    link: {
      label: 'View AI policy',
      url: 'https://www.redhat.com/'
    }
  }
};

const markdown = `A paragraph with *emphasis* and **strong importance**.

> A block quote with ~strikethrough~ and a URL: https://reactjs.org.

Here is an inline code - \`() => void\`

Here is some YAML code:

~~~yaml
apiVersion: helm.openshift.io/v1beta1/
kind: HelmChartRepository
metadata:
  name: azure-sample-repo0oooo00ooo
spec:
  connectionConfig:
  url: https://raw.githubusercontent.com/Azure-Samples/helm-charts/master/docs
~~~

Here is some JavaScript code:

~~~js
import React from 'react';

const MessageLoading = () => (
  <div className="pf-chatbot__message-loading">
    <span className="pf-chatbot__message-loading-dots">
      <span className="pf-v6-screen-reader">Loading message</span>
    </span>
  </div>
);

export default MessageLoading;

~~~
`;

// It's important to set a date and timestamp prop since the Message components re-render.
// The timestamps re-render with them.
const date = new Date();

const initialMessages: MessageProps[] = [
  {
    id: '1',
    role: 'user',
    content: 'Hello, can you give me an example of what you can do?',
    name: 'User',
    avatar: userAvatar,
    timestamp: date.toLocaleString(),
    avatarProps: { isBordered: true }
  },
  {
    id: '2',
    role: 'bot',
    content: markdown,
    name: 'Bot',
    avatar: patternflyAvatar,
    timestamp: date.toLocaleString(),
    actions: {
      // eslint-disable-next-line no-console
      positive: { onClick: () => console.log('Good response') },
      // eslint-disable-next-line no-console
      negative: { onClick: () => console.log('Bad response') },
      // eslint-disable-next-line no-console
      copy: { onClick: () => console.log('Copy') },
      // eslint-disable-next-line no-console
      share: { onClick: () => console.log('Share') },
      // eslint-disable-next-line no-console
      listen: { onClick: () => console.log('Listen') }
    }
  }
];

const welcomePrompts = [
  {
    title: 'Set up account',
    message: 'Choose the necessary settings and preferences for your account.'
  },
  {
    title: 'Troubleshoot issue',
    message: 'Find documentation and instructions to resolve your issue.'
  }
];

const initialConversations = {
  Today: [{ id: '1', text: 'Hello, can you give me an example of what you can do?' }],
  'This month': [
    {
      id: '2',
      text: 'Enterprise Linux installation and setup'
    },
    { id: '3', text: 'Troubleshoot system crash' }
  ],
  March: [
    { id: '4', text: 'Ansible security and updates' },
    { id: '5', text: 'Red Hat certification' },
    { id: '6', text: 'Lightspeed user documentation' }
  ],
  February: [
    { id: '7', text: 'Crashing pod assistance' },
    { id: '8', text: 'OpenShift AI pipelines' },
    { id: '9', text: 'Updating subscription plan' },
    { id: '10', text: 'Red Hat licensing options' }
  ],
  January: [
    { id: '11', text: 'RHEL system performance' },
    { id: '12', text: 'Manage user accounts' }
  ]
};

export const EmbeddedChatbotDemo: React.FunctionComponent = () => {
  const [messages, setMessages] = React.useState<MessageProps[]>(initialMessages);
  const [selectedModel, setSelectedModel] = React.useState('Granite 7B');
  const [isSendButtonDisabled, setIsSendButtonDisabled] = React.useState(false);
  const [isDrawerOpen, setIsDrawerOpen] = React.useState(false);
  const [conversations, setConversations] = React.useState<Conversation[] | { [key: string]: Conversation[] }>(
    initialConversations
  );
  const [isSidebarOpen, setIsSidebarOpen] = React.useState(false);
  const [announcement, setAnnouncement] = React.useState<string>();
  const scrollToBottomRef = React.useRef<HTMLDivElement>(null);
  const historyRef = React.useRef<HTMLButtonElement>(null);

  const displayMode = ChatbotDisplayMode.embedded;
  // Autu-scrolls to the latest message
  React.useEffect(() => {
    // don't scroll the first load - in this demo, we know we start with two messages
    if (messages.length > 2) {
      scrollToBottomRef.current?.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages]);

  const onSelectModel = (
    _event: React.MouseEvent<Element, MouseEvent> | undefined,
    value: string | number | undefined
  ) => {
    setSelectedModel(value as string);
  };

  // you will likely want to come up with your own unique id function; this is for demo purposes only
  const generateId = () => {
    const id = Date.now() + Math.random();
    return id.toString();
  };

  const handleSend = (message: string) => {
    setIsSendButtonDisabled(true);
    const newMessages: MessageProps[] = [];
    // We can't use structuredClone since messages contains functions, but we can't mutate
    // items that are going into state or the UI won't update correctly
    messages.forEach((message) => newMessages.push(message));
    // It's important to set a timestamp prop since the Message components re-render.
    // The timestamps re-render with them.
    const date = new Date();
    newMessages.push({
      id: generateId(),
      role: 'user',
      content: message,
      name: 'User',
      avatar: userAvatar,
      timestamp: date.toLocaleString(),
      avatarProps: { isBordered: true }
    });
    newMessages.push({
      id: generateId(),
      role: 'bot',
      content: 'API response goes here',
      name: 'Bot',
      avatar: patternflyAvatar,
      isLoading: true,
      timestamp: date.toLocaleString()
    });
    setMessages(newMessages);
    // make announcement to assistive devices that new messages have been added
    setAnnouncement(`Message from User: ${message}. Message from Bot is loading.`);

    // this is for demo purposes only; in a real situation, there would be an API response we would wait for
    setTimeout(() => {
      const loadedMessages: MessageProps[] = [];
      // we can't use structuredClone since messages contains functions, but we can't mutate
      // items that are going into state or the UI won't update correctly
      newMessages.forEach((message) => loadedMessages.push(message));
      loadedMessages.pop();
      loadedMessages.push({
        id: generateId(),
        role: 'bot',
        content: 'API response goes here',
        name: 'Bot',
        avatar: patternflyAvatar,
        isLoading: false,
        actions: {
          // eslint-disable-next-line no-console
          positive: { onClick: () => console.log('Good response') },
          // eslint-disable-next-line no-console
          negative: { onClick: () => console.log('Bad response') },
          // eslint-disable-next-line no-console
          copy: { onClick: () => console.log('Copy') },
          // eslint-disable-next-line no-console
          share: { onClick: () => console.log('Share') },
          // eslint-disable-next-line no-console
          listen: { onClick: () => console.log('Listen') }
        },
        timestamp: date.toLocaleString()
      });
      setMessages(loadedMessages);
      // make announcement to assistive devices that new message has loaded
      setAnnouncement(`Message from Bot: API response goes here`);
      setIsSendButtonDisabled(false);
    }, 5000);
  };

  const findMatchingItems = (targetValue: string) => {
    let filteredConversations = Object.entries(initialConversations).reduce((acc, [key, items]) => {
      const filteredItems = items.filter((item) => item.text.toLowerCase().includes(targetValue.toLowerCase()));
      if (filteredItems.length > 0) {
        acc[key] = filteredItems;
      }
      return acc;
    }, {});

    // append message if no items are found
    if (Object.keys(filteredConversations).length === 0) {
      filteredConversations = [{ id: '13', noIcon: true, text: 'No results found' }];
    }
    return filteredConversations;
  };

  const horizontalLogo = (
    <Bullseye>
      <Brand className="show-light" src={PFHorizontalLogoColor} alt="PatternFly" />
      <Brand className="show-dark" src={PFHorizontalLogoReverse} alt="PatternFly" />
    </Bullseye>
  );

  const masthead = (
    <Masthead>
      <MastheadMain>
        <MastheadToggle>
          <PageToggleButton
            variant="plain"
            aria-label="Global navigation"
            isSidebarOpen={isSidebarOpen}
            onSidebarToggle={() => setIsSidebarOpen(!isSidebarOpen)}
            id="fill-nav-toggle"
          >
            <BarsIcon />
          </PageToggleButton>
        </MastheadToggle>
        <MastheadBrand>
          <MastheadLogo href="https://patternfly.org" target="_blank">
            Logo
          </MastheadLogo>
        </MastheadBrand>
      </MastheadMain>
    </Masthead>
  );

  const sidebar = (
    <PageSidebar isSidebarOpen={isSidebarOpen} id="fill-sidebar">
      <PageSidebarBody>Navigation</PageSidebarBody>
    </PageSidebar>
  );

  const skipToChatbot = (event: React.MouseEvent) => {
    event.preventDefault();
    if (historyRef.current) {
      historyRef.current.focus();
    }
  };

  const skipToContent = (
    /* You can also add a SkipToContent for your main content here */
    <SkipToContent href="#" onClick={skipToChatbot}>
      Skip to chatbot
    </SkipToContent>
  );

  return (
    <Page skipToContent={skipToContent} masthead={masthead} sidebar={sidebar} isContentFilled>
      <Chatbot displayMode={displayMode}>
        <ChatbotConversationHistoryNav
          displayMode={displayMode}
          onDrawerToggle={() => {
            setIsDrawerOpen(!isDrawerOpen);
            setConversations(initialConversations);
          }}
          isDrawerOpen={isDrawerOpen}
          setIsDrawerOpen={setIsDrawerOpen}
          activeItemId="1"
          // eslint-disable-next-line no-console
          onSelectActiveItem={(e, selectedItem) => console.log(`Selected history item with id ${selectedItem}`)}
          conversations={conversations}
          onNewChat={() => {
            setIsDrawerOpen(!isDrawerOpen);
            setMessages([]);
            setConversations(initialConversations);
          }}
          handleTextInputChange={(value: string) => {
            if (value === '') {
              setConversations(initialConversations);
            }
            // this is where you would perform search on the items in the drawer
            // and update the state
            const newConversations: { [key: string]: Conversation[] } = findMatchingItems(value);
            setConversations(newConversations);
          }}
          drawerContent={
            <>
              <ChatbotHeader>
                <ChatbotHeaderMain>
                  <ChatbotHeaderMenu
                    ref={historyRef}
                    aria-expanded={isDrawerOpen}
                    onMenuToggle={() => setIsDrawerOpen(!isDrawerOpen)}
                  />
                  <ChatbotHeaderTitle>{horizontalLogo}</ChatbotHeaderTitle>
                </ChatbotHeaderMain>
                <ChatbotHeaderActions>
                  <ChatbotHeaderSelectorDropdown value={selectedModel} onSelect={onSelectModel}>
                    <DropdownList>
                      <DropdownItem value="Granite 7B" key="granite">
                        Granite 7B
                      </DropdownItem>
                      <DropdownItem value="Llama 3.0" key="llama">
                        Llama 3.0
                      </DropdownItem>
                      <DropdownItem value="Mistral 3B" key="mistral">
                        Mistral 3B
                      </DropdownItem>
                    </DropdownList>
                  </ChatbotHeaderSelectorDropdown>
                </ChatbotHeaderActions>
              </ChatbotHeader>
              <ChatbotContent>
                {/* Update the announcement prop on MessageBox whenever a new message is sent
                 so that users of assistive devices receive sufficient context  */}
                <MessageBox announcement={announcement}>
                  <ChatbotWelcomePrompt
                    title="Hi, ChatBot User!"
                    description="How can I help you today?"
                    prompts={welcomePrompts}
                  />
                  {/* This code block enables scrolling to the top of the last message.
                  You can instead choose to move the div with scrollToBottomRef on it below 
                  the map of messages, so that users are forced to scroll to the bottom.
                  If you are using streaming, you will want to take a different approach; 
                  see: https://github.com/patternfly/chatbot/issues/201#issuecomment-2400725173 */}
                  {messages.map((message, index) => {
                    if (index === messages.length - 1) {
                      return (
                        <>
                          <div ref={scrollToBottomRef}></div>
                          <Message key={message.id} {...message} />
                        </>
                      );
                    }
                    return <Message key={message.id} {...message} />;
                  })}
                </MessageBox>
              </ChatbotContent>
              <ChatbotFooter>
                <MessageBar
                  onSendMessage={handleSend}
                  hasMicrophoneButton
                  isSendButtonDisabled={isSendButtonDisabled}
                />
                <ChatbotFootnote {...footnoteProps} />
              </ChatbotFooter>
            </>
          }
        ></ChatbotConversationHistoryNav>
      </Chatbot>
    </Page>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/demos/EmbeddedComparisonChatbot.tsx
================================================
import React from 'react';

import {
  Page,
  Masthead,
  MastheadMain,
  MastheadBrand,
  MastheadLogo,
  PageSidebarBody,
  PageSidebar,
  MastheadToggle,
  PageToggleButton
} from '@patternfly/react-core';
import Chatbot, { ChatbotDisplayMode } from '@patternfly/chatbot/dist/dynamic/Chatbot';
import ChatbotContent from '@patternfly/chatbot/dist/dynamic/ChatbotContent';
import ChatbotWelcomePrompt from '@patternfly/chatbot/dist/dynamic/ChatbotWelcomePrompt';
import ChatbotFooter from '@patternfly/chatbot/dist/dynamic/ChatbotFooter';
import MessageBar from '@patternfly/chatbot/dist/dynamic/MessageBar';
import MessageBox from '@patternfly/chatbot/dist/dynamic/MessageBox';
import Message, { MessageProps } from '@patternfly/chatbot/dist/dynamic/Message';
import ChatbotHeader, { ChatbotHeaderMain } from '@patternfly/chatbot/dist/dynamic/ChatbotHeader';
import Compare from '@patternfly/chatbot/dist/dynamic/Compare';
import { BarsIcon } from '@patternfly/react-icons';
import userAvatar from '../Messages/user_avatar.svg';
import patternflyAvatar from '../Messages/patternfly_avatar.jpg';
import '@patternfly/react-core/dist/styles/base.css';
import '@patternfly/chatbot/dist/css/main.css';

export const CompareChild = ({ name, input, hasNewInput, setIsSendButtonDisabled }) => {
  const [messages, setMessages] = React.useState<MessageProps[]>([]);
  const [announcement, setAnnouncement] = React.useState<string>();
  const scrollToBottomRef = React.useRef<HTMLDivElement>(null);
  const displayMode = ChatbotDisplayMode.embedded;

  // you will likely want to come up with your own unique id function; this is for demo purposes only
  const generateId = () => {
    const id = Date.now() + Math.random();
    return id.toString();
  };

  const handleSend = React.useCallback(
    (input: string) => {
      const date = new Date();
      const newMessages: MessageProps[] = [];
      messages.forEach((message) => newMessages.push(message));
      newMessages.push({
        avatar: userAvatar,
        avatarProps: { isBordered: true },
        id: generateId(),
        name: 'You',
        role: 'user',
        content: input,
        timestamp: `${date?.toLocaleDateString()} ${date?.toLocaleTimeString()}`
      });
      newMessages.push({
        avatar: patternflyAvatar,
        id: generateId(),
        name,
        role: 'bot',
        timestamp: `${date?.toLocaleDateString()} ${date?.toLocaleTimeString()}`,
        isLoading: true
      });
      setMessages(newMessages);
      // make announcement to assistive devices that new messages have been added
      setAnnouncement(`Message from You: ${input}. Message from ${name} is loading.`);

      // this is for demo purposes only; in a real situation, there would be an API response we would wait for
      setTimeout(() => {
        const loadedMessages: MessageProps[] = [];
        // we can't use structuredClone since messages contains functions, but we can't mutate
        // items that are going into state or the UI won't update correctly
        newMessages.forEach((message) => loadedMessages.push(message));
        loadedMessages.pop();
        loadedMessages.push({
          id: generateId(),
          role: 'bot',
          content: `API response from ${name} goes here`,
          name,
          avatar: patternflyAvatar,
          isLoading: false,
          actions: {
            // eslint-disable-next-line no-console
            positive: { onClick: () => console.log('Good response') },
            // eslint-disable-next-line no-console
            negative: { onClick: () => console.log('Bad response') },
            // eslint-disable-next-line no-console
            copy: { onClick: () => console.log('Copy') },
            // eslint-disable-next-line no-console
            share: { onClick: () => console.log('Share') },
            // eslint-disable-next-line no-console
            listen: { onClick: () => console.log('Listen') }
          },
          timestamp: date.toLocaleString()
        });
        setMessages(loadedMessages);
        // make announcement to assistive devices that new message has loaded
        setAnnouncement(`Message from ${name}: API response goes here`);
        setIsSendButtonDisabled(false);
      }, 5000);
    },
    [messages, name, setIsSendButtonDisabled]
  );

  React.useEffect(() => {
    if (input) {
      handleSend(input);
    }
  }, [hasNewInput, input]);

  // Auto-scrolls to the latest message
  React.useEffect(() => {
    // don't scroll the first load, but scroll if there's a current stream or a new source has popped up
    if (messages.length > 0) {
      scrollToBottomRef.current?.scrollIntoView();
    }
  }, [messages]);

  return (
    <Chatbot displayMode={displayMode}>
      <ChatbotHeader>
        <ChatbotHeaderMain>{name}</ChatbotHeaderMain>
      </ChatbotHeader>
      <ChatbotContent>
        <MessageBox ariaLabel={`Scrollable message log for ${name}`} announcement={announcement}>
          <ChatbotWelcomePrompt title="Hi, ChatBot User!" description="How can I help you today?" />
          {messages.map((message) => (
            <Message key={message.id} {...message} />
          ))}
          <div ref={scrollToBottomRef}></div>
        </MessageBox>
      </ChatbotContent>
    </Chatbot>
  );
};

export const EmbeddedComparisonChatbotDemo: React.FunctionComponent = () => {
  const [input, setInput] = React.useState<string>();
  const [hasNewInput, setHasNewInput] = React.useState(false);
  const [isSidebarOpen, setIsSidebarOpen] = React.useState(false);
  const [isSendButtonDisabled, setIsSendButtonDisabled] = React.useState(false);

  const handleSend = (value: string) => {
    setInput(value);
    setHasNewInput(!hasNewInput);
    setIsSendButtonDisabled(true);
  };

  const masthead = (
    <Masthead>
      <MastheadMain>
        <MastheadToggle>
          <PageToggleButton
            variant="plain"
            aria-label="Global navigation"
            isSidebarOpen={isSidebarOpen}
            onSidebarToggle={() => setIsSidebarOpen(!isSidebarOpen)}
            id="fill-nav-toggle"
          >
            <BarsIcon />
          </PageToggleButton>
        </MastheadToggle>
        <MastheadBrand>
          <MastheadLogo href="https://patternfly.org" target="_blank">
            Logo
          </MastheadLogo>
        </MastheadBrand>
      </MastheadMain>
    </Masthead>
  );

  const sidebar = (
    <PageSidebar isSidebarOpen={isSidebarOpen} id="fill-sidebar">
      <PageSidebarBody>Navigation</PageSidebarBody>
    </PageSidebar>
  );

  return (
    <Page masthead={masthead} sidebar={sidebar} isContentFilled>
      <div className="pf-chatbot__compare-container">
        <Compare
          firstChild={
            <CompareChild
              input={input}
              hasNewInput={hasNewInput}
              name="ChatBot 1"
              setIsSendButtonDisabled={setIsSendButtonDisabled}
            />
          }
          secondChild={
            <CompareChild
              input={input}
              hasNewInput={hasNewInput}
              name="ChatBot 2"
              setIsSendButtonDisabled={setIsSendButtonDisabled}
            />
          }
          firstChildDisplayName="ChatBot 1"
          secondChildDisplayName="ChatBot 2"
        />
        <ChatbotFooter>
          <MessageBar
            onSendMessage={handleSend}
            hasAttachButton={false}
            alwayShowSendButton
            isSendButtonDisabled={isSendButtonDisabled}
          />
        </ChatbotFooter>
      </div>
    </Page>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/demos/Feedback.tsx
================================================
import React from 'react';
import Message from '@patternfly/chatbot/dist/dynamic/Message';
import patternflyAvatar from '../Messages/patternfly_avatar.jpg';
import '@patternfly/react-core/dist/styles/base.css';
import '@patternfly/chatbot/dist/css/main.css';

export const MessageWithFeedbackExample: React.FunctionComponent = () => {
  const [showUserFeedbackForm, setShowUserFeedbackForm] = React.useState(false);
  const [showCompletionForm, setShowCompletionForm] = React.useState(false);
  const [launchButton, setLaunchButton] = React.useState<string>();
  const positiveRef = React.useRef<HTMLButtonElement>(null);
  const negativeRef = React.useRef<HTMLButtonElement>(null);
  const feedbackId = 'user-feedback-form';
  const completeId = 'user-feedback-received';

  const getCurrentCard = () => {
    if (showUserFeedbackForm) {
      return feedbackId;
    }
    if (showCompletionForm) {
      return completeId;
    }
  };

  const isExpanded = showUserFeedbackForm || showCompletionForm;

  const focusLaunchButton = () => {
    if (launchButton === 'positive') {
      positiveRef.current?.focus();
    }
    if (launchButton === 'negative') {
      negativeRef.current?.focus();
    }
  };

  return (
    <Message
      name="Bot"
      role="bot"
      avatar={patternflyAvatar}
      content="Bot message with user feedback flow; click on a message action to launch the feedback flow. Click submit to see the thank-you message."
      actions={{
        positive: {
          onClick: () => {
            setShowUserFeedbackForm(true);
            setShowCompletionForm(false);
            setLaunchButton('positive');
          },
          /* These are important for accessibility */
          'aria-expanded': isExpanded,
          'aria-controls': getCurrentCard(),
          ref: positiveRef
        },
        negative: {
          onClick: () => {
            setShowUserFeedbackForm(true);
            setShowCompletionForm(false);
            setLaunchButton('negative');
          },
          /* These are important for accessibility */
          'aria-expanded': isExpanded,
          'aria-controls': getCurrentCard(),
          ref: negativeRef
        }
      }}
      userFeedbackForm={
        showUserFeedbackForm
          ? /* eslint-disable indent */
            {
              quickResponses: [
                { id: '1', content: 'Helpful information' },
                { id: '2', content: 'Easy to understand' },
                { id: '3', content: 'Resolved my issue' }
              ],
              onSubmit: (quickResponse, additionalFeedback) => {
                alert(`Selected ${quickResponse} and received the additional feedback: ${additionalFeedback}`);
                setShowUserFeedbackForm(false);
                setShowCompletionForm(true);
                focusLaunchButton();
              },
              hasTextArea: true,
              onClose: () => {
                setShowUserFeedbackForm(false);
                focusLaunchButton();
              },
              id: feedbackId
            }
          : undefined
        /* eslint-enable indent */
      }
      userFeedbackComplete={
        showCompletionForm
          ? /* eslint-disable indent */
            {
              onClose: () => {
                setShowCompletionForm(false);
                focusLaunchButton();
              },
              id: completeId
            }
          : undefined
        /* eslint-enable indent */
      }
    />
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/Messages/AttachmentEdit.tsx
================================================
import React from 'react';
import { Button, Checkbox } from '@patternfly/react-core';
import { AttachmentEdit } from '@patternfly/chatbot/dist/dynamic/AttachmentEdit';

export const AttachmentEditModalExample: React.FunctionComponent = () => {
  const [isModalOpen, setIsModalOpen] = React.useState(false);
  const [isCompact, setIsCompact] = React.useState(false);

  const handleModalToggle = (_event: React.MouseEvent | MouseEvent | KeyboardEvent) => {
    setIsModalOpen(!isModalOpen);
  };

  return (
    <>
      <Checkbox
        label="Show compact version"
        isChecked={isCompact}
        onChange={() => setIsCompact(!isCompact)}
        id="modal-compact-edit"
        name="modal-compact-edit"
      ></Checkbox>
      <Button onClick={handleModalToggle}>Launch modal</Button>
      <AttachmentEdit
        code="I am a code snippet"
        fileName="test.yaml"
        handleModalToggle={handleModalToggle}
        isModalOpen={isModalOpen}
        onCancel={() => null}
        // eslint-disable-next-line no-console
        onSave={(_event, code) => console.log(`The new code is "${code}"`)}
        isCompact={isCompact}
      />
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/Messages/AttachmentError.tsx
================================================
import React from 'react';
import ChatbotAlert from '@patternfly/chatbot/dist/dynamic/ChatbotAlert';

export const AttachmentErrorExample: React.FunctionComponent = () => (
  <ChatbotAlert
    variant="danger"
    // eslint-disable-next-line no-console
    onClose={() => console.log('Clicked the close button')}
    title="Could not upload file"
  >
    Your file size must be less than 25 MB.
  </ChatbotAlert>
);



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/Messages/AttachMenu.tsx
================================================
import React from 'react';
import AttachMenu from '@patternfly/chatbot/dist/dynamic/AttachMenu';
import SourceDetailsMenuItem from '@patternfly/chatbot/dist/dynamic/SourceDetailsMenuItem';
import { Button, Divider, DropdownGroup, DropdownItem, DropdownList } from '@patternfly/react-core';
import { BellIcon, CodeIcon, ClipboardIcon, CalendarAltIcon, UploadIcon } from '@patternfly/react-icons';
import PaperclipIcon from './PaperclipIcon';

const initialMenuItems = [
  <DropdownList key="list-1">
    <DropdownItem className="pf-chatbot-source-details-dropdown-item" value="auth-operator Pod" id="0">
      <SourceDetailsMenuItem
        icon={
          <svg width="24" height="25" viewBox="0 0 24 25" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path
              d="M0 12.5C0 5.87258 5.37258 0.5 12 0.5C18.6274 0.5 24 5.87258 24 12.5C24 19.1274 18.6274 24.5 12 24.5C5.37258 24.5 0 19.1274 0 12.5Z"
              fill="currentColor"
            />
            <g clipPath="url(#clip0_3280_27488)">
              <path
                d="M8.25 8.75C8.25 7.92266 8.92266 7.25 9.75 7.25H12C14.0719 7.25 15.75 8.92812 15.75 11C15.75 13.0719 14.0719 14.75 12 14.75H9.75V17C9.75 17.4148 9.41484 17.75 9 17.75C8.58516 17.75 8.25 17.4148 8.25 17V14V8.75ZM9.75 13.25H12C13.2422 13.25 14.25 12.2422 14.25 11C14.25 9.75781 13.2422 8.75 12 8.75H9.75V13.25Z"
                fill="white"
              />
            </g>
            <defs>
              <clipPath id="clip0_3280_27488">
                <rect width="7.5" height="12" fill="white" transform="translate(8.25 6.5)" />
              </clipPath>
            </defs>
          </svg>
        }
        name="auth-operator"
        type="Pod"
      />
    </DropdownItem>
  </DropdownList>,
  <DropdownGroup key="group2">
    <DropdownList>
      <DropdownItem value="Alerts" id="1" icon={<BellIcon />}>
        Alerts
      </DropdownItem>
      <DropdownItem value="Events" id="2" icon={<CalendarAltIcon />}>
        Events
      </DropdownItem>
      <DropdownItem value="Logs" id="3" icon={<ClipboardIcon />}>
        Logs
      </DropdownItem>
      <DropdownItem value="YAML - Status" id="4" icon={<CodeIcon />}>
        YAML - Status
      </DropdownItem>
      <DropdownItem value="YAML - All contents" id="5" icon={<CodeIcon />}>
        YAML - All contents
      </DropdownItem>
    </DropdownList>
  </DropdownGroup>
];

const uploadMenuItems = [
  <Divider key="divider" />,
  <DropdownList key="list-2">
    <DropdownItem key="upload" value="upload" id="upload" icon={<UploadIcon />}>
      Upload from computer
    </DropdownItem>
  </DropdownList>
];

export const AttachmentMenuExample: React.FunctionComponent = () => {
  const [isOpen, setIsOpen] = React.useState<boolean>(false);
  const [userFacingMenuItems, setUserFacingMenuItems] = React.useState<React.ReactNode>([]);

  const onToggleClick = () => {
    setIsOpen(!isOpen);
    setUserFacingMenuItems(initialMenuItems.concat(uploadMenuItems));
  };

  const findMatchingElements = (elements: React.ReactNode[], targetValue: string) => {
    let matchingElements = [] as React.ReactNode[];

    elements.forEach((element) => {
      if (React.isValidElement(element)) {
        // Check if the element's value matches the targetValue
        if (element.props.value && element.props.value.toLowerCase().includes(targetValue.toLowerCase())) {
          matchingElements.push(React.cloneElement(element, { key: element.props.value }));
        }

        // Recursively check the element's children
        const children = React.Children.toArray(element.props.children);
        matchingElements = matchingElements.concat(findMatchingElements(children, targetValue));
      }
    });

    return matchingElements;
  };

  const onTextChange = (textValue: string) => {
    if (textValue === '') {
      setUserFacingMenuItems(initialMenuItems.concat(uploadMenuItems));
      return;
    }

    const newMenuItems = findMatchingElements(initialMenuItems, textValue);
    // this is necessary because the React nodes we find traversing the recursive search
    // aren't correctly wrapped in a DropdownList. This leads to problems with the
    // auth-operator item where it winds up floating in a bad place in the DOM and never
    // gets removed
    setUserFacingMenuItems(
      <>
        <DropdownList>
          {newMenuItems.length === 0 ? (
            <DropdownItem key="no-items">No results found</DropdownItem>
          ) : (
            newMenuItems.map((item) => item)
          )}
        </DropdownList>
        {uploadMenuItems.map((item) => item)}
      </>
    );
  };

  return (
    <AttachMenu
      filteredItems={userFacingMenuItems}
      isOpen={isOpen}
      onOpenChange={(isOpen) => setIsOpen(isOpen)}
      onOpenChangeKeys={['Escape']}
      // eslint-disable-next-line no-console
      onSelect={(_ev, value) => console.log('selected', value)}
      handleTextInputChange={onTextChange}
      popperProps={{ direction: 'up', distance: '8' }}
      searchInputPlaceholder="Search cluster resources..."
      toggle={(toggleRef) => (
        <Button
          style={{
            alignItems: 'center',
            borderRadius: '50%',
            display: 'flex',
            height: '48px',
            justifyContent: 'center',
            padding: '0',
            width: '48px',
            lineHeight: '1rem'
          }}
          ref={toggleRef}
          onClick={onToggleClick}
          icon={<img src={PaperclipIcon} alt="Add an attachment" />}
        />
      )}
    />
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/Messages/BotMessage.tsx
================================================
import React from 'react';
import Message from '@patternfly/chatbot/dist/dynamic/Message';
import patternflyAvatar from './patternfly_avatar.jpg';
import squareImg from './PF-social-color-square.svg';
import {
  AlertActionLink,
  MenuToggle,
  MenuToggleElement,
  Select,
  SelectList,
  SelectOption
} from '@patternfly/react-core';

export const BotMessageExample: React.FunctionComponent = () => {
  const [variant, setVariant] = React.useState<string>('Code');
  const [isOpen, setIsOpen] = React.useState(false);
  const [selected, setSelected] = React.useState<string>('Message content type');

  /* eslint-disable indent */
  const renderContent = () => {
    switch (variant) {
      case 'Code':
        return code;
      case 'Heading':
        return heading;
      case 'Emphasis':
        return emphasis;
      case 'Block quotes':
        return blockQuotes;
      case 'Ordered list':
        return orderedList;
      case 'Unordered list':
        return unorderedList;
      case 'More complex list':
        return moreComplexList;
      case 'Inline code':
        return inlineCode;
      case 'Link':
        return link;
      case 'Table':
        return table;
      case 'Image':
        return image;
      default:
        return;
    }
  };
  /* eslint-enable indent */

  const code = `
Here is some YAML code:

~~~yaml
apiVersion: helm.openshift.io/v1beta1/
kind: HelmChartRepository
metadata:
  name: azure-sample-repo0oooo00ooo
spec:
  connectionConfig:
  url: https://raw.githubusercontent.com/Azure-Samples/helm-charts/master/docs
~~~

Here is some JavaScript code:

~~~js
import React from 'react';

const MessageLoading = () => (
  <div className="pf-chatbot__message-loading">
    <span className="pf-chatbot__message-loading-dots">
      <span className="pf-v6-screen-reader">Loading message</span>
    </span>
  </div>
);

export default MessageLoading;

~~~
`;

  const heading = `
# h1 Heading

## h2 Heading

### h3 Heading

#### h4 Heading

##### h5 Heading

###### h6 Heading
`;

  const emphasis = `
**Bold text, formatted with double asterisks**

__Bold text, formatted with double underscores__

*Italic text, formatted with single asterisks*

_Italic text, formatted with single underscores_

~~Strikethrough~~
`;

  const blockQuotes = `> Blockquotes can also be nested...
>> ...by using additional greater-than signs (>) right next to each other...
> > > ...or with spaces between each sign.`;

  const orderedList = `
  Here is an ordered list:

  1. Item 1
  2. Item 2
  3. Item 3`;

  const unorderedList = `
  Here is an unordered list:

  * Item 1
  * Item 2
  * Item 3`;

  const moreComplexList = `You may be wondering whether you can display more complex lists with formatting. In response to your question, I will explain how to spread butter on toast.

1. **Using a \`toaster\`:**

   - Place \`bread\` in a \`toaster\`.
   - Once \`bread\` is lightly browned, remove from \`toaster\`.

2. **Using a \`knife\`:**

     Acquire 1 tablespoon of room temperature \`butter\`. Use \`knife\` to spread butter on \`toast\`. Bon appétit!
 `;

  const link = `A paragraph with a URL: https://reactjs.org.`;

  const inlineCode = `Here is an inline code - \`() => void\``;

  const table = `To customize your table, you can use [PatternFly TableProps](/components/table#table)

 | Version | GA date | User role 
 |-|-|-|
 | 2.5 | September 30, 2024 | Administrator |
 | 2.5 | June 27, 2023 | Editor |
 | 3.0 | April 1, 2025 | Administrator
 `;

  const image = `![Multi-colored wavy lines on a black background](https://cdn.dribbble.com/userupload/10651749/file/original-8a07b8e39d9e8bf002358c66fce1223e.gif)`;

  const error = {
    title: 'Could not load chat',
    children: 'Wait a few minutes and check your network settings. If the issue persists: ',
    actionLinks: (
      <React.Fragment>
        <AlertActionLink component="a" href="#">
          Start a new chat
        </AlertActionLink>
        <AlertActionLink component="a" href="#">
          Contact support
        </AlertActionLink>
      </React.Fragment>
    )
  };

  const onSelect = (_event: React.MouseEvent<Element, MouseEvent> | undefined, value: string | number | undefined) => {
    setVariant(value);
    setSelected(value as string);
    setIsOpen(false);
  };

  const onToggleClick = () => {
    setIsOpen(!isOpen);
  };

  const toggle = (toggleRef: React.Ref<MenuToggleElement>) => (
    <MenuToggle
      className="pf-v6-u-mb-md"
      ref={toggleRef}
      onClick={onToggleClick}
      isExpanded={isOpen}
      style={
        {
          width: '200px'
        } as React.CSSProperties
      }
    >
      {selected}
    </MenuToggle>
  );

  return (
    <>
      <Message
        name="Bot"
        role="bot"
        avatar={patternflyAvatar}
        content={`This is a text-based message from a bot named "Bot."`}
      />
      <Message
        name="Bot"
        role="bot"
        avatar={patternflyAvatar}
        content={`This is a text-based message from "Bot," with an updated timestamp.`}
        timestamp="1 hour ago"
      />
      <Message name="Bot" role="bot" avatar={patternflyAvatar} content="Example content" isLoading />
      <Message role="bot" avatar={patternflyAvatar} content="This message is from a nameless bot." />
      <Message
        name="Default Openshift Container Platform Assistant That Can Help With Any Query You Might Need Help With"
        role="bot"
        avatar={patternflyAvatar}
        content="This is a message from a bot with really long name: it's truncated!"
      />
      <Message
        name="Bot"
        role="bot"
        avatar={squareImg}
        content="This bot has a square avatar. You can further customize the avatar by applying an additional class or passing [PatternFly avatar props](/components/avatar) to the `<Message>` component via `avatarProps`."
        hasRoundAvatar={false}
      />
      <Message
        name="Bot"
        role="bot"
        avatar={patternflyAvatar}
        content={`Text-based message from a bot named "Bot," with updated timestamp`}
        timestamp="1 hour ago"
      />
      <Message name="Bot" role="bot" avatar={patternflyAvatar} content="Example content" isLoading />
      <Select
        id="single-select"
        isOpen={isOpen}
        selected={selected}
        onSelect={onSelect}
        onOpenChange={(isOpen) => setIsOpen(isOpen)}
        toggle={toggle}
        shouldFocusToggleOnSelect
      >
        <SelectList>
          <SelectOption value="Code">Code</SelectOption>
          <SelectOption value="Inline code">Inline code</SelectOption>
          <SelectOption value="Heading">Heading</SelectOption>
          <SelectOption value="Block quotes">Block quotes</SelectOption>
          <SelectOption value="Emphasis">Emphasis</SelectOption>
          <SelectOption value="Link">Link</SelectOption>
          <SelectOption value="Unordered list">Unordered list</SelectOption>
          <SelectOption value="Ordered list">Ordered list</SelectOption>
          <SelectOption value="More complex list">More complex list</SelectOption>
          <SelectOption value="Table">Table</SelectOption>
          <SelectOption value="Image">Image</SelectOption>
          <SelectOption value="Error">Error</SelectOption>
        </SelectList>
      </Select>
      <Message
        name="Bot"
        role="bot"
        avatar={patternflyAvatar}
        content={renderContent()}
        tableProps={
          variant === 'Table' ? { 'aria-label': 'App information and user roles for bot messages' } : undefined
        }
        error={variant === 'Error' ? error : undefined}
      />
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/Messages/explore-pipeline-quickstart.ts
================================================
import userAvatar from './user_avatar.svg';

export const explorePipelinesQuickStart = {
  apiVersion: 'console.openshift.io/v1',
  kind: 'QuickStarts',
  metadata: {
    name: 'explore-pipelines'
  },
  spec: {
    version: 4.7,
    displayName: `Installing the Pipelines Operator`,
    durationMinutes: 10,
    icon: userAvatar,
    description: `Install the OpenShift® Pipelines Operator to build Pipelines using Tekton.`,
    prerequisites: [''],
    introduction: `OpenShift® Pipelines is a cloud-native, continuous integration and continuous delivery (CI/CD) solution based on Kubernetes resources. It uses Tekton building blocks to automate deployments across multiple Kubernetes distributions by abstracting away the underlying implementation details.
* OpenShift Pipelines is a serverless CI/CD system that runs pipelines with all the required dependencies in isolated containers.
* They are designed for decentralized teams that work on a microservice-based architecture.
* They are defined using standard Custom Resource Definitions making them extensible and easy to integrate with the existing Kubernetes tools. This enables you to scale on-demand.
* You can use OpenShift Pipelines to build images with Kubernetes tools such as Source-to-Image (S2I), Buildah, Buildpacks, and Kaniko that are portable across any Kubernetes platform.
* You can use the Developer perspective to create and manage pipelines and view logs in your namespaces.

To start using Pipelines, install the OpenShift® Pipelines Operator on your cluster.`,
    tasks: [
      {
        title: `Installing the OpenShift Pipelines Operator`,
        description: `### To install the OpenShift Pipelines Operator:

1. From the **Administrator** perspective in the console navigation panel, click **Operators > OperatorHub**.
2. In the **Filter by keyword** field, type \`OpenShift Pipelines Operator\`.
3. If the tile has an Installed label, the Operator is already installed. Proceed to the next quick start to create a Pipeline.
4. Click the **tile** to open the Operator details.
5. At the top of the OpenShift Pipelines Operator panel that opens, click **Install**.
6. Fill out the Operator subscription form by selecting the channel that matches your OpenShift cluster, and then click **Install**.
7. On the **Installed Operators** page, wait for the OpenShift Pipelines Operator's status to change from **Installing** to **Succeeded**. `,
        review: {
          instructions: `#### To verify that the OpenShift Pipelines Operator is installed:
1. From the **Operators** section of the navigation, go to the **Installed Operators** page.
2. Verify that the **OpenShift Pipelines Operator** appears in the list of Operators.

In the status column, is the status of the OpenShift Pipelines Operator **Succeeded**?`,
          failedTaskHelp: `This task isn’t verified yet. Try the task again, or [read more](https://docs.openshift.com/container-platform/4.6/pipelines/installing-pipelines.html#op-installing-pipelines-operator-in-web-console_installing-pipelines) about this topic.`
        },
        summary: {
          success: `You have installed the Pipelines Operator!`,
          failed: `Try the steps again.`
        }
      }
    ],
    conclusion: `You successfully installed the OpenShift Pipelines Operator! If you want to learn how to deploy an application and associate a Pipeline with it, take the Creating a Pipeline quick start.`,
    nextQuickStart: [`install-app-and-associate-pipeline`],
    accessReviewResources: [
      {
        group: 'operators.coreos.com',
        resource: 'operatorgroups',
        verb: 'list'
      },
      {
        group: 'packages.operators.coreos.com',
        resource: 'packagemanifests',
        verb: 'list'
      }
    ]
  }
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/Messages/FileDetails.tsx
================================================
import React from 'react';
import FileDetails from '@patternfly/chatbot/dist/dynamic/FileDetails';

export const FileDetailsExample: React.FunctionComponent = () => <FileDetails fileName="test.yml" />;



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/Messages/FileDetailsLabel.tsx
================================================
import React from 'react';
import FileDetailsLabel from '@patternfly/chatbot/dist/dynamic/FileDetailsLabel';
import { Stack, MenuToggle, MenuToggleElement, Select, SelectList, SelectOption } from '@patternfly/react-core';

export const FileDetailsLabelExample: React.FunctionComponent = () => {
  const [variant, setVariant] = React.useState<string>('plain');
  const [isOpen, setIsOpen] = React.useState<boolean>(false);
  const [selected, setSelected] = React.useState<string>('Variant');

  const onSelect = (_event: React.MouseEvent<Element, MouseEvent> | undefined, value: string | number | undefined) => {
    setVariant(value);
    setSelected(value as string);
    setIsOpen(false);
  };

  const onToggleClick = () => {
    setIsOpen(!isOpen);
  };

  const toggle = (toggleRef: React.Ref<MenuToggleElement>) => (
    <MenuToggle
      ref={toggleRef}
      onClick={onToggleClick}
      isExpanded={isOpen}
      style={
        {
          width: '200px'
        } as React.CSSProperties
      }
    >
      {selected}
    </MenuToggle>
  );

  return (
    <Stack hasGutter>
      <Select
        id="single-select"
        isOpen={isOpen}
        selected={selected}
        onSelect={onSelect}
        onOpenChange={(isOpen) => setIsOpen(isOpen)}
        toggle={toggle}
        shouldFocusToggleOnSelect
      >
        <SelectList>
          <SelectOption value="Plain">Plain</SelectOption>
          <SelectOption value="Closeable">Closeable</SelectOption>
          <SelectOption value="Clickable">Clickable</SelectOption>
          <SelectOption value="Loading">Loading</SelectOption>
        </SelectList>
      </Select>
      <div className="pf-chatbot__file-details-example">
        <FileDetailsLabel
          fileName="auth-operator.yml"
          // eslint-disable-next-line no-console
          {...(variant === 'Closeable' && { onClose: () => console.log('clicked close button!') })}
          // eslint-disable-next-line no-console
          {...(variant === 'Clickable' && { onClick: () => console.log('clicked entire button!') })}
          {...(variant === 'Loading' && { isLoading: true })}
        />
      </div>
    </Stack>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/Messages/FileDropZone.tsx
================================================
import React from 'react';
import FileDropZone from '@patternfly/chatbot/dist/dynamic/FileDropZone';
import { DropEvent } from '@patternfly/react-core';

interface readFile {
  fileName: string;
  data?: string;
  loadResult?: 'danger' | 'success';
  loadError?: DOMException;
}

export const DropzoneExample: React.FunctionComponent = () => {
  const [currentFiles, setCurrentFiles] = React.useState<File[]>([]);
  const [readFileData, setReadFileData] = React.useState<readFile[]>([]);

  // remove files from both state arrays based on their name
  const removeFiles = (namesOfFilesToRemove: string[]) => {
    const newCurrentFiles = currentFiles.filter(
      (currentFile) => !namesOfFilesToRemove.some((fileName) => fileName === currentFile.name)
    );

    setCurrentFiles(newCurrentFiles);

    const newReadFiles = readFileData.filter(
      (readFile) => !namesOfFilesToRemove.some((fileName) => fileName === readFile.fileName)
    );

    setReadFileData(newReadFiles);
  };

  // callback that will be called by the react dropzone with the newly dropped file objects
  const handleFileDrop = (_event: DropEvent, droppedFiles: File[]) => {
    // any custom validation you'd like
    if (droppedFiles.length > 1) {
      alert('Error: Dropped too many files');
      return;
    }
    if (droppedFiles[0].size > 25000000) {
      alert('Error: File size too large');
      return;
    }
    // identify what, if any, files are re-uploads of already uploaded files
    const currentFileNames = currentFiles.map((file) => file.name);
    const reUploads = droppedFiles.filter((droppedFile) => currentFileNames.includes(droppedFile.name));

    /** this promise chain is needed because if the file removal is done at the same time as the file adding react
     * won't realize that the status items for the re-uploaded files needs to be re-rendered */
    Promise.resolve()
      .then(() => removeFiles(reUploads.map((file) => file.name)))
      .then(() => alert(`Dropped ${droppedFiles.map((file) => file.name)}`));
  };

  return (
    <FileDropZone onFileDrop={handleFileDrop} displayMode="fullscreen">
      <div className="pf-chatbot__file-drop-zone-example">
        This is example content that would be shown when no dragging is happening. To see the drop zone, start to drag
        an item into this section. The static content will be replaced by an active drop zone message.
      </div>
    </FileDropZone>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/Messages/Messages.md
================================================
---
# Sidenav top-level section
# should be the same for all markdown files
section: PatternFly-AI
subsection: ChatBot
# Sidenav secondary level section
# should be the same for all markdown files
id: Messages
# Tab (react | react-demos | html | html-demos | design-guidelines | accessibility)
source: react
# If you use typescript, the name of the interface to display props for
# These are found through the sourceProps function provided in patternfly-docs.source.js
propComponents:
  [
    'AttachMenu',
    'AttachmentEdit',
    'FileDetailsProps',
    'FileDetailsLabelProps',
    'FileDropZone',
    'PreviewAttachment',
    'Message',
    'MessageExtraContent',
    'PreviewAttachment',
    'ActionProps',
    'SourcesCardProps',
    'UserFeedbackProps',
    'UserFeedbackCompleteProps',
    'QuickResponseProps'
  ]
sortValue: 3
---

import Message from '@patternfly/chatbot/dist/dynamic/Message';
import SourcesCard from '@patternfly/chatbot/dist/dynamic/SourcesCard';
import { RobotIcon } from '@patternfly/react-icons/dist/esm/icons/robot-icon';
import InfoCircleIcon from '@patternfly/react-icons/dist/esm/icons/info-circle-icon';
import DownloadIcon from '@patternfly/react-icons/dist/esm/icons/download-icon';
import RedoIcon from '@patternfly/react-icons/dist/esm/icons/redo-icon';
import patternflyAvatar from './patternfly_avatar.jpg';
import AttachmentEdit from '@patternfly/chatbot/dist/dynamic/AttachmentEdit';
import FileDetails from '@patternfly/chatbot/dist/dynamic/FileDetails';
import FileDetailsLabel from '@patternfly/chatbot/dist/dynamic/FileDetailsLabel';
import FileDropZone from '@patternfly/chatbot/dist/dynamic/FileDropZone';
import { PreviewAttachment } from '@patternfly/chatbot/dist/dynamic/PreviewAttachment';
import ChatbotAlert from '@patternfly/chatbot/dist/dynamic/ChatbotAlert';
import { explorePipelinesQuickStart } from './explore-pipeline-quickstart.ts';
import { monitorSampleAppQuickStart } from '@patternfly/chatbot/src/Message/QuickStarts/monitor-sampleapp-quickstart.ts';
import userAvatar from './user_avatar.svg';
import squareImg from './PF-social-color-square.svg';

The `content` prop of the `<Message>` component is passed to a `<Markdown>` component (from [react-markdown](https://remarkjs.github.io/react-markdown/)), which is configured to translate plain text strings into PatternFly [`<Content>` components](/components/content) and code blocks into PatternFly [`<CodeBlock>` components.](/components/code-block)

## Messages

### Bot messages

Messages from the ChatBot will be marked with an "AI" label to clearly communicate the use of AI to users. The ChatBot can display different `content` types, including plain text, code, or a loading animation (via `isLoading`).

By default, a date and timestamp is displayed with each message. We recommend using the `timestamp` prop in real ChatBots, since it will allow you to set persistent dates and times on messages, even if the messages re-render. You can update `timestamp` with a different [date and time format](/ux-writing/numerics) as needed.

You can further customize the avatar by applying an additional class or passing [PatternFly avatar props](/components/avatar) to the `<Message>` component via `avatarProps`.

```js file="./BotMessage.tsx"

```

### Message actions

You can add actions to a message, to allow users to interact with the message content. These actions can include:

- Feedback responses that allow users to rate a message as "good" or "bad".
- Copy and share controls that allow users to share the message content with others.
- A listen action, that will read the message content out loud.

**Note:** The logic for the actions is not built into the component and must be implemented by the consuming application.

```js file="./MessageWithResponseActions.tsx"

```

### Custom message actions

Beyond the standard message actions (good response, bad response, copy, share, or listen), you can add custom actions to a bot message by passing an `actions` object to the `<Message>` component. This object can contain the following customizations:

- `ariaLabel`
- `onClick`
- `className`
- `isDisabled`
- `tooltipContent`
- `tooltipContent`
- `tooltipProps`
- `icon`

You can apply a `clickedAriaLabel` and `clickedTooltipContent` once a button is clicked. If either of these props are omitted, their values will default to the `ariaLabel` or `tooltipContent` supplied.

```js file="./MessageWithCustomResponseActions.tsx"

```

### Message feedback

When a user selects a positive or negative [message action](#message-actions), you can display a message feedback card that acknowledges their response and provides space for additional written feedback. These cards can be manually dismissed via the close button and the thank-you card can be [configured to time out automatically](/patternfly-ai/chatbot/messages#message-feedback-with-timeouts).

You can see the full feedback flow [in the message demos](/patternfly-ai/chatbot/messages/demo#message-feedback).

The message feedback cards will immediately receive focus by default, but you can remove this behavior by passing `focusOnLoad: false` to the `<Message>` (as shown in the following examples). For better usability, you should generally keep the default focus behavior.

The following examples demonstrate:

- A basic feedback card. To toggle the text input area, select the **Has text area** checkbox.
- A thank-you card. To toggle the close button, select the **Has close button** checkbox.

```js file="./MessageWithFeedback.tsx"

```

### Message feedback with timeouts

The feedback thank-you message can be configured to time out and automatically close after a period of time. The default time-out period is 8000 ms, but it can be customized via `timeout`.

To display the thank-you message in this example, click **Show card**.

The card will not dismiss within the default time if a user is hovering over it or if it has keyboard focus. Instead, it will dismiss after they remove focus, via `timeoutAnimation`, which is 3000 ms by default. You can adjust this duration and set an `onTimeout` callback, as well as optional `onMouseEnter` and `onMouseLeave` callbacks.

For accessibility purposes, be sure to announce when new content appears onscreen. `isLiveRegion` is set to true by default on `<Message>` so it will make appropriate announcements for you when the thank-you card appears.

```js file="./MessageWithFeedbackTimeout.tsx"

```

### Messages with quick responses

You can offer convenient, clickable responses to messages in the form of quick actions. Quick actions are [PatternFly labels](/components/label/) in a label group, configured to display up to 5 visible labels. Only 1 response can be selected at a time.

To add quick actions, pass `quickResponses` to `<Message>`. This can be overridden by passing additional `<LabelGroup>` props to `quickResponseContainerProps`, or additional `<Label>` props to `quickResponses`.

```js file="./MessageWithQuickResponses.tsx"

```

### Messages with sources

If you are using Retrieval-Augmented Generation, you may want to display sources in a message. Passing `sources` to `<Message>` allows you to paginate between the sources you provide.

If a source will open outside of the ChatBot window, add an external link icon via `isExternal`.

The API for a source requires a link at minimum, but we strongly recommend providing a more descriptive title and body description so users have enough context. For the best clarity and readability, we strongly recommend limiting the title to 1 line and the body to 2 lines. If the body description is more than 2 lines, use the "long sources" or "very long sources" variant.

```js file="./MessageWithSources.tsx"

```

### Messages with quick start tiles

[Quick start](/extensions/quick-starts/) tiles can be added to messages via the `quickStarts` prop. Users can initiate the quick start from a link within the message tile.

The quick start tile displayed below the message is based on the tile included in the [PatternFly quick starts extension](https://github.com/patternfly/patternfly-quickstarts), but with slightly more limited functionality. For example, it does not track the state of the extension. However, it supports an additional `onSelectQuickStart` prop, so that the name of the quick start can be captured on click. This can be used to trigger other behavior in your application, such as launching that quick start in your main UI.

```js file="./MessageWithQuickStart.tsx"

```

### User messages

Messages from users have a different background color to differentiate them from bot messages. You can also display a custom avatar that is uploaded by the user. You can further customize the avatar by applying an additional class or passing [PatternFly avatar props](/components/avatar) to the `<Message>` component via `avatarProps`.

```js file="./UserMessage.tsx"

```

### Custom message content

**Caution:** Take care when using this feature. It can cause you to stray from accessibility and design best practice standards. If you frequently need add the same component via custom message content, reach out to the PatternFly team. If there's a consistent need for a certain component, we can look into adding native support for additional features.

You can add custom content to specific parts of a `<Message>` via the `extraContent` prop, including additional components (like timestamps, badges, or custom elements). This prop allows you to create dynamic and reusable elements for various use cases, without changing the default message layout.

```js file="./UserMessageWithExtraContent.tsx"

```

## File attachments

### Messages with attachments

When [attachments](/patternfly-ai/chatbot/messages#file-attachments) are shared and displayed in the ChatBot window, users will see a selectable and dismissible message that contains file details in a label. Selecting the file label can open a preview modal, which allows users to view or make edits to the file contents.

The `<PreviewAttachment>` component displays a modal with a read-only view of the attached file's contents. Selecting the "edit" button will open the `<AttachmentEdit>` component, which provides an interactive environment where users can make changes to the file.

If a `displayMode` is not passed to `<PreviewAttachment>` or `<AttachmentEdit>`, they both default to overlaying the default `displayMode` of the `<Chatbot>` component.

**Note:** This example does not actually apply any edits to the attached file. That logic depends on the implementation.

```js file="./MessageWithAttachment.tsx"

```

We are using [react-dropzone](https://react-dropzone.js.org) for opening the file dialog and handling drag and drop. It does not process files or provide any way to make HTTP requests to a server. If you need this, [react-dropzone](https://react-dropzone.js.org) suggests [filepond](https://pqina.nl/filepond/) or [uppy.io.](https://uppy.io/). To handle edge cases, like restricting the number or size of files, you can pass a function to the `handleAttach` prop on `MessageBar` or `onFileDrop` prop in `FileDropZone.`

### Attachment label

When an attachment is successfully uploaded, a label will appear in the message box. There are several label variants that cover different attachment states, including:

- **Plain:** Default attachment labels, which display the filename and extension.
- **Closeable:** Attachments that can be dismissed.
- **Clickable:** Attachments that can be selected, typically to open file details.
- **Loading:** Attachments that are still being uploaded.

```js file="./FileDetailsLabel.tsx"

```

### Attachment preview

To allow users to preview the contents of an attachment, load a read-only view of the file contents in a new modal.

```js file="./PreviewAttachment.tsx"

```

### Editable attachments

To allow users to edit an attached file, load a new code editor within the ChatBot window. On this screen, you can allow users to edit a file and save changes if they'd like. Return users to the main ChatBot window once they dismiss the editor.

```js file="./AttachmentEdit.tsx"

```

### Failed attachment error

When an attachment upload fails, a [danger alert](/components/alert) is displayed to provide details about the reason for failure.

```js file="./AttachmentError.tsx"

```

### Attachment dropzone

An attachment dropzone allows users to upload files via drag and drop.

```js file="./FileDropZone.tsx"

```



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/Messages/MessageWithAttachment.tsx
================================================
import React from 'react';

import Message from '@patternfly/chatbot/dist/dynamic/Message';
import PreviewAttachment from '@patternfly/chatbot/dist/dynamic/PreviewAttachment';
import AttachmentEdit from '@patternfly/chatbot/dist/dynamic/AttachmentEdit';
import userAvatar from './user_avatar.svg';

interface ModalData {
  code: string;
  fileName: string;
}

export const AttachmentMenuExample: React.FunctionComponent = () => {
  const [isPreviewModalOpen, setIsPreviewModalOpen] = React.useState<boolean>(false);
  const [isEditModalOpen, setIsEditModalOpen] = React.useState<boolean>(false);
  const [currentModalData, setCurrentModalData] = React.useState<ModalData>();

  const onClick = (event: React.MouseEvent, name: string) => {
    setCurrentModalData({ fileName: name, code: 'test' });
    setIsEditModalOpen(false);
    setIsPreviewModalOpen(true);
  };

  const onClose = (event: React.MouseEvent, name: string, id: number | string | undefined) => {
    // eslint-disable-next-line no-console
    console.log(`Closed attachment with name: ${name} and id: ${id}`);
  };

  return (
    <>
      <Message
        name="User"
        role="user"
        avatar={userAvatar}
        content="Here is an uploaded file:"
        attachments={[{ name: 'auth-operator.yml', id: '1', onClick, onClose }]}
      />
      <Message
        name="User"
        role="user"
        avatar={userAvatar}
        content="Here are 2 uploaded files:"
        attachments={[
          { name: 'auth-operator.yml', id: '1' },
          { name: 'patternfly.svg', id: '2' }
        ]}
      />
      {currentModalData && (
        <PreviewAttachment
          code={currentModalData?.code}
          fileName={currentModalData?.fileName}
          isModalOpen={isPreviewModalOpen}
          onEdit={() => {
            setIsPreviewModalOpen(false);
            setIsEditModalOpen(true);
          }}
          onDismiss={() => setCurrentModalData(undefined)}
          handleModalToggle={() => setIsPreviewModalOpen(false)}
        />
      )}
      {currentModalData && (
        <AttachmentEdit
          code={currentModalData?.code}
          fileName={currentModalData?.fileName}
          isModalOpen={isEditModalOpen}
          onSave={() => {
            setIsEditModalOpen(false);
          }}
          onCancel={() => setCurrentModalData(undefined)}
          handleModalToggle={() => setIsEditModalOpen(false)}
        />
      )}
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/Messages/MessageWithCustomResponseActions.tsx
================================================
import React from 'react';

import Message from '@patternfly/chatbot/dist/dynamic/Message';
import patternflyAvatar from './patternfly_avatar.jpg';
import InfoCircleIcon from '@patternfly/react-icons/dist/esm/icons/info-circle-icon';
import DownloadIcon from '@patternfly/react-icons/dist/esm/icons/download-icon';
import RedoIcon from '@patternfly/react-icons/dist/esm/icons/redo-icon';

export const CustomActionExample: React.FunctionComponent = () => (
  <Message
    name="Bot"
    role="bot"
    avatar={patternflyAvatar}
    content="I updated your account with those settings. You're ready to set up your first dashboard!"
    actions={{
      regenerate: {
        ariaLabel: 'Regenerate',
        clickedAriaLabel: 'Regenerated',
        // eslint-disable-next-line no-console
        onClick: () => console.log('Clicked regenerate'),
        tooltipContent: 'Regenerate',
        clickedTooltipContent: 'Regenerated',
        icon: <RedoIcon />
      },
      download: {
        ariaLabel: 'Download',
        clickedAriaLabel: 'Downloaded',
        // eslint-disable-next-line no-console
        onClick: () => console.log('Clicked download'),
        tooltipContent: 'Download',
        clickedTooltipContent: 'Downloaded',
        icon: <DownloadIcon />
      },
      info: {
        ariaLabel: 'Info',
        // eslint-disable-next-line no-console
        onClick: () => console.log('Clicked info'),
        tooltipContent: 'Info',
        icon: <InfoCircleIcon />
      }
    }}
  />
);



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/Messages/MessageWithFeedback.tsx
================================================
import React from 'react';
import Message from '@patternfly/chatbot/dist/dynamic/Message';
import patternflyAvatar from './patternfly_avatar.jpg';
import { Checkbox, FormGroup, Stack } from '@patternfly/react-core';

export const MessageWithFeedbackExample: React.FunctionComponent = () => {
  const [hasCloseButton, setHasCloseButton] = React.useState(false);
  const [hasTextArea, setHasTextArea] = React.useState(false);

  return (
    <>
      <Stack hasGutter>
        <FormGroup role="radiogroup" isInline fieldId="feedback-card" label="Variant">
          <Checkbox
            isChecked={hasTextArea}
            onChange={() => {
              setHasTextArea(!hasTextArea);
            }}
            name="basic-inline-radio"
            label="Has text area"
            id="has-text-area"
          />
        </FormGroup>
        <Message
          name="Bot"
          role="bot"
          avatar={patternflyAvatar}
          content="This is a message with the feedback card:"
          userFeedbackForm={{
            quickResponses: [
              { id: '1', content: 'Helpful information' },
              { id: '2', content: 'Easy to understand' },
              { id: '3', content: 'Resolved my issue' }
            ],
            onSubmit: (quickResponse, additionalFeedback) =>
              alert(`Selected ${quickResponse} and received the additional feedback: ${additionalFeedback}`),
            hasTextArea,
            // eslint-disable-next-line no-console
            onClose: () => console.log('closed feedback form'),
            focusOnLoad: false
          }}
        />
        <Message
          name="Bot"
          role="bot"
          avatar={patternflyAvatar}
          content="This is a compact message with the feedback card:"
          userFeedbackForm={{
            quickResponses: [
              { id: '1', content: 'Helpful information' },
              { id: '2', content: 'Easy to understand' },
              { id: '3', content: 'Resolved my issue' }
            ],
            onSubmit: (quickResponse, additionalFeedback) =>
              alert(`Selected ${quickResponse} and received the additional feedback: ${additionalFeedback}`),
            hasTextArea,
            // eslint-disable-next-line no-console
            onClose: () => console.log('closed feedback form'),
            focusOnLoad: false
          }}
          isCompact
        />
      </Stack>
      <Stack hasGutter>
        <FormGroup role="radiogroup" isInline fieldId="feedback-thank-you" label="Variant">
          <Checkbox
            isChecked={hasCloseButton}
            onChange={() => {
              setHasCloseButton(!hasCloseButton);
            }}
            name="basic-inline-radio"
            label="Has close button"
            id="has-close"
          />
        </FormGroup>
        <Message
          name="Bot"
          role="bot"
          avatar={patternflyAvatar}
          content="This is a thank-you message, which is displayed once the feedback card is submitted:"
          // eslint-disable-next-line no-console
          userFeedbackComplete={{
            // eslint-disable-next-line no-console
            onClose: hasCloseButton ? () => console.log('closed completion message') : undefined,
            focusOnLoad: false
          }}
        />
        <Message
          name="Bot"
          role="bot"
          avatar={patternflyAvatar}
          content="This is a compact thank-you message, which is displayed once the feedback card is submitted:"
          // eslint-disable-next-line no-console
          userFeedbackComplete={{
            // eslint-disable-next-line no-console
            onClose: hasCloseButton ? () => console.log('closed completion message') : undefined,
            focusOnLoad: false
          }}
          isCompact
        />
      </Stack>
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/Messages/MessageWithFeedbackTimeout.tsx
================================================
import React from 'react';
import Message from '@patternfly/chatbot/dist/dynamic/Message';
import patternflyAvatar from './patternfly_avatar.jpg';
import { Button } from '@patternfly/react-core';

export const MessageWithFeedbackTimeoutExample: React.FunctionComponent = () => {
  const [hasFeedback, setHasFeedback] = React.useState(false);

  return (
    <>
      <Button variant="secondary" onClick={() => setHasFeedback(true)}>
        Show card
      </Button>
      <Button variant="secondary" onClick={() => setHasFeedback(false)}>
        Remove card
      </Button>
      <Message
        name="Bot"
        role="bot"
        avatar={patternflyAvatar}
        content="This completion message times out after you click **Show card**:"
        userFeedbackComplete={hasFeedback ? { timeout: true, onTimeout: () => setHasFeedback(false) } : undefined}
        isLiveRegion
      />
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/Messages/MessageWithQuickResponses.tsx
================================================
import React from 'react';
import Message from '@patternfly/chatbot/dist/dynamic/Message';
import patternflyAvatar from './patternfly_avatar.jpg';

export const MessageWithQuickResponsesExample: React.FunctionComponent = () => (
  <>
    <Message
      name="Bot"
      role="bot"
      avatar={patternflyAvatar}
      content="Did you clear your cache?"
      quickResponses={[
        { id: '1', content: 'Yes', onClick: () => alert('Clicked yes') },
        { id: '2', content: 'No', onClick: () => alert('Clicked no') }
      ]}
    />
    <Message
      name="Bot"
      role="bot"
      avatar={patternflyAvatar}
      content="What browser are you noticing the issue in?"
      quickResponses={[
        { id: '1', content: 'Microsoft Edge', onClick: () => alert('Clicked Edge') },
        { id: '2', content: 'Google Chrome', onClick: () => alert('Clicked Chrome') },
        { id: '3', content: 'Mozilla Firefox', onClick: () => alert('Clicked Firefox') },
        { id: '4', content: 'Apple Safari', onClick: () => alert('Clicked Safari') },
        { id: '5', content: 'Internet Explorer', onClick: () => alert('Clicked Internet Explorer') }
      ]}
    />
    <Message
      name="Bot"
      role="bot"
      avatar={patternflyAvatar}
      content="Welcome back, User! How can I help you today?"
      quickResponses={[
        { id: '1', content: 'Help me with an access issue', onClick: () => alert('Clicked id 1') },
        { id: '2', content: 'Show my critical vulnerabilities', onClick: () => alert('Clicked id 2') },
        { id: '3', content: 'Create new integrations', onClick: () => alert('Clicked id 3') },
        { id: '4', content: 'Get recommendations from an advisor', onClick: () => alert('Clicked id 4') },
        { id: '5', content: 'Something else', onClick: () => alert('Clicked id 5') }
      ]}
    />
    <Message
      name="Bot"
      role="bot"
      avatar={patternflyAvatar}
      content="Did you clear your cache?"
      quickResponses={[
        { id: '1', content: 'Yes', isDisabled: true },
        { id: '2', content: 'No', onClick: () => alert('Clicked no') }
      ]}
    />
    <Message
      name="Bot"
      role="bot"
      avatar={patternflyAvatar}
      content="Welcome back, User! How can I help you today?"
      quickResponses={[
        { id: '1', content: 'Help me with an access issue', onClick: () => alert('Clicked id 1') },
        { id: '2', content: 'Show my critical vulnerabilities', onClick: () => alert('Clicked id 2') },
        { id: '3', content: 'Create new integrations', onClick: () => alert('Clicked id 3') },
        { id: '4', content: 'Get recommendations from an advisor', onClick: () => alert('Clicked id 4') },
        { id: '5', content: 'Something else', onClick: () => alert('Clicked id 5') }
      ]}
    />
    <Message
      name="Bot"
      role="bot"
      avatar={patternflyAvatar}
      content="Example with compact responses"
      quickResponses={[
        { id: '1', content: 'Yes', onClick: () => alert('Clicked id 1') },
        { id: '2', content: 'No', onClick: () => alert('Clicked id 2') }
      ]}
      isCompact
    />
  </>
);



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/Messages/MessageWithQuickStart.tsx
================================================
import React from 'react';
import Message from '@patternfly/chatbot/dist/dynamic/Message';
import patternflyAvatar from './patternfly_avatar.jpg';
import { explorePipelinesQuickStart } from './explore-pipeline-quickstart.ts';
import { monitorSampleAppQuickStart } from '@patternfly/chatbot/src/Message/QuickStarts/monitor-sampleapp-quickstart.ts';
import { QuickStart } from '@patternfly/chatbot/dist/esm/Message/QuickStarts/types';

export const MessageWithQuickStartExample: React.FunctionComponent = () => (
  <>
    <Message
      name="Bot"
      role="bot"
      avatar={patternflyAvatar}
      content="Follow this quick guide to install the Pipelines Operator."
      quickStarts={{
        quickStart: explorePipelinesQuickStart as QuickStart,
        onSelectQuickStart: (id) => alert(id)
      }}
    />
    <Message
      name="Bot"
      role="bot"
      avatar={patternflyAvatar}
      content="This quick start tile includes prerequisites and a default icon."
      quickStarts={{
        quickStart: monitorSampleAppQuickStart,
        onSelectQuickStart: (id) => alert(id)
      }}
    />
    <Message
      name="Bot"
      role="bot"
      avatar={patternflyAvatar}
      content="This quick start tile is compact"
      quickStarts={{
        quickStart: monitorSampleAppQuickStart,
        onSelectQuickStart: (id) => alert(id)
      }}
      isCompact
    />
  </>
);



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/Messages/MessageWithResponseActions.tsx
================================================
import React from 'react';

import Message from '@patternfly/chatbot/dist/dynamic/Message';
import patternflyAvatar from './patternfly_avatar.jpg';

export const ResponseActionExample: React.FunctionComponent = () => (
  <Message
    name="Bot"
    role="bot"
    avatar={patternflyAvatar}
    content="I updated your account with those settings. You're ready to set up your first dashboard!"
    actions={{
      // eslint-disable-next-line no-console
      positive: { onClick: () => console.log('Good response') },
      // eslint-disable-next-line no-console
      negative: { onClick: () => console.log('Bad response') },
      // eslint-disable-next-line no-console
      copy: { onClick: () => console.log('Copy') },
      // eslint-disable-next-line no-console
      share: { onClick: () => console.log('Share') },
      // eslint-disable-next-line no-console
      listen: { onClick: () => console.log('Listen') }
    }}
  />
);



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/Messages/MessageWithSources.tsx
================================================
import React from 'react';
import Message from '@patternfly/chatbot/dist/dynamic/Message';
import patternflyAvatar from './patternfly_avatar.jpg';

export const MessageWithSourcesExample: React.FunctionComponent = () => {
  const onSetPage = (_event: React.MouseEvent | React.KeyboardEvent | MouseEvent, newPage: number) => {
    // eslint-disable-next-line no-console
    console.log(`Page changed to ${newPage}`);
  };

  return (
    <>
      <Message
        name="Bot"
        role="bot"
        avatar={patternflyAvatar}
        content="This example has a body description that's within the recommended limit of 2 lines:"
        sources={{
          sources: [
            {
              title: 'Getting started with Red Hat OpenShift',
              link: '#',
              body: 'Red Hat OpenShift on IBM Cloud is a managed offering to create your own cluster of compute hosts where you can deploy and manage containerized apps on IBM Cloud ...',
              isExternal: true
            },
            {
              title: 'Azure Red Hat OpenShift documentation',
              link: '#',
              body: 'Microsoft Azure Red Hat OpenShift allows you to deploy a production ready Red Hat OpenShift cluster in Azure ...',
              isExternal: true
            },
            {
              title: 'OKD Documentation: Home',
              link: '#',
              body: 'OKD is a distribution of Kubernetes optimized for continuous application development and multi-tenant deployment. OKD also serves as the upstream code base upon ...',
              isExternal: true
            }
          ],
          onSetPage
        }}
      />
      <Message
        name="Bot"
        role="bot"
        avatar={patternflyAvatar}
        content="This example has a body description that's longer than the recommended limit of 2 lines, with a link to load the rest of the description:"
        sources={{
          sources: [
            {
              title: 'Getting started with Red Hat OpenShift',
              link: '#',
              body: 'Red Hat OpenShift on IBM Cloud is a managed offering to create your own cluster of compute hosts where you can deploy and manage containerized apps on IBM Cloud.',
              hasShowMore: true
            },
            {
              title: 'Azure Red Hat OpenShift documentation',
              link: '#',
              body: 'Microsoft Azure Red Hat OpenShift allows you to deploy a production ready Red Hat OpenShift cluster in Azure.',
              hasShowMore: true
            },
            {
              title: 'OKD Documentation: Home',
              link: '#',
              body: 'OKD is a distribution of Kubernetes optimized for continuous application development and multi-tenant deployment. OKD also serves as the upstream code base upon.',
              hasShowMore: true
            }
          ],
          onSetPage
        }}
      />
      <Message
        name="Bot"
        role="bot"
        avatar={patternflyAvatar}
        content="This example has a truncated title:"
        sources={{
          sources: [
            {
              title: 'Getting started with Red Hat OpenShift AI and other products',
              link: '#',
              body: 'Red Hat OpenShift on IBM Cloud is a managed offering to create your own cluster of compute hosts where you can deploy and manage containerized apps on IBM Cloud ...',
              isExternal: true
            },
            {
              title: 'Azure Red Hat OpenShift documentation | Red Hat',
              link: '#',
              body: 'Microsoft Azure Red Hat OpenShift allows you to deploy a production ready Red Hat OpenShift cluster in Azure ...',
              isExternal: true
            }
          ],
          onSetPage
        }}
      />
      <Message
        name="Bot"
        role="bot"
        avatar={patternflyAvatar}
        content="This example only includes 1 source:"
        sources={{
          sources: [
            {
              title: 'Getting started with Red Hat OpenShift',
              link: '#',
              body: 'Red Hat OpenShift on IBM Cloud is a managed offering to create your own cluster of compute hosts where you can deploy and manage containerized apps on IBM Cloud ...',
              isExternal: true
            }
          ],
          onSetPage
        }}
      />
      <Message
        name="Bot"
        role="bot"
        avatar={patternflyAvatar}
        content="This example has a title and no body description:"
        sources={{
          sources: [
            { title: 'Getting started with Red Hat OpenShift', link: '#', isExternal: true },
            {
              title: 'Azure Red Hat OpenShift documentation',
              link: '#',
              isExternal: true
            },
            {
              title: 'OKD Documentation: Home',
              link: '#',
              isExternal: true
            }
          ],
          onSetPage
        }}
      />
      <Message
        name="Bot"
        role="bot"
        avatar={patternflyAvatar}
        content="This example displays the source as a link, without a title (not recommended)"
        sources={{
          sources: [
            {
              link: '#'
            },
            {
              link: '#'
            },
            {
              link: '#'
            }
          ],
          onSetPage
        }}
      />
      <Message
        name="Bot"
        role="bot"
        avatar={patternflyAvatar}
        content="This example displays a compact sources card"
        sources={{
          sources: [
            {
              link: '#'
            },
            {
              link: '#'
            },
            {
              link: '#'
            }
          ],
          onSetPage
        }}
        isCompact
      />
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/Messages/PreviewAttachment.tsx
================================================
import React from 'react';
import { Button, Checkbox } from '@patternfly/react-core';
import { PreviewAttachment } from '@patternfly/chatbot/dist/dynamic/PreviewAttachment';

export const PreviewAttachmentExample: React.FunctionComponent = () => {
  const [isModalOpen, setIsModalOpen] = React.useState(false);
  const [isCompact, setIsCompact] = React.useState(false);

  const handleModalToggle = (_event: React.MouseEvent | MouseEvent | KeyboardEvent) => {
    setIsModalOpen(!isModalOpen);
  };

  return (
    <>
      <Checkbox
        label="Show compact version"
        isChecked={isCompact}
        onChange={() => setIsCompact(!isCompact)}
        id="modal-compact-preview"
        name="modal-compact-preview"
      ></Checkbox>
      <Button onClick={handleModalToggle}>Launch modal</Button>
      <PreviewAttachment
        code="I am a code snippet"
        fileName="test.yaml"
        handleModalToggle={handleModalToggle}
        isModalOpen={isModalOpen}
        onDismiss={() => null}
        onEdit={() => null}
        isCompact={isCompact}
      />
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/Messages/UserMessage.tsx
================================================
import React from 'react';

import Message from '@patternfly/chatbot/dist/dynamic/Message';
import userAvatar from './user_avatar.svg';
import {
  AlertActionLink,
  MenuToggle,
  MenuToggleElement,
  Select,
  SelectList,
  SelectOption
} from '@patternfly/react-core';

export const UserMessageExample: React.FunctionComponent = () => {
  const [variant, setVariant] = React.useState<string>('Code');
  const [isEditable, setIsEditable] = React.useState<boolean>(true);
  const [isOpen, setIsOpen] = React.useState<boolean>(false);
  const [selected, setSelected] = React.useState<string>('Message content type');

  /* eslint-disable indent */
  const renderContent = () => {
    switch (variant) {
      case 'Code':
        return code;
      case 'Inline code':
        return inlineCode;
      case 'Heading':
        return heading;
      case 'Emphasis':
        return emphasis;
      case 'Block quotes':
        return blockQuotes;
      case 'Ordered list':
        return orderedList;
      case 'Unordered list':
        return unorderedList;
      case 'More complex list':
        return moreComplexList;
      case 'Link':
        return link;
      case 'Table':
        return table;
      case 'Image':
        return image;
      default:
        return '';
    }
  };
  /* eslint-enable indent */

  const code = `
Here is some YAML code:

~~~yaml
apiVersion: helm.openshift.io/v1beta1/
kind: HelmChartRepository
metadata:
  name: azure-sample-repo0oooo00ooo
spec:
  connectionConfig:
  url: https://raw.githubusercontent.com/Azure-Samples/helm-charts/master/docs
~~~

Here is some JavaScript code:

~~~js
import React from 'react';

const MessageLoading = () => (
  <div className="pf-chatbot__message-loading">
    <span className="pf-chatbot__message-loading-dots">
      <span className="pf-v6-screen-reader">Loading message</span>
    </span>
  </div>
);

export default MessageLoading;

~~~
`;

  const heading = `
# h1 Heading

## h2 Heading

### h3 Heading

#### h4 Heading

##### h5 Heading

###### h6 Heading
`;

  const emphasis = `
**Bold text, formatted with double asterisks**

__Bold text, formatted with double underscores__

*Italic text, formatted with single asterisks*

_Italic text, formatted with single underscores_

~~Strikethrough~~
`;

  const blockQuotes = `> Blockquotes can also be nested...
>> ...by using additional greater-than signs (>) right next to each other...
> > > ...or with spaces between each sign.`;

  const orderedList = `
  Here is an ordered list:

  1. Item 1
  2. Item 2
  3. Item 3`;

  const unorderedList = `
  Here is an unordered list:

  * Item 1
  * Item 2
  * Item 3`;

  const moreComplexList = `You may be wondering whether you can display more complex lists with formatting. In response to your question, I will explain how to spread butter on toast.

1. **Using a \`toaster\`:**

  - Place \`bread\` in a \`toaster\`
  - Once \`bread\` is lightly browned, remove from \`toaster\`

2. **Using a \`knife\`:**

  Acquire 1 tablespoon of room temperature \`butter\`. Use \`knife\` to spread butter on \`toast\`. Bon appétit!
`;

  const link = `A paragraph with a URL: https://reactjs.org.`;

  const inlineCode = `Here is an inline code - \`() => void\``;

  const table = `To customize your table, you can use [PatternFly TableProps](/components/table#table)

 | Version | GA date | User role 
 |-|-|-|
 | 2.5 | September 30, 2024 | Administrator |
 | 2.5 | June 27, 2023 | Editor |
 | 3.0 | April 1, 2025 | Administrator
 `;

  const image = `![Multi-colored wavy lines on a black background](https://cdn.dribbble.com/userupload/10651749/file/original-8a07b8e39d9e8bf002358c66fce1223e.gif)`;

  const error = {
    title: 'Could not load chat',
    children: 'Wait a few minutes and check your network settings. If the issue persists: ',
    actionLinks: (
      <React.Fragment>
        <AlertActionLink component="a" href="#">
          Start a new chat
        </AlertActionLink>
        <AlertActionLink component="a" href="#">
          Contact support
        </AlertActionLink>
      </React.Fragment>
    )
  };

  const onSelect = (_event: React.MouseEvent<Element, MouseEvent> | undefined, value: string | number | undefined) => {
    setVariant(value);
    setSelected(value as string);
    setIsOpen(false);
  };

  const onToggleClick = () => {
    setIsOpen(!isOpen);
  };

  const toggle = (toggleRef: React.Ref<MenuToggleElement>) => (
    <MenuToggle
      className="pf-v6-u-mb-md"
      ref={toggleRef}
      onClick={onToggleClick}
      isExpanded={isOpen}
      style={
        {
          width: '200px'
        } as React.CSSProperties
      }
    >
      {selected}
    </MenuToggle>
  );

  return (
    <>
      <Message
        name="User"
        role="user"
        content="This is a user message with an updated timestamp."
        timestamp="1 hour ago"
        avatar={userAvatar}
      />
      <Message
        name="User"
        role="user"
        content="This is a user message with `avatarProps` set to add a border."
        avatar={userAvatar}
        avatarProps={{ isBordered: true }}
      />
      <Select
        id="single-select"
        isOpen={isOpen}
        selected={selected}
        onSelect={onSelect}
        onOpenChange={(isOpen) => setIsOpen(isOpen)}
        toggle={toggle}
        shouldFocusToggleOnSelect
      >
        <SelectList>
          <SelectOption value="Code">Code</SelectOption>
          <SelectOption value="Inline code">Inline code</SelectOption>
          <SelectOption value="Heading">Heading</SelectOption>
          <SelectOption value="Block quotes">Block quotes</SelectOption>
          <SelectOption value="Emphasis">Emphasis</SelectOption>
          <SelectOption value="Link">Link</SelectOption>
          <SelectOption value="Unordered list">Unordered list</SelectOption>
          <SelectOption value="Ordered list">Ordered list</SelectOption>
          <SelectOption value="More complex list">More complex list</SelectOption>
          <SelectOption value="Table">Table</SelectOption>
          <SelectOption value="Image">Image</SelectOption>
          <SelectOption value="Error">Error</SelectOption>
          <SelectOption value="Editable">Editable</SelectOption>
        </SelectList>
      </Select>
      <Message
        name="User"
        role="user"
        content={renderContent()}
        avatar={userAvatar}
        tableProps={
          variant === 'Table' ? { 'aria-label': 'App information and user roles for user messages' } : undefined
        }
        isEditable={variant === 'Editable' ? isEditable : false}
        error={variant === 'Error' ? error : undefined}
        onEditUpdate={() => setIsEditable(false)}
        onEditCancel={() => setIsEditable(false)}
      />
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/Messages/UserMessageWithExtraContent.tsx
================================================
import React from 'react';

import Message from '@patternfly/chatbot/dist/dynamic/Message';
import userAvatar from './user_avatar.svg';
import { Alert, Badge, Button, Card, CardBody, CardFooter, CardTitle } from '@patternfly/react-core';

const UserActionEndContent = () => {
  // eslint-disable-next-line no-console
  const onClick = () => console.log('custom button click');
  return (
    <React.Fragment>
      <Button variant="secondary" ouiaId="Secondary" onClick={onClick}>
        End content button
      </Button>
      <Alert variant="danger" title="Danger alert title" ouiaId="DangerAlert" />
    </React.Fragment>
  );
};

const CardInformationAfterMainContent = () => (
  <Card ouiaId="BasicCard">
    <CardTitle>This is content card after main content</CardTitle>
    <CardBody>Body</CardBody>
    <CardFooter>Footer</CardFooter>
  </Card>
);

const BeforeMainContent = () => (
  <div>
    <Badge key={1} isRead>
      7
    </Badge>
    <Badge key={2} isRead>
      24
    </Badge>
  </div>
);

export const UserMessageWithExtraContent: React.FunctionComponent = () => (
  <>
    <Message
      avatar={userAvatar}
      name="User"
      role="user"
      content="This is a main message."
      timestamp="1 hour ago"
      extraContent={{
        beforeMainContent: <BeforeMainContent />,
        afterMainContent: <CardInformationAfterMainContent />,
        endContent: <UserActionEndContent />
      }}
    />
  </>
);



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/ChatbotContainer.tsx
================================================
import React from 'react';
import Chatbot, { ChatbotDisplayMode } from '@patternfly/chatbot/dist/dynamic/Chatbot';
import { Checkbox } from '@patternfly/react-core/dist/dynamic/Checkbox';
import { Stack } from '@patternfly/react-core/dist/dynamic/Stack';
import { MenuToggle, MenuToggleElement, Select, SelectList, SelectOption } from '@patternfly/react-core';

export const ChatbotContainerDemo: React.FunctionComponent = () => {
  const [displayMode, setDisplayMode] = React.useState(ChatbotDisplayMode.default);
  const [isVisible, setIsVisible] = React.useState(true);
  const [isOpen, setIsOpen] = React.useState(false);
  const [selected, setSelected] = React.useState<string>('Select display mode');

  const onSelect = (_event: React.MouseEvent<Element, MouseEvent> | undefined, value: string | number | undefined) => {
    setSelected(value as string);
    setIsOpen(false);
    if (value === 'Overlay / default') {
      setDisplayMode(ChatbotDisplayMode.default);
    }
    if (value === 'Docked') {
      setDisplayMode(ChatbotDisplayMode.docked);
    }
    if (value === 'Fullscreen') {
      setDisplayMode(ChatbotDisplayMode.fullscreen);
    }
    if (value === 'Embedded') {
      setDisplayMode(ChatbotDisplayMode.embedded);
    }
  };

  const onToggleClick = () => {
    setIsOpen(!isOpen);
  };

  const toggle = (toggleRef: React.Ref<MenuToggleElement>) => (
    <MenuToggle
      ref={toggleRef}
      onClick={onToggleClick}
      isExpanded={isOpen}
      style={
        {
          width: '200px'
        } as React.CSSProperties
      }
    >
      {selected}
    </MenuToggle>
  );

  return (
    <>
      <div
        style={{
          position: 'fixed',
          padding: 'var(--pf-t--global--spacer--lg)',
          zIndex: '601',
          boxShadow: 'var(--pf-t--global--box-shadow--lg)'
        }}
      >
        <Stack hasGutter>
          <Select
            id="single-select"
            isOpen={isOpen}
            selected={selected}
            onSelect={onSelect}
            onOpenChange={(isOpen) => setIsOpen(isOpen)}
            toggle={toggle}
            shouldFocusToggleOnSelect
          >
            <SelectList>
              <SelectOption value="Overlay / default">Overlay / default</SelectOption>
              <SelectOption value="Docked">Docked</SelectOption>
              <SelectOption value="Fullscreen">Fullscreen</SelectOption>
              <SelectOption value="Embedded">Embedded</SelectOption>
            </SelectList>
          </Select>
          <Checkbox
            label="Display chatbot container"
            isChecked={isVisible}
            onChange={() => setIsVisible(!isVisible)}
            id="container-visible"
            name="container-visible"
          />
        </Stack>
      </div>
      <Chatbot displayMode={displayMode} isVisible={isVisible}></Chatbot>
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/ChatbotFooter.tsx
================================================
import React from 'react';
import { ChatbotFooter, ChatbotFootnote } from '@patternfly/chatbot/dist/dynamic/ChatbotFooter';
import { MessageBar } from '@patternfly/chatbot/dist/dynamic/MessageBar';

export const ChatbotFooterExample: React.FunctionComponent = () => {
  const handleSend = (message) => alert(message);

  return (
    <ChatbotFooter>
      <MessageBar onSendMessage={handleSend} hasMicrophoneButton hasAttachButton />
      <ChatbotFootnote label="ChatBot uses AI. Check for mistakes." />
    </ChatbotFooter>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/ChatbotFootnote.tsx
================================================
import React from 'react';
import { ChatbotFootnote } from '@patternfly/chatbot/dist/dynamic/ChatbotFooter';

export const FootnoteDemo: React.FunctionComponent = () => (
  <ChatbotFootnote
    label="ChatBot uses AI. Check for mistakes."
    popover={{
      title: 'Verify information',
      description: `While ChatBot strives for accuracy, AI is experimental and can make mistakes. We cannot guarantee that all information provided by ChatBot is up to date or without error. You should always verify responses using reliable sources, especially for crucial information and decision making.`,
      bannerImage: {
        src: 'https://cdn.dribbble.com/userupload/10651749/file/original-8a07b8e39d9e8bf002358c66fce1223e.gif',
        alt: 'Example image for footnote popover'
      },
      cta: {
        label: 'Dismiss',
        onClick: () => {
          alert('Do something!');
        }
      },
      link: {
        label: 'View AI policy',
        url: 'https://www.redhat.com/'
      }
    }}
  />
);



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/ChatbotHeaderBasic.tsx
================================================
import React from 'react';
import {
  Brand,
  Bullseye,
  Checkbox,
  DropdownGroup,
  DropdownItem,
  DropdownList,
  FormGroup,
  Stack,
  Title
} from '@patternfly/react-core';
import {
  ChatbotHeader,
  ChatbotHeaderMain,
  ChatbotHeaderMenu,
  ChatbotHeaderActions,
  ChatbotHeaderTitle,
  ChatbotHeaderOptionsDropdown,
  ChatbotHeaderSelectorDropdown
} from '@patternfly/chatbot/dist/dynamic/ChatbotHeader';
import { ChatbotDisplayMode } from '@patternfly/chatbot/dist/dynamic/Chatbot';
import OutlinedWindowRestoreIcon from '@patternfly/react-icons/dist/esm/icons/outlined-window-restore-icon';
import ExpandIcon from '@patternfly/react-icons/dist/esm/icons/expand-icon';
import OpenDrawerRightIcon from '@patternfly/react-icons/dist/esm/icons/open-drawer-right-icon';

import PFHorizontalLogoColor from './PF-HorizontalLogo-Color.svg';
import PFHorizontalLogoReverse from './PF-HorizontalLogo-Reverse.svg';

export const BasicDemo: React.FunctionComponent = () => {
  const [selectedModel, setSelectedModel] = React.useState('Granite Code 7B');
  const [showAll, setShowAll] = React.useState<boolean>(true);
  const [showMenu, setShowMenu] = React.useState<boolean>(true);
  const [showLogo, setShowLogo] = React.useState<boolean>(false);
  const [showCenteredLogo, setShowCenteredLogo] = React.useState<boolean>(true);
  const [showSelectorDropdown, setShowSelectorDropdown] = React.useState<boolean>(true);
  const [showOptionsDropdown, setShowOptionsDropdown] = React.useState<boolean>(true);

  const onSelectModel = (
    _event: React.MouseEvent<Element, MouseEvent> | undefined,
    value: string | number | undefined
  ) => {
    setSelectedModel(value as string);
  };

  const title = (
    <>
      <div className="show-light">
        <Brand src={PFHorizontalLogoColor} alt="PatternFly" style={{ marginRight: '10px' }} />
      </div>
      <div className="show-dark">
        <Brand src={PFHorizontalLogoReverse} alt="PatternFly" style={{ marginRight: '10px' }} />
      </div>
      <Title headingLevel="h1" size="2xl">
        ChatBot Extension
      </Title>
    </>
  );

  return (
    <Stack hasGutter>
      <FormGroup role="radiogroup" isInline fieldId="header-variant-form-radio-group" label="Variant">
        <Checkbox
          isChecked={showMenu && showCenteredLogo && showSelectorDropdown && showOptionsDropdown}
          onChange={() => {
            setShowMenu(true);
            setShowCenteredLogo(true);
            setShowSelectorDropdown(true);
            setShowOptionsDropdown(true);
            showLogo && setShowLogo(false);
          }}
          name="basic-inline-radio"
          label="All"
          id="all"
        />
        <Checkbox
          isChecked={showMenu}
          onChange={() => {
            setShowMenu(!showMenu);
            showAll && setShowAll(!showAll);
          }}
          name="basic-inline-radio"
          label="With menu"
          id="menu"
        />
        <Checkbox
          isChecked={showLogo}
          onChange={() => {
            setShowLogo(!showLogo);
            showCenteredLogo && setShowCenteredLogo(!showCenteredLogo);
          }}
          name="basic-inline-radio"
          label="With left-aligned logo"
          id="logo"
        />
        <Checkbox
          isChecked={showCenteredLogo}
          onChange={() => {
            setShowCenteredLogo(!showCenteredLogo);
            showLogo && setShowLogo(!showLogo);
            showAll && setShowAll(!showAll);
          }}
          name="basic-inline-radio"
          label="With centered logo"
          id="logo-centered"
        />
        <Checkbox
          isChecked={showSelectorDropdown}
          onChange={() => {
            setShowSelectorDropdown(!showSelectorDropdown);
            showAll && setShowAll(!showAll);
          }}
          name="basic-inline-radio"
          label="With selector dropdown"
          id="selector-dropdown"
        />
        <Checkbox
          isChecked={showOptionsDropdown}
          onChange={() => {
            setShowOptionsDropdown(!showOptionsDropdown);
            showAll && setShowAll(!showAll);
          }}
          name="basic-inline-radio"
          label="With settings dropdown"
          id="options-dropdown"
        />
      </FormGroup>

      <ChatbotHeader>
        {(showMenu || showLogo || showCenteredLogo) && (
          <ChatbotHeaderMain>
            {showMenu && <ChatbotHeaderMenu onMenuToggle={() => alert('Menu toggle clicked')} />}
            {(showLogo || showCenteredLogo) && (
              <ChatbotHeaderTitle>{showCenteredLogo ? <Bullseye>{title}</Bullseye> : title}</ChatbotHeaderTitle>
            )}
          </ChatbotHeaderMain>
        )}
        {(showSelectorDropdown || showOptionsDropdown) && (
          <ChatbotHeaderActions>
            {showSelectorDropdown && (
              <ChatbotHeaderSelectorDropdown value={selectedModel} onSelect={onSelectModel}>
                <DropdownList>
                  <DropdownItem value="Granite Code 7B" key="granite">
                    Granite Code 7B
                  </DropdownItem>
                  <DropdownItem value="Llama 3.0" key="llama">
                    Llama 3.0
                  </DropdownItem>
                  <DropdownItem value="Mistral 3B" key="mistral">
                    Mistral 3B
                  </DropdownItem>
                </DropdownList>
              </ChatbotHeaderSelectorDropdown>
            )}
            {showOptionsDropdown && (
              <ChatbotHeaderOptionsDropdown>
                <DropdownGroup label="Display mode">
                  <DropdownList>
                    <DropdownItem
                      value={ChatbotDisplayMode.default}
                      key="switchDisplayOverlay"
                      icon={<OutlinedWindowRestoreIcon aria-hidden />}
                    >
                      <span>Overlay</span>
                    </DropdownItem>
                    <DropdownItem
                      value={ChatbotDisplayMode.docked}
                      key="switchDisplayDock"
                      icon={<OpenDrawerRightIcon aria-hidden />}
                    >
                      <span>Dock to window</span>
                    </DropdownItem>
                    <DropdownItem
                      value={ChatbotDisplayMode.fullscreen}
                      key="switchDisplayFullscreen"
                      icon={<ExpandIcon aria-hidden />}
                    >
                      <span>Fullscreen</span>
                    </DropdownItem>
                  </DropdownList>
                </DropdownGroup>
              </ChatbotHeaderOptionsDropdown>
            )}
          </ChatbotHeaderActions>
        )}
      </ChatbotHeader>
    </Stack>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/ChatbotHeaderDrawer.tsx
================================================
import React from 'react';
import { ChatbotDisplayMode } from '@patternfly/chatbot/dist/dynamic/Chatbot';
import ChatbotConversationHistoryNav, {
  Conversation
} from '@patternfly/chatbot/dist/dynamic/ChatbotConversationHistoryNav';
import { Checkbox, EmptyStateStatus, Spinner } from '@patternfly/react-core';
import { OutlinedCommentsIcon, SearchIcon } from '@patternfly/react-icons';

const initialConversations: { [key: string]: Conversation[] } = {
  Today: [{ id: '1', text: 'Red Hat products and services' }],
  'This month': [
    {
      id: '2',
      text: 'Enterprise Linux installation and setup'
    },
    { id: '3', text: 'Troubleshoot system crash' }
  ],
  March: [
    { id: '4', text: 'Ansible security and updates' },
    { id: '5', text: 'Red Hat certification' },
    { id: '6', text: 'Lightspeed user documentation' }
  ],
  February: [
    { id: '7', text: 'Crashing pod assistance' },
    { id: '8', text: 'OpenShift AI pipelines' },
    { id: '9', text: 'Updating subscription plan' },
    { id: '10', text: 'Red Hat licensing options' }
  ],
  January: [
    { id: '11', text: 'RHEL system performance' },
    { id: '12', text: 'Manage user accounts' }
  ]
};

const ERROR = {
  bodyText: (
    <>
      To try again, check your connection and reload this page. If the issue persists,{' '}
      <a href="">contact the support team</a>.
    </>
  ),
  buttonText: 'Reload',
  buttonIcon: <Spinner size="sm" />,
  hasButton: true,
  titleText: 'Could not load chat history',
  status: EmptyStateStatus.danger,
  onClick: () => alert('Clicked Reload')
};

const NO_RESULTS = {
  bodyText: 'Adjust your search query and try again. Check your spelling or try a more general term.',
  titleText: 'No results found',
  icon: SearchIcon
};

const EMPTY_STATE = {
  bodyText: 'Access timely assistance by starting a conversation with an AI model.',
  titleText: 'Start a new chat',
  icon: OutlinedCommentsIcon
};

export const ChatbotHeaderTitleDemo: React.FunctionComponent = () => {
  const [isOpen, setIsOpen] = React.useState(true);
  const [isButtonOrderReversed, setIsButtonOrderReversed] = React.useState(false);
  const [isCompact, setIsCompact] = React.useState(false);
  const [conversations, setConversations] = React.useState<Conversation[] | { [key: string]: Conversation[] }>(
    initialConversations
  );
  const [isLoading, setIsLoading] = React.useState(false);
  const [hasError, setHasError] = React.useState(false);
  const [isEmpty, setIsEmpty] = React.useState(false);
  const [hasNoResults, setHasNoResults] = React.useState(false);
  const displayMode = ChatbotDisplayMode.embedded;

  const findMatchingItems = (targetValue: string) => {
    const filteredConversations = Object.entries(initialConversations).reduce((acc, [key, items]) => {
      const filteredItems = items.filter((item) => item.text.toLowerCase().includes(targetValue.toLowerCase()));
      if (filteredItems.length > 0) {
        acc[key] = filteredItems;
      }
      return acc;
    }, {});

    // append message if no items are found
    if (Object.keys(filteredConversations).length === 0) {
      setHasNoResults(true);
    } else {
      setHasNoResults(false);
    }
    return filteredConversations;
  };

  return (
    <>
      <Checkbox
        label="Display drawer"
        isChecked={isOpen}
        onChange={() => {
          setIsOpen(!isOpen);
          setConversations(initialConversations);
        }}
        id="drawer-visible"
        name="drawer-visible"
      />
      <Checkbox
        label="Reverse action buttons"
        isChecked={isButtonOrderReversed}
        onChange={() => setIsButtonOrderReversed(!isButtonOrderReversed)}
        id="drawer-actions-visible"
        name="drawer-actions-visible"
      ></Checkbox>
      <Checkbox
        label="Show loading state"
        isChecked={isLoading}
        onChange={() => setIsLoading(!isLoading)}
        id="drawer-is-loading"
        name="drawer-is-loading"
      ></Checkbox>
      <Checkbox
        label="Show error state"
        isChecked={hasError}
        onChange={() => setHasError(!hasError)}
        id="drawer-has-error"
        name="drawer-has-error"
      ></Checkbox>
      <Checkbox
        label="Show empty state"
        isChecked={isEmpty}
        onChange={() => setIsEmpty(!isEmpty)}
        id="drawer-is-empty"
        name="drawer-is-empty"
      ></Checkbox>
      <Checkbox
        label="Show no results state"
        isChecked={hasNoResults}
        onChange={() => setHasNoResults(!hasNoResults)}
        id="drawer-has-no-results"
        name="drawer-has-no-results"
      ></Checkbox>
      <Checkbox
        label="Show compact version"
        isChecked={isCompact}
        onChange={() => setIsCompact(!isCompact)}
        id="drawer-compact"
        name="drawer-compact"
      ></Checkbox>
      <ChatbotConversationHistoryNav
        displayMode={displayMode}
        onDrawerToggle={() => setIsOpen(!isOpen)}
        isDrawerOpen={isOpen}
        setIsDrawerOpen={setIsOpen}
        // eslint-disable-next-line no-console
        onSelectActiveItem={(e, selectedItem) => console.log(`Selected history item with id ${selectedItem}`)}
        conversations={conversations}
        onNewChat={() => {
          setIsOpen(!isOpen);
        }}
        reverseButtonOrder={isButtonOrderReversed}
        handleTextInputChange={(value: string) => {
          if (value === '') {
            setConversations(initialConversations);
          }
          // this is where you would perform search on the items in the drawer
          // and update the state
          const newConversations: { [key: string]: Conversation[] } = findMatchingItems(value);
          setConversations(newConversations);
        }}
        drawerContent={<div>Drawer content</div>}
        isLoading={isLoading}
        errorState={hasError ? ERROR : undefined}
        emptyState={isEmpty ? EMPTY_STATE : undefined}
        noResultsState={hasNoResults ? NO_RESULTS : undefined}
        isCompact={isCompact}
      />
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/ChatbotHeaderDrawerNavigation.tsx
================================================
import React from 'react';
import { ChatbotDisplayMode } from '@patternfly/chatbot/dist/dynamic/Chatbot';
import ChatbotConversationHistoryNav, {
  Conversation
} from '@patternfly/chatbot/dist/dynamic/ChatbotConversationHistoryNav';
import { Checkbox } from '@patternfly/react-core';

const initialConversations: Conversation[] = [
  { id: '1', text: 'Red Hat products and services', noIcon: true },
  {
    id: '2',
    text: 'Enterprise Linux installation and setup',
    noIcon: true
  },
  { id: '3', text: 'Troubleshoot system crash', noIcon: true },
  { id: '4', text: 'Ansible security and updates', noIcon: true },
  { id: '5', text: 'Red Hat certification', noIcon: true },
  { id: '6', text: 'Lightspeed user documentation', noIcon: true },
  { id: '7', text: 'Crashing pod assistance', noIcon: true },
  { id: '8', text: 'OpenShift AI pipelines', noIcon: true },
  { id: '9', text: 'Updating subscription plan', noIcon: true },
  { id: '10', text: 'Red Hat licensing options', noIcon: true },
  { id: '11', text: 'RHEL system performance', noIcon: true },
  { id: '12', text: 'Manage user accounts', noIcon: true }
];

export const ChatbotHeaderTitleDemo: React.FunctionComponent = () => {
  const [isOpen, setIsOpen] = React.useState(true);
  const [isButtonOrderReversed, setIsButtonOrderReversed] = React.useState(false);
  const [conversations, setConversations] = React.useState<Conversation[] | { [key: string]: Conversation[] }>(
    initialConversations
  );
  const displayMode = ChatbotDisplayMode.embedded;

  return (
    <>
      <Checkbox
        label="Display drawer"
        isChecked={isOpen}
        onChange={() => {
          setIsOpen(!isOpen);
          setConversations(initialConversations);
        }}
        id="navigation-drawer-visible"
        name="navigation-drawer-visible"
      />
      <Checkbox
        label="Reverse action buttons"
        isChecked={isButtonOrderReversed}
        onChange={() => setIsButtonOrderReversed(!isButtonOrderReversed)}
        id="navigation-drawer-actions-visible"
        name="navigation-drawer-actions-visible"
      ></Checkbox>
      <ChatbotConversationHistoryNav
        displayMode={displayMode}
        onDrawerToggle={() => setIsOpen(!isOpen)}
        isDrawerOpen={isOpen}
        setIsDrawerOpen={setIsOpen}
        // eslint-disable-next-line no-console
        onSelectActiveItem={(e, selectedItem) => console.log(`Selected history item with id ${selectedItem}`)}
        conversations={conversations}
        reverseButtonOrder={isButtonOrderReversed}
        drawerContent={<div>Drawer content</div>}
      />
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/ChatbotHeaderDrawerResizable.tsx
================================================
import React from 'react';
import { ChatbotDisplayMode } from '@patternfly/chatbot/dist/dynamic/Chatbot';
import ChatbotConversationHistoryNav, {
  Conversation
} from '@patternfly/chatbot/dist/dynamic/ChatbotConversationHistoryNav';
import { Checkbox } from '@patternfly/react-core';
import { SearchIcon } from '@patternfly/react-icons';

const initialConversations: { [key: string]: Conversation[] } = {
  Today: [{ id: '1', text: 'Red Hat products and services' }],
  'This month': [
    {
      id: '2',
      text: 'Enterprise Linux installation and setup'
    },
    { id: '3', text: 'Troubleshoot system crash' }
  ],
  March: [
    { id: '4', text: 'Ansible security and updates' },
    { id: '5', text: 'Red Hat certification' },
    { id: '6', text: 'Lightspeed user documentation' }
  ],
  February: [
    { id: '7', text: 'Crashing pod assistance' },
    { id: '8', text: 'OpenShift AI pipelines' },
    { id: '9', text: 'Updating subscription plan' },
    { id: '10', text: 'Red Hat licensing options' }
  ],
  January: [
    { id: '11', text: 'RHEL system performance' },
    { id: '12', text: 'Manage user accounts' }
  ]
};

const NO_RESULTS = {
  bodyText: 'Adjust your search query and try again. Check your spelling or try a more general term.',
  titleText: 'No results found',
  icon: SearchIcon
};

export const ChatbotHeaderDrawerResizableDemo: React.FunctionComponent = () => {
  const [isOpen, setIsOpen] = React.useState(true);
  const [conversations, setConversations] = React.useState<Conversation[] | { [key: string]: Conversation[] }>(
    initialConversations
  );
  const [showNoResults, setShowNoResults] = React.useState(false);
  const displayMode = ChatbotDisplayMode.embedded;

  const findMatchingItems = (targetValue: string) => {
    const filteredConversations = Object.entries(initialConversations).reduce((acc, [key, items]) => {
      const filteredItems = items.filter((item) => item.text.toLowerCase().includes(targetValue.toLowerCase()));
      if (filteredItems.length > 0) {
        acc[key] = filteredItems;
      }
      return acc;
    }, {});

    // append message if no items are found
    if (Object.keys(filteredConversations).length === 0) {
      setShowNoResults(true);
    } else {
      setShowNoResults(false);
    }
    return filteredConversations;
  };

  return (
    <>
      <Checkbox
        label="Display drawer"
        isChecked={isOpen}
        onChange={() => {
          setIsOpen(!isOpen);
          setConversations(initialConversations);
        }}
        id="drawer-visible"
        name="drawer-visible"
      />
      <ChatbotConversationHistoryNav
        displayMode={displayMode}
        onDrawerToggle={() => setIsOpen(!isOpen)}
        isDrawerOpen={isOpen}
        setIsDrawerOpen={setIsOpen}
        // eslint-disable-next-line no-console
        onSelectActiveItem={(e, selectedItem) => console.log(`Selected history item with id ${selectedItem}`)}
        conversations={conversations}
        onNewChat={() => {
          setIsOpen(!isOpen);
        }}
        handleTextInputChange={(value: string) => {
          if (value === '') {
            setConversations(initialConversations);
          }
          // this is where you would perform search on the items in the drawer
          // and update the state
          const newConversations: { [key: string]: Conversation[] } = findMatchingItems(value);
          setConversations(newConversations);
        }}
        drawerContent={<div>Drawer content</div>}
        drawerPanelContentProps={{ isResizable: true, minSize: '200px' }}
        emptyState={showNoResults ? NO_RESULTS : undefined}
      />
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/ChatbotHeaderDrawerWithActions.tsx
================================================
import React from 'react';
import { ChatbotDisplayMode } from '@patternfly/chatbot/dist/dynamic/Chatbot';
import ChatbotConversationHistoryNav, {
  Conversation
} from '@patternfly/chatbot/dist/dynamic/ChatbotConversationHistoryNav';
import { Checkbox, DropdownItem, DropdownList } from '@patternfly/react-core';

const menuItems = [
  <DropdownList key="list-1">
    <DropdownItem value="Share" id="Share">
      Share
    </DropdownItem>
    <DropdownItem value="Rename" id="Rename">
      Rename
    </DropdownItem>
    <DropdownItem value="Archive" id="Archive">
      Archive
    </DropdownItem>
    <DropdownItem value="Delete" id="Delete">
      Delete
    </DropdownItem>
  </DropdownList>
];

const conversations: { [key: string]: Conversation[] } = {
  Today: [{ id: '1', text: 'Red Hat products and services', menuItems }],
  'This month': [
    {
      id: '2',
      text: 'Enterprise Linux installation and setup',
      menuItems
    },
    { id: '3', text: 'Troubleshoot system crash', menuItems }
  ],
  March: [
    { id: '4', text: 'Ansible security and updates', menuItems },
    { id: '5', text: 'Red Hat certification', menuItems },
    { id: '6', text: 'Lightspeed user documentation', menuItems }
  ],
  February: [
    { id: '7', text: 'Crashing pod assistance', menuItems },
    { id: '8', text: 'OpenShift AI pipelines', menuItems },
    { id: '9', text: 'Updating subscription plan', menuItems },
    { id: '10', text: 'Red Hat licensing options', menuItems }
  ],
  January: [
    { id: '11', text: 'RHEL system performance', menuItems },
    { id: '12', text: 'Manage user accounts', menuItems }
  ]
};

export const ChatbotHeaderTitleDemo: React.FunctionComponent = () => {
  const [isDrawerOpen, setIsDrawerOpen] = React.useState(true);
  const [isCompact, setIsCompact] = React.useState(false);
  const displayMode = ChatbotDisplayMode.embedded;

  return (
    <>
      <Checkbox
        label="Display drawer"
        isChecked={isDrawerOpen}
        onChange={() => setIsDrawerOpen(!isDrawerOpen)}
        id="drawer-actions-visible"
        name="drawer-actions-visible"
      ></Checkbox>
      <Checkbox
        label="Show compact version"
        isChecked={isCompact}
        onChange={() => setIsCompact(!isCompact)}
        id="drawer-actions-compact"
        name="drawer-actions-compact"
      ></Checkbox>
      <ChatbotConversationHistoryNav
        displayMode={displayMode}
        onDrawerToggle={() => setIsDrawerOpen(!isDrawerOpen)}
        isDrawerOpen={isDrawerOpen}
        setIsDrawerOpen={setIsDrawerOpen}
        conversations={conversations}
        drawerContent={<div>Drawer content</div>}
        isCompact={isCompact}
      />
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/ChatbotHeaderDrawerWithSelection.tsx
================================================
import React from 'react';
import { ChatbotDisplayMode } from '@patternfly/chatbot/dist/dynamic/Chatbot';
import ChatbotConversationHistoryNav, {
  Conversation
} from '@patternfly/chatbot/dist/dynamic/ChatbotConversationHistoryNav';
import { Checkbox, DropdownItem, DropdownList } from '@patternfly/react-core';

const menuItems = [
  <DropdownList key="list-1">
    <DropdownItem value="Share" id="Share">
      Share
    </DropdownItem>
    <DropdownItem value="Rename" id="Rename">
      Rename
    </DropdownItem>
    <DropdownItem value="Archive" id="Archive">
      Archive
    </DropdownItem>
    <DropdownItem value="Delete" id="Delete">
      Delete
    </DropdownItem>
  </DropdownList>
];

export const ChatbotHeaderDrawerWithSelection: React.FunctionComponent = () => {
  const [isDrawerOpen, setIsDrawerOpen] = React.useState(true);
  const [currentSelection, setCurrentSelection] = React.useState('2');
  const [isCompact, setIsCompact] = React.useState(false);
  const displayMode = ChatbotDisplayMode.embedded;

  const conversations: { [key: string]: Conversation[] } = {
    Today: [{ id: '1', text: 'Red Hat products and services', menuItems }],
    'This month': [
      {
        id: '2',
        text: 'Enterprise Linux installation and setup',
        menuItems
      },
      { id: '3', text: 'Troubleshoot system crash', menuItems }
    ],
    March: [
      { id: '4', text: 'Ansible security and updates', menuItems },
      { id: '5', text: 'Red Hat certification', menuItems },
      { id: '6', text: 'Lightspeed user documentation', menuItems }
    ],
    February: [
      { id: '7', text: 'Crashing pod assistance', menuItems },
      { id: '8', text: 'OpenShift AI pipelines', menuItems },
      { id: '9', text: 'Updating subscription plan', menuItems },
      { id: '10', text: 'Red Hat licensing options', menuItems }
    ],
    January: [
      { id: '11', text: 'RHEL system performance', menuItems },
      { id: '12', text: 'Manage user accounts', menuItems }
    ]
  };

  return (
    <>
      <Checkbox
        label="Display drawer"
        isChecked={isDrawerOpen}
        onChange={() => setIsDrawerOpen(!isDrawerOpen)}
        id="drawer-selected-visible"
        name="drawer-selected-visible"
      ></Checkbox>
      <Checkbox
        label="Show compact version"
        isChecked={isCompact}
        onChange={() => setIsCompact(!isCompact)}
        id="drawer-selected-compact"
        name="drawer-selected-compact"
      ></Checkbox>
      <ChatbotConversationHistoryNav
        displayMode={displayMode}
        onDrawerToggle={() => setIsDrawerOpen(!isDrawerOpen)}
        isDrawerOpen={isDrawerOpen}
        setIsDrawerOpen={setIsDrawerOpen}
        conversations={conversations}
        drawerContent={<div>Drawer content</div>}
        activeItemId={currentSelection}
        onSelectActiveItem={(_e, id) => setCurrentSelection(id as string)}
        isCompact={isCompact}
      />
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/ChatbotHeaderTitle.tsx
================================================
import React from 'react';
import { ChatbotHeaderTitle } from '@patternfly/chatbot/dist/dynamic/ChatbotHeader';
import { ChatbotDisplayMode } from '@patternfly/chatbot/dist/dynamic/Chatbot';
import { MenuToggle, MenuToggleElement, Select, SelectList, SelectOption } from '@patternfly/react-core';

export const ChatbotHeaderTitleDemo: React.FunctionComponent = () => {
  const [displayMode, setDisplayMode] = React.useState(ChatbotDisplayMode.default);
  const [isOpen, setIsOpen] = React.useState(false);
  const [selected, setSelected] = React.useState<string>('Select display mode');

  const onSelect = (_event: React.MouseEvent<Element, MouseEvent> | undefined, value: string | number | undefined) => {
    setSelected(value as string);
    setIsOpen(false);
    if (value === 'Default') {
      setDisplayMode(ChatbotDisplayMode.default);
    }
    if (value === 'Embedded') {
      setDisplayMode(ChatbotDisplayMode.embedded);
    }
    if (value === 'Docked') {
      setDisplayMode(ChatbotDisplayMode.docked);
    }
    if (value === 'Full screen') {
      setDisplayMode(ChatbotDisplayMode.fullscreen);
    }
  };

  const onToggleClick = () => {
    setIsOpen(!isOpen);
  };

  const toggle = (toggleRef: React.Ref<MenuToggleElement>) => (
    <MenuToggle
      className="pf-v6-u-mb-md"
      ref={toggleRef}
      onClick={onToggleClick}
      isExpanded={isOpen}
      style={
        {
          width: '200px'
        } as React.CSSProperties
      }
    >
      {selected}
    </MenuToggle>
  );

  return (
    <>
      <Select
        id="single-select"
        isOpen={isOpen}
        selected={selected}
        onSelect={onSelect}
        onOpenChange={(isOpen) => setIsOpen(isOpen)}
        toggle={toggle}
        shouldFocusToggleOnSelect
      >
        <SelectList>
          <SelectOption value="Default">Default</SelectOption>
          <SelectOption value="Embedded">Embedded</SelectOption>
          <SelectOption value="Docked">Docked</SelectOption>
          <SelectOption value="Full screen">Full screen</SelectOption>
        </SelectList>
      </Select>
      <ChatbotHeaderTitle
        displayMode={displayMode}
        showOnEmbedded="Embedded"
        showOnDocked="Docked"
        showOnFullScreen="Full screen"
        showOnDefault="Default"
      />
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/ChatbotMessageBar.tsx
================================================
import React from 'react';
import { MessageBar } from '@patternfly/chatbot/dist/dynamic/MessageBar';

export const ChatbotMessageBarExample: React.FunctionComponent = () => {
  const handleSend = (message) => alert(message);

  return <MessageBar onSendMessage={handleSend} hasMicrophoneButton />;
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/ChatbotMessageBarAttach.tsx
================================================
import React from 'react';
import { MessageBar } from '@patternfly/chatbot/dist/dynamic/MessageBar';
import SourceDetailsMenuItem from '@patternfly/chatbot/dist/dynamic/SourceDetailsMenuItem';
import { Divider, DropdownGroup, DropdownItem, DropdownList } from '@patternfly/react-core';
import { BellIcon, CalendarAltIcon, ClipboardIcon, CodeIcon, UploadIcon } from '@patternfly/react-icons';
import { useDropzone } from 'react-dropzone';

export const ChatbotMessageBarDefaultAttachExample: React.FunctionComponent = () => {
  const [isOpen, setIsOpen] = React.useState<boolean>(false);
  const [userFacingMenuItems, setUserFacingMenuItems] = React.useState<React.ReactNode>([]);

  const handleSend = (message) => alert(message);
  const { open, getInputProps } = useDropzone({
    multiple: true,
    // eslint-disable-next-line no-console
    onDropAccepted: () => console.log('fileUploaded')
  });

  const onToggleClick = () => {
    setIsOpen(!isOpen);
    setUserFacingMenuItems(initialMenuItems.concat(uploadMenuItems));
  };

  const findMatchingElements = (elements: React.ReactNode[], targetValue: string) => {
    let matchingElements = [] as React.ReactNode[];

    elements.forEach((element) => {
      if (React.isValidElement(element)) {
        // Check if the element's value matches the targetValue
        if (element.props.value && element.props.value.toLowerCase().includes(targetValue.toLowerCase())) {
          matchingElements.push(React.cloneElement(element, { key: element.props.value }));
        }

        // Recursively check the element's children
        const children = React.Children.toArray(element.props.children);
        matchingElements = matchingElements.concat(findMatchingElements(children, targetValue));
      }
    });

    return matchingElements;
  };

  const onTextChange = (textValue: string) => {
    if (textValue === '') {
      setUserFacingMenuItems(initialMenuItems.concat(uploadMenuItems));
      return;
    }

    const newMenuItems = findMatchingElements(initialMenuItems, textValue);
    // this is necessary because the React nodes we find traversing the recursive search
    // aren't correctly wrapped in a DropdownList. This leads to problems with the
    // auth-operator item where it winds up floating in a bad place in the DOM and never
    // gets removed
    setUserFacingMenuItems(
      <>
        <DropdownList>
          {newMenuItems.length === 0 ? (
            <DropdownItem key="no-items">No results found</DropdownItem>
          ) : (
            newMenuItems.map((item) => item)
          )}
        </DropdownList>
        {uploadMenuItems.map((item) => item)}
      </>
    );
  };

  const initialMenuItems = [
    <DropdownList key="list-1">
      <DropdownItem className="pf-chatbot-source-details-dropdown-item" value="auth-operator Pod" id="0">
        <SourceDetailsMenuItem
          icon={
            <svg width="24" height="25" viewBox="0 0 24 25" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path
                d="M0 12.5C0 5.87258 5.37258 0.5 12 0.5C18.6274 0.5 24 5.87258 24 12.5C24 19.1274 18.6274 24.5 12 24.5C5.37258 24.5 0 19.1274 0 12.5Z"
                fill="currentColor"
              />
              <g clipPath="url(#clip0_3280_27488)">
                <path
                  d="M8.25 8.75C8.25 7.92266 8.92266 7.25 9.75 7.25H12C14.0719 7.25 15.75 8.92812 15.75 11C15.75 13.0719 14.0719 14.75 12 14.75H9.75V17C9.75 17.4148 9.41484 17.75 9 17.75C8.58516 17.75 8.25 17.4148 8.25 17V14V8.75ZM9.75 13.25H12C13.2422 13.25 14.25 12.2422 14.25 11C14.25 9.75781 13.2422 8.75 12 8.75H9.75V13.25Z"
                  fill="white"
                />
              </g>
              <defs>
                <clipPath id="clip0_3280_27488">
                  <rect width="7.5" height="12" fill="white" transform="translate(8.25 6.5)" />
                </clipPath>
              </defs>
            </svg>
          }
          name="auth-operator"
          type="Pod"
        />
      </DropdownItem>
    </DropdownList>,
    <DropdownGroup key="group2">
      <DropdownList>
        <DropdownItem value="Alerts" id="1" icon={<BellIcon />}>
          Alerts
        </DropdownItem>
        <DropdownItem value="Events" id="2" icon={<CalendarAltIcon />}>
          Events
        </DropdownItem>
        <DropdownItem value="Logs" id="3" icon={<ClipboardIcon />}>
          Logs
        </DropdownItem>
        <DropdownItem value="YAML - Status" id="4" icon={<CodeIcon />}>
          YAML - Status
        </DropdownItem>
        <DropdownItem value="YAML - All contents" id="5" icon={<CodeIcon />}>
          YAML - All contents
        </DropdownItem>
      </DropdownList>
    </DropdownGroup>
  ];

  const uploadMenuItems = [
    <Divider key="divider" />,
    <DropdownList key="list-2">
      <DropdownItem key="upload" value="upload" id="upload" icon={<UploadIcon />} onClick={open}>
        Upload from computer
      </DropdownItem>
    </DropdownList>
  ];

  return (
    <>
      {/* this is required for react-dropzone to work in Safari and Firefox */}
      <input {...getInputProps()} hidden />
      <MessageBar
        onSendMessage={handleSend}
        attachMenuProps={{
          isAttachMenuOpen: isOpen,
          setIsAttachMenuOpen: setIsOpen,
          attachMenuItems: userFacingMenuItems,
          onAttachMenuSelect: (_ev, value) => {
            // eslint-disable-next-line no-console
            console.log('selected', value);
            setIsOpen(false);
          },
          attachMenuInputPlaceholder: 'Search cluster resources...',
          onAttachMenuInputChange: onTextChange,
          onAttachMenuToggleClick: onToggleClick
        }}
      />
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/ChatbotMessageBarDisabled.tsx
================================================
import React from 'react';
import { MessageBar } from '@patternfly/chatbot/dist/dynamic/MessageBar';
import { Checkbox } from '@patternfly/react-core';

export const ChatbotMessageBarDisabledExample: React.FunctionComponent = () => {
  const [isDisabled, setIsDisabled] = React.useState(false);
  const handleSend = (message) => alert(message);

  return (
    <>
      <Checkbox
        label="Disable send button"
        isChecked={isDisabled}
        onChange={() => setIsDisabled(!isDisabled)}
        id="disabled"
        name="disabled"
      />
      <MessageBar
        onSendMessage={handleSend}
        isSendButtonDisabled={isDisabled}
        alwayShowSendButton
        hasAttachButton={false}
      />
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/ChatbotMessageBarLanguage.tsx
================================================
import React from 'react';
import { MessageBar } from '@patternfly/chatbot/dist/dynamic/MessageBar';

export const ChatbotMessageBarExample: React.FunctionComponent = () => {
  const handleSend = (message) => alert(message);

  return (
    <MessageBar
      hasAttachButton={false}
      onSendMessage={handleSend}
      hasMicrophoneButton
      buttonProps={{
        microphone: { language: 'ja-JP' }
      }}
    />
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/ChatbotMessageBarStop.tsx
================================================
import React from 'react';
import { MessageBar } from '@patternfly/chatbot/dist/dynamic/MessageBar';

export const ChatbotMessageBarStop: React.FunctionComponent = () => {
  const handleSend = (message) => alert(message);

  const handleStopButton = () => alert('Stop button clicked');

  return <MessageBar handleStopButton={handleStopButton} hasStopButton onSendMessage={handleSend} />;
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/ChatbotModal.tsx
================================================
import React from 'react';
import {
  Button,
  ModalBody,
  ModalFooter,
  ModalHeader,
  MenuToggle,
  MenuToggleElement,
  Select,
  SelectList,
  SelectOption,
  Stack
} from '@patternfly/react-core';
import { ChatbotModal } from '@patternfly/chatbot/dist/dynamic/ChatbotModal';
import Chatbot, { ChatbotDisplayMode } from '@patternfly/chatbot/dist/dynamic/Chatbot';

export const ChatbotModalExample: React.FunctionComponent = () => {
  const [isModalOpen, setIsModalOpen] = React.useState(false);
  const [displayMode, setDisplayMode] = React.useState(ChatbotDisplayMode.default);
  const [isOpen, setIsOpen] = React.useState(false);
  const [selected, setSelected] = React.useState<string>('Select display mode');

  const handleModalToggle = (_event: React.MouseEvent | MouseEvent | KeyboardEvent) => {
    setIsModalOpen(!isModalOpen);
  };

  const onSelect = (_event: React.MouseEvent<Element, MouseEvent> | undefined, value: string | number | undefined) => {
    setSelected(value as string);
    setIsOpen(false);
    if (value === 'Default') {
      setDisplayMode(ChatbotDisplayMode.default);
    }
    if (value === 'Docked') {
      setDisplayMode(ChatbotDisplayMode.docked);
    }
    if (value === 'Fullscreen') {
      setDisplayMode(ChatbotDisplayMode.fullscreen);
    }
    if (value === 'Embedded') {
      setDisplayMode(ChatbotDisplayMode.embedded);
    }
  };

  const onToggleClick = () => {
    setIsOpen(!isOpen);
  };

  const toggle = (toggleRef: React.Ref<MenuToggleElement>) => (
    <MenuToggle
      ref={toggleRef}
      onClick={onToggleClick}
      isExpanded={isOpen}
      style={
        {
          width: '200px'
        } as React.CSSProperties
      }
    >
      {selected}
    </MenuToggle>
  );

  return (
    <>
      <div
        style={{
          position: 'fixed',
          padding: 'var(--pf-t--global--spacer--lg)',
          zIndex: '601',
          boxShadow: 'var(--pf-t--global--box-shadow--lg)'
        }}
      >
        <Stack hasGutter>
          <Select
            id="single-select"
            isOpen={isOpen}
            selected={selected}
            onSelect={onSelect}
            onOpenChange={(isOpen) => setIsOpen(isOpen)}
            toggle={toggle}
            shouldFocusToggleOnSelect
          >
            <SelectList>
              <SelectOption value="Default">Default</SelectOption>
              <SelectOption value="Docked">Docked</SelectOption>
              <SelectOption value="Fullscreen">Fullscreen</SelectOption>
              <SelectOption value="Embedded">Embedded</SelectOption>
            </SelectList>
          </Select>
          <Button onClick={handleModalToggle}>Launch modal</Button>
        </Stack>
      </div>
      <Chatbot displayMode={displayMode} isVisible></Chatbot>
      <ChatbotModal
        isOpen={isModalOpen}
        displayMode={displayMode}
        onClose={handleModalToggle}
        ouiaId="ChatbotModal"
        aria-labelledby="basic-modal-title"
        aria-describedby="modal-box-body-basic"
      >
        <ModalHeader title="Basic modal" labelId="basic-modal-title" />
        <ModalBody id="modal-box-body-basic">
          Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore
          magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
          consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla
          pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id
          est laborum.
        </ModalBody>
        <ModalFooter>
          <Button key="confirm" variant="primary" onClick={handleModalToggle}>
            Confirm
          </Button>
          <Button key="cancel" variant="link" onClick={handleModalToggle}>
            Cancel
          </Button>
        </ModalFooter>
      </ChatbotModal>
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/ChatbotToggleBasic.tsx
================================================
import React from 'react';
import ChatbotToggle from '@patternfly/chatbot/dist/dynamic/ChatbotToggle';

export const BasicDemo: React.FunctionComponent = () => {
  const [chatbotVisible, setChatbotVisible] = React.useState<boolean>(false);
  return (
    <ChatbotToggle
      tooltipLabel="Chatbot"
      isChatbotVisible={chatbotVisible}
      onToggleChatbot={() => setChatbotVisible(!chatbotVisible)}
    />
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/ChatbotWelcomeInteraction.tsx
================================================
import React from 'react';

import Chatbot, { ChatbotDisplayMode } from '@patternfly/chatbot/dist/dynamic/Chatbot';
import ChatbotContent from '@patternfly/chatbot/dist/dynamic/ChatbotContent';
import ChatbotWelcomePrompt from '@patternfly/chatbot/dist/dynamic/ChatbotWelcomePrompt';
import ChatbotFooter from '@patternfly/chatbot/dist/dynamic/ChatbotFooter';
import MessageBar from '@patternfly/chatbot/dist/dynamic/MessageBar';
import MessageBox from '@patternfly/chatbot/dist/dynamic/MessageBox';
import Message, { MessageProps } from '@patternfly/chatbot/dist/dynamic/Message';
import userAvatar from '../Messages/user_avatar.svg';
import patternflyAvatar from '../Messages/patternfly_avatar.jpg';
import { FormGroup, Radio } from '@patternfly/react-core';

export const ChatbotWelcomeInteractionDemo: React.FunctionComponent = () => {
  const [messages, setMessages] = React.useState<MessageProps[]>([]);
  const [isSendButtonDisabled, setIsSendButtonDisabled] = React.useState(false);
  const [announcement, setAnnouncement] = React.useState<string>();
  const [position, setPosition] = React.useState<'top' | 'bottom'>('top');
  const scrollToBottomRef = React.useRef<HTMLDivElement>(null);
  const isVisible = true;
  const displayMode = ChatbotDisplayMode.default;

  // you will likely want to come up with your own unique id function; this is for demo purposes only
  const generateId = () => {
    const id = Date.now() + Math.random();
    return id.toString();
  };

  const handleSend = (message: string) => {
    setIsSendButtonDisabled(true);
    const newMessages: MessageProps[] = [];
    // We can't use structuredClone since messages contains functions, but we can't mutate
    // items that are going into state or the UI won't update correctly
    messages.forEach((message) => newMessages.push(message));
    // It's important to set a timestamp prop since the Message components re-render.
    // The timestamps re-render with them.
    const date = new Date();
    newMessages.push({
      id: generateId(),
      role: 'user',
      content: message,
      name: 'User',
      avatar: userAvatar,
      timestamp: date.toLocaleString(),
      avatarProps: { isBordered: true }
    });
    newMessages.push({
      id: generateId(),
      role: 'bot',
      content: 'API response goes here',
      name: 'Bot',
      isLoading: true,
      avatar: patternflyAvatar,
      timestamp: date.toLocaleString()
    });
    setMessages(newMessages);
    // make announcement to assistive devices that new messages have been added
    setAnnouncement(`Message from User: ${message}. Message from Bot is loading.`);

    // this is for demo purposes only; in a real situation, there would be an API response we would wait for
    setTimeout(() => {
      const loadedMessages: MessageProps[] = [];
      // We can't use structuredClone since messages contains functions, but we can't mutate
      // items that are going into state or the UI won't update correctly
      newMessages.forEach((message) => loadedMessages.push(message));
      loadedMessages.pop();
      loadedMessages.push({
        id: generateId(),
        role: 'bot',
        content: 'API response goes here',
        name: 'Bot',
        isLoading: false,
        avatar: patternflyAvatar,
        timestamp: date.toLocaleString(),
        actions: {
          // eslint-disable-next-line no-console
          positive: { onClick: () => console.log('Good response') },
          // eslint-disable-next-line no-console
          negative: { onClick: () => console.log('Bad response') },
          // eslint-disable-next-line no-console
          copy: { onClick: () => console.log('Copy') },
          // eslint-disable-next-line no-console
          share: { onClick: () => console.log('Share') },
          // eslint-disable-next-line no-console
          listen: { onClick: () => console.log('Listen') }
        }
      });
      setMessages(loadedMessages);
      // make announcement to assistive devices that new message has loaded
      setAnnouncement(`Message from Bot: API response goes here`);
      setIsSendButtonDisabled(false);
    }, 5000);
  };

  return (
    <>
      <FormGroup role="radiogroup" isInline fieldId="basic-form-radio-group" label="Position">
        <Radio
          isChecked={position === 'top'}
          onChange={() => setPosition('top')}
          name="basic-inline-radio"
          label="Top"
          id="top"
        />
        <Radio
          isChecked={position === 'bottom'}
          onChange={() => setPosition('bottom')}
          name="basic-inline-radio"
          label="Bottom"
          id="bottom"
        />
      </FormGroup>
      <Chatbot displayMode={displayMode} isVisible={isVisible}>
        <ChatbotContent>
          {/* Update the announcement prop on MessageBox whenever a new message is sent
        so that users of assistive devices receive sufficient context  */}
          <MessageBox announcement={announcement} position={position}>
            {messages.length === 0 && (
              <ChatbotWelcomePrompt title="Hi, ChatBot User!" description="How can I help you today?" />
            )}
            {/* This code block enables scrolling to the top of the last message.
          You can instead choose to move the div with scrollToBottomRef on it below 
          the map of messages, so that users are forced to scroll to the bottom.
          If you are using streaming, you will want to take a different approach; 
          see: https://github.com/patternfly/chatbot/issues/201#issuecomment-2400725173 */}
            {messages.map((message, index) => {
              if (index === messages.length - 1) {
                return (
                  <>
                    <div ref={scrollToBottomRef}></div>
                    <Message key={message.id} {...message} />
                  </>
                );
              }
              return <Message key={message.id} {...message} />;
            })}
          </MessageBox>
        </ChatbotContent>
        <ChatbotFooter>
          <MessageBar onSendMessage={handleSend} hasMicrophoneButton isSendButtonDisabled={isSendButtonDisabled} />
        </ChatbotFooter>
      </Chatbot>
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/ChatbotWelcomePrompt.tsx
================================================
import React from 'react';

import ChatbotWelcomePrompt from '@patternfly/chatbot/dist/dynamic/ChatbotWelcomePrompt';
import { Checkbox } from '@patternfly/react-core';

export const ChatbotWelcomePromptExample: React.FunctionComponent = () => {
  const [showWelcomePrompts, setShowWelcomePrompts] = React.useState(true);

  const welcomePrompts = [
    {
      title: 'Set up account',
      message: 'Choose the necessary settings and preferences for your account.'
    },
    {
      title: 'Troubleshoot issue',
      message: 'Find documentation and instructions to resolve your issue.'
    }
  ];

  return (
    <>
      <Checkbox
        isChecked={showWelcomePrompts}
        onChange={() => {
          setShowWelcomePrompts(!showWelcomePrompts);
        }}
        name="showWelcomePrompts"
        label="Show welcome prompts"
        id="showWelcomePrompts"
      />
      <ChatbotWelcomePrompt
        title="Hi, ChatBot User!"
        description="How can I help you today?"
        {...(showWelcomePrompts && { prompts: welcomePrompts })}
      />
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/CompactSettings.tsx
================================================
import React from 'react';

import SettingsForm from '@patternfly/chatbot/dist/dynamic/Settings';
import {
  Button,
  Divider,
  Dropdown,
  DropdownGroup,
  DropdownItem,
  DropdownList,
  MenuToggle,
  MenuToggleElement,
  Switch,
  Title
} from '@patternfly/react-core';
import Chatbot, { ChatbotDisplayMode } from '@patternfly/chatbot/dist/dynamic/Chatbot';
import ChatbotHeader, {
  ChatbotHeaderActions,
  ChatbotHeaderCloseButton,
  ChatbotHeaderMain,
  ChatbotHeaderOptionsDropdown,
  ChatbotHeaderTitle
} from '@patternfly/chatbot/dist/dynamic/ChatbotHeader';
import { CogIcon, ExpandIcon, OpenDrawerRightIcon, OutlinedWindowRestoreIcon } from '@patternfly/react-icons';

export const CompactSettingsDemo: React.FunctionComponent = () => {
  const [isChecked, setIsChecked] = React.useState<boolean>(true);
  const [isThemeOpen, setIsThemeOpen] = React.useState(false);
  const [isLanguageOpen, setIsLanguageOpen] = React.useState(false);
  const [isVoiceOpen, setIsVoiceOpen] = React.useState(false);
  const [displayMode, setDisplayMode] = React.useState(ChatbotDisplayMode.default);
  const [areSettingsOpen, setAreSettingsOpen] = React.useState(true);
  const chatbotVisible = true;

  const onFocus = (id: string) => {
    const element = document.getElementById(id);
    (element as HTMLElement).focus();
  };

  const onThemeToggleClick = () => {
    setIsThemeOpen(!isThemeOpen);
  };

  const onThemeSelect = (
    _event: React.MouseEvent<Element, MouseEvent> | undefined,
    value: string | number | undefined
  ) => {
    // eslint-disable-next-line no-console
    console.log('selected', value);
    onFocus('theme');
    setIsThemeOpen(false);
  };

  const onLanguageToggleClick = () => {
    setIsLanguageOpen(!isLanguageOpen);
  };

  const onLanguageSelect = (
    _event: React.MouseEvent<Element, MouseEvent> | undefined,
    value: string | number | undefined
  ) => {
    // eslint-disable-next-line no-console
    console.log('selected', value);
    onFocus('language');
    setIsLanguageOpen(false);
  };

  const onVoiceToggleClick = () => {
    onFocus('voice');
    setIsVoiceOpen(!isVoiceOpen);
  };

  const onVoiceSelect = (
    _event: React.MouseEvent<Element, MouseEvent> | undefined,
    value: string | number | undefined
  ) => {
    // eslint-disable-next-line no-console
    console.log('selected', value);
    setIsVoiceOpen(false);
  };

  const handleChange = (_event: React.FormEvent<HTMLInputElement>, checked: boolean) => {
    setIsChecked(checked);
  };

  const themeDropdown = (
    <Dropdown
      isOpen={isThemeOpen}
      onSelect={onThemeSelect}
      onOpenChange={(isOpen: boolean) => setIsThemeOpen(isOpen)}
      shouldFocusToggleOnSelect
      shouldFocusFirstItemOnOpen
      shouldPreventScrollOnItemFocus
      toggle={(toggleRef: React.Ref<MenuToggleElement>) => (
        // We want to add the id property here as well so the label is coupled
        // with t he button on screen readers.
        <MenuToggle size="sm" id="theme" ref={toggleRef} onClick={onThemeToggleClick} isExpanded={isThemeOpen}>
          System
        </MenuToggle>
      )}
      ouiaId="ThemeDropdown"
    >
      <DropdownList>
        <DropdownItem value="System" key="system">
          System
        </DropdownItem>
      </DropdownList>
    </Dropdown>
  );

  const languageDropdown = (
    <Dropdown
      isOpen={isLanguageOpen}
      onSelect={onLanguageSelect}
      onOpenChange={(isOpen: boolean) => setIsLanguageOpen(isOpen)}
      shouldFocusToggleOnSelect
      shouldFocusFirstItemOnOpen
      shouldPreventScrollOnItemFocus
      toggle={(toggleRef: React.Ref<MenuToggleElement>) => (
        // We want to add the id property here as well so the label is coupled
        // with the button on screen readers.
        <MenuToggle size="sm" id="language" ref={toggleRef} onClick={onLanguageToggleClick} isExpanded={isLanguageOpen}>
          Auto-detect
        </MenuToggle>
      )}
      ouiaId="LanguageDropdown"
    >
      <DropdownList>
        <DropdownItem value="Auto-detect" key="auto-detect">
          Auto-detect
        </DropdownItem>
      </DropdownList>
    </Dropdown>
  );
  const voiceDropdown = (
    <Dropdown
      isOpen={isVoiceOpen}
      onSelect={onVoiceSelect}
      onOpenChange={(isOpen: boolean) => setIsVoiceOpen(isOpen)}
      shouldFocusToggleOnSelect
      shouldFocusFirstItemOnOpen
      shouldPreventScrollOnItemFocus
      toggle={(toggleRef: React.Ref<MenuToggleElement>) => (
        // We want to add the id property here as well so the label is coupled
        // with the button on screen readers.
        <MenuToggle size="sm" id="voice" ref={toggleRef} onClick={onVoiceToggleClick} isExpanded={isVoiceOpen}>
          Bot
        </MenuToggle>
      )}
      ouiaId="VoiceDropdown"
    >
      <DropdownList>
        <DropdownItem value="Bot" key="bot">
          Bot
        </DropdownItem>
      </DropdownList>
    </Dropdown>
  );
  const children = [
    { id: 'theme', label: 'Theme', field: themeDropdown },
    { id: 'language', label: 'Language', field: languageDropdown },
    { id: 'voice', label: 'Voice', field: voiceDropdown },
    {
      id: 'analytics',
      label: 'Share analytics',
      field: (
        <Switch
          // We want to add the id property here as well so the label is coupled
          // with the button on screen readers.
          id="analytics"
          aria-label="Togglable option for whether to share analytics"
          isChecked={isChecked}
          onChange={handleChange}
        />
      )
    },
    {
      id: 'archived-chat',
      label: 'Archive chat',
      field: (
        // We want to add the id property here as well so the label is coupled
        // with the button on screen readers.
        <Button size="sm" id="archived-chat" variant="secondary">
          Manage
        </Button>
      )
    },
    {
      id: 'archive-all',
      label: 'Archive all chat',
      field: (
        // We want to add the id property here as well so the label is coupled
        // with the button on screen readers.
        <Button size="sm" id="archive-all" variant="secondary">
          Archive all
        </Button>
      )
    },
    {
      id: 'delete-all',
      label: 'Delete all chats',
      field: (
        // We want to add the id property here as well so the label is coupled
        // with the button on screen readers.
        <Button size="sm" id="delete-all" variant="danger">
          Delete all
        </Button>
      )
    }
  ];

  const onSelectDropdownItem = (
    _event: React.MouseEvent<Element, MouseEvent> | undefined,
    value: string | number | undefined
  ) => {
    if (value === 'Settings') {
      setAreSettingsOpen(true);
    } else {
      setDisplayMode(value as ChatbotDisplayMode);
    }
  };

  const regularChatbot = (
    <ChatbotHeader>
      <ChatbotHeaderActions>
        <ChatbotHeaderOptionsDropdown isCompact onSelect={onSelectDropdownItem}>
          <DropdownGroup label="Display mode">
            <DropdownList>
              <DropdownItem
                value={ChatbotDisplayMode.default}
                key="switchDisplayOverlay"
                icon={<OutlinedWindowRestoreIcon aria-hidden />}
                isSelected={displayMode === ChatbotDisplayMode.default}
              >
                <span>Overlay</span>
              </DropdownItem>
              <DropdownItem
                value={ChatbotDisplayMode.docked}
                key="switchDisplayDock"
                icon={<OpenDrawerRightIcon aria-hidden />}
                isSelected={displayMode === ChatbotDisplayMode.docked}
              >
                <span>Dock to window</span>
              </DropdownItem>
              <DropdownItem
                value={ChatbotDisplayMode.fullscreen}
                key="switchDisplayFullscreen"
                icon={<ExpandIcon aria-hidden />}
                isSelected={displayMode === ChatbotDisplayMode.fullscreen}
              >
                <span>Fullscreen</span>
              </DropdownItem>
            </DropdownList>
          </DropdownGroup>
          <Divider />
          <DropdownList>
            <DropdownItem value="Settings" key="switchSettings" icon={<CogIcon aria-hidden />}>
              <span>Settings</span>
            </DropdownItem>
          </DropdownList>
        </ChatbotHeaderOptionsDropdown>
      </ChatbotHeaderActions>
    </ChatbotHeader>
  );

  return (
    <>
      <Chatbot isCompact isVisible={chatbotVisible} displayMode={displayMode}>
        {areSettingsOpen ? (
          <>
            <ChatbotHeader className="pf-m-compact">
              <ChatbotHeaderMain>
                <ChatbotHeaderTitle>
                  <Title headingLevel="h1" size="2xl">
                    Settings
                  </Title>
                </ChatbotHeaderTitle>
              </ChatbotHeaderMain>
              <ChatbotHeaderCloseButton isCompact onClick={() => setAreSettingsOpen(false)} />
            </ChatbotHeader>
            <SettingsForm isCompact fields={children} />
          </>
        ) : (
          <>{regularChatbot}</>
        )}
      </Chatbot>
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/CustomClosedIcon.tsx
================================================
import React from 'react';
import ChatbotToggle from '@patternfly/chatbot/dist/dynamic/ChatbotToggle';

export const BasicDemo: React.FunctionComponent = () => {
  const [chatbotVisible, setChatbotVisible] = React.useState<boolean>(false);

  const closedToggleIcon: () => JSX.Element = () => (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      id="Layer_1"
      data-name="Layer 1"
      viewBox="0 0 40.62 36.55"
      style={{ height: '2.5rem', width: '2.5rem' }}
    >
      <defs>
        <style>
          {`
          .cls-1 {
            stroke-width: 0px;
          }
          .eye {
            transform-origin: 50%;
            -webkit-transform-origin: 50%;
            -webkit-animation: blink 5s infinite;
            animation: blink 5s infinite;
          }
          @-webkit-keyframes blink {
            0%, 100% {
              transform: scale(1, 0.05);
            }
            5%, 95% {
              transform: scale(1, 1);
            }
          }
          @keyframes blink {
            0%, 100% {
              transform: scale(1, 0.05);
            }
            5%, 95% {
              transform: scale(1, 1);
            }
          }
        `}
        </style>
      </defs>
      <path
        fill="currentColor"
        id="mouth"
        className="cls-1"
        d="m17.09,30.4c-.6,0-1.2-.2-1.7-.6l-2.2-1.6s-.4-.6.1-1.1c.4-.6,1.2-.4,1.2-.4,0,0,1.2.9,2.1,1.5.3.2.7.3,1,.3l9.3.1s.7.1.7,1.1c0,.6-.7.9-.7.9h-9.8v-.2Z"
      />
      <path
        fill="currentColor"
        id="right_ear"
        data-name="right ear"
        className="cls-1"
        d="m37.29,15.6c1.7,0,3,1.3,3,3v6c0,1.7-1.3,3-3,3h-1v-12h1Z"
      />
      <path
        fill="currentColor"
        id="left_ear"
        data-name="left ear"
        className="cls-1"
        d="m3.29,15.6h1v12h-1c-1.7,0-3-1.3-3-3v-6c0-1.7,1.4-3,3-3Z"
      />
      <circle fill="currentColor" className="cls-1 eye" cx="26.1" cy="18.3" r="2.4" />
      <circle fill="currentColor" className="cls-1 eye" cx="14.5" cy="18.3" r="2.4" />
      <circle fill="currentColor" className="cls-1" cx="14" cy="4" r="1.6">
        <animate attributeName="cx" begin="0s" dur="2s" values="13.5;27;13.5" repeatCount="indefinite" />
      </circle>
      <g id="antennas_copy" data-name="antennas copy">
        <path
          fill="currentColor"
          className="cls-1"
          d="m29.59,9.1h-.7l1.1-2.4h.5c1.4,0,2.5-1.1,2.5-2.5s-1.1-2.5-2.5-2.5-2.5,1.1-2.5,2.5c0,.8.4,1.4.9,1.9l-1.4,3h-14.3l-1.4-3c.5-.5.8-1.1.8-1.8,0-1.4-1.1-2.5-2.5-2.5s-2.5,1.1-2.5,2.5,1.1,2.5,2.5,2.5c.2,0,.4,0,.6-.1l1.1,2.4h-.9c-2.8,0-5.2,2.3-5.2,5.2v16.7c0,2.8,2.3,5.2,5.2,5.2h18.7c2.8,0,5.2-2.3,5.2-5.2V14.2c0-2.8-2.3-5.1-5.2-5.1Zm3.1,21.8c0,1.7-1.4,3.1-3.1,3.1H10.99c-1.7,0-3.1-1.4-3.1-3.1V14.2c0-1.7,1.4-3.1,3.1-3.1h18.7c1.7,0,3.1,1.4,3.1,3.1v16.7h-.1Z"
        />
      </g>
    </svg>
  );

  return (
    <ChatbotToggle
      tooltipLabel="Virtual assistant"
      isChatbotVisible={chatbotVisible}
      onToggleChatbot={() => setChatbotVisible(!chatbotVisible)}
      closedToggleIcon={closedToggleIcon}
    />
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/Settings.tsx
================================================
import React from 'react';

import SettingsForm from '@patternfly/chatbot/dist/dynamic/Settings';
import {
  Button,
  Divider,
  Dropdown,
  DropdownGroup,
  DropdownItem,
  DropdownList,
  MenuToggle,
  MenuToggleElement,
  Switch,
  Title
} from '@patternfly/react-core';
import Chatbot, { ChatbotDisplayMode } from '@patternfly/chatbot/dist/dynamic/Chatbot';
import ChatbotHeader, {
  ChatbotHeaderActions,
  ChatbotHeaderCloseButton,
  ChatbotHeaderMain,
  ChatbotHeaderOptionsDropdown,
  ChatbotHeaderTitle
} from '@patternfly/chatbot/dist/dynamic/ChatbotHeader';
import { CogIcon, ExpandIcon, OpenDrawerRightIcon, OutlinedWindowRestoreIcon } from '@patternfly/react-icons';

export const SettingsDemo: React.FunctionComponent = () => {
  const [isChecked, setIsChecked] = React.useState<boolean>(true);
  const [isThemeOpen, setIsThemeOpen] = React.useState(false);
  const [isLanguageOpen, setIsLanguageOpen] = React.useState(false);
  const [isVoiceOpen, setIsVoiceOpen] = React.useState(false);
  const [displayMode, setDisplayMode] = React.useState(ChatbotDisplayMode.default);
  const [areSettingsOpen, setAreSettingsOpen] = React.useState(true);
  const chatbotVisible = true;

  const onFocus = (id: string) => {
    const element = document.getElementById(id);
    (element as HTMLElement).focus();
  };

  const onThemeToggleClick = () => {
    setIsThemeOpen(!isThemeOpen);
  };

  const onThemeSelect = (
    _event: React.MouseEvent<Element, MouseEvent> | undefined,
    value: string | number | undefined
  ) => {
    // eslint-disable-next-line no-console
    console.log('selected', value);
    onFocus('theme');
    setIsThemeOpen(false);
  };

  const onLanguageToggleClick = () => {
    setIsLanguageOpen(!isLanguageOpen);
  };

  const onLanguageSelect = (
    _event: React.MouseEvent<Element, MouseEvent> | undefined,
    value: string | number | undefined
  ) => {
    // eslint-disable-next-line no-console
    console.log('selected', value);
    onFocus('language');
    setIsLanguageOpen(false);
  };

  const onVoiceToggleClick = () => {
    onFocus('voice');
    setIsVoiceOpen(!isVoiceOpen);
  };

  const onVoiceSelect = (
    _event: React.MouseEvent<Element, MouseEvent> | undefined,
    value: string | number | undefined
  ) => {
    // eslint-disable-next-line no-console
    console.log('selected', value);
    setIsVoiceOpen(false);
  };

  const handleChange = (_event: React.FormEvent<HTMLInputElement>, checked: boolean) => {
    setIsChecked(checked);
  };

  const themeDropdown = (
    <Dropdown
      isOpen={isThemeOpen}
      onSelect={onThemeSelect}
      onOpenChange={(isOpen: boolean) => setIsThemeOpen(isOpen)}
      shouldFocusToggleOnSelect
      shouldFocusFirstItemOnOpen
      shouldPreventScrollOnItemFocus
      toggle={(toggleRef: React.Ref<MenuToggleElement>) => (
        // We want to add the id property here as well so the label is coupled
        // with the button on screen readers.
        <MenuToggle id="theme" ref={toggleRef} onClick={onThemeToggleClick} isExpanded={isThemeOpen}>
          System
        </MenuToggle>
      )}
      ouiaId="ThemeDropdown"
    >
      <DropdownList>
        <DropdownItem value="System" key="system">
          System
        </DropdownItem>
      </DropdownList>
    </Dropdown>
  );

  const languageDropdown = (
    <Dropdown
      isOpen={isLanguageOpen}
      onSelect={onLanguageSelect}
      onOpenChange={(isOpen: boolean) => setIsLanguageOpen(isOpen)}
      shouldFocusToggleOnSelect
      shouldFocusFirstItemOnOpen
      shouldPreventScrollOnItemFocus
      toggle={(toggleRef: React.Ref<MenuToggleElement>) => (
        // We want to add the id property here as well so the label is coupled
        // with the button on screen readers.
        <MenuToggle id="language" ref={toggleRef} onClick={onLanguageToggleClick} isExpanded={isLanguageOpen}>
          Auto-detect
        </MenuToggle>
      )}
      ouiaId="LanguageDropdown"
    >
      <DropdownList>
        <DropdownItem value="Auto-detect" key="auto-detect">
          Auto-detect
        </DropdownItem>
      </DropdownList>
    </Dropdown>
  );
  const voiceDropdown = (
    <Dropdown
      isOpen={isVoiceOpen}
      onSelect={onVoiceSelect}
      onOpenChange={(isOpen: boolean) => setIsVoiceOpen(isOpen)}
      shouldFocusToggleOnSelect
      shouldFocusFirstItemOnOpen
      shouldPreventScrollOnItemFocus
      toggle={(toggleRef: React.Ref<MenuToggleElement>) => (
        // We want to add the id property here as well so the label is coupled
        // with the button on screen readers.
        <MenuToggle id="voice" ref={toggleRef} onClick={onVoiceToggleClick} isExpanded={isVoiceOpen}>
          Bot
        </MenuToggle>
      )}
      ouiaId="VoiceDropdown"
    >
      <DropdownList>
        <DropdownItem value="Bot" key="bot">
          Bot
        </DropdownItem>
      </DropdownList>
    </Dropdown>
  );
  const children = [
    { id: 'theme', label: 'Theme', field: themeDropdown },
    { id: 'language', label: 'Language', field: languageDropdown },
    { id: 'voice', label: 'Voice', field: voiceDropdown },
    {
      id: 'analytics',
      label: 'Share analytics',
      field: (
        <Switch
          // We want to add the id property here as well so the label is coupled
          // with the button on screen readers.
          id="analytics"
          aria-label="Togglable option for whether to share analytics"
          isChecked={isChecked}
          onChange={handleChange}
        />
      )
    },
    {
      id: 'archived-chat',
      label: 'Archive chat',
      field: (
        // We want to add the id property here as well so the label is coupled
        // with the button on screen readers.
        <Button id="archived-chat" variant="secondary">
          Manage
        </Button>
      )
    },
    {
      id: 'archive-all',
      label: 'Archive all chat',
      field: (
        // We want to add the id property here as well so the label is coupled
        // with the button on screen readers.
        <Button id="archive-all" variant="secondary">
          Archive all
        </Button>
      )
    },
    {
      id: 'delete-all',
      label: 'Delete all chats',
      field: (
        // We want to add the id property here as well so the label is coupled
        // with the button on screen readers.
        <Button id="delete-all" variant="danger">
          Delete all
        </Button>
      )
    }
  ];

  const onSelectDropdownItem = (
    _event: React.MouseEvent<Element, MouseEvent> | undefined,
    value: string | number | undefined
  ) => {
    if (value === 'Settings') {
      setAreSettingsOpen(true);
    } else {
      setDisplayMode(value as ChatbotDisplayMode);
    }
  };

  const regularChatbot = (
    <ChatbotHeader>
      <ChatbotHeaderActions>
        <ChatbotHeaderOptionsDropdown onSelect={onSelectDropdownItem}>
          <DropdownGroup label="Display mode">
            <DropdownList>
              <DropdownItem
                value={ChatbotDisplayMode.default}
                key="switchDisplayOverlay"
                icon={<OutlinedWindowRestoreIcon aria-hidden />}
                isSelected={displayMode === ChatbotDisplayMode.default}
              >
                <span>Overlay</span>
              </DropdownItem>
              <DropdownItem
                value={ChatbotDisplayMode.docked}
                key="switchDisplayDock"
                icon={<OpenDrawerRightIcon aria-hidden />}
                isSelected={displayMode === ChatbotDisplayMode.docked}
              >
                <span>Dock to window</span>
              </DropdownItem>
              <DropdownItem
                value={ChatbotDisplayMode.fullscreen}
                key="switchDisplayFullscreen"
                icon={<ExpandIcon aria-hidden />}
                isSelected={displayMode === ChatbotDisplayMode.fullscreen}
              >
                <span>Fullscreen</span>
              </DropdownItem>
            </DropdownList>
          </DropdownGroup>
          <Divider />
          <DropdownList>
            <DropdownItem value="Settings" key="switchSettings" icon={<CogIcon aria-hidden />}>
              <span>Settings</span>
            </DropdownItem>
          </DropdownList>
        </ChatbotHeaderOptionsDropdown>
      </ChatbotHeaderActions>
    </ChatbotHeader>
  );

  return (
    <>
      <Chatbot isVisible={chatbotVisible} displayMode={displayMode}>
        {areSettingsOpen ? (
          <>
            <ChatbotHeader>
              <ChatbotHeaderMain>
                <ChatbotHeaderTitle>
                  <Title headingLevel="h1" size="2xl">
                    Settings
                  </Title>
                </ChatbotHeaderTitle>
              </ChatbotHeaderMain>
              <ChatbotHeaderCloseButton onClick={() => setAreSettingsOpen(false)} />
            </ChatbotHeader>
            <SettingsForm fields={children} />
          </>
        ) : (
          <>{regularChatbot}</>
        )}
      </Chatbot>
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/SkipToContent.tsx
================================================
import React from 'react';

import { SkipToContent } from '@patternfly/react-core';
import ChatbotToggle from '@patternfly/chatbot/dist/dynamic/ChatbotToggle';
import Chatbot, { ChatbotDisplayMode } from '@patternfly/chatbot/dist/dynamic/Chatbot';

export const ChatbotDemo: React.FunctionComponent = () => {
  const [chatbotVisible, setChatbotVisible] = React.useState<boolean>(true);
  const toggleRef = React.useRef<HTMLButtonElement>(null);
  const chatbotRef = React.useRef<HTMLDivElement>(null);
  const displayMode = ChatbotDisplayMode.default;

  const handleSkipToContent = (e) => {
    e.preventDefault();
    if (!chatbotVisible && toggleRef.current) {
      toggleRef.current.focus();
    }
    if (chatbotVisible && chatbotRef.current) {
      chatbotRef.current.focus();
    }
  };

  return (
    <>
      <SkipToContent onClick={handleSkipToContent} href="#">
        Skip to chatbot
      </SkipToContent>
      <ChatbotToggle
        tooltipLabel="Chatbot"
        isChatbotVisible={chatbotVisible}
        onToggleChatbot={() => setChatbotVisible(!chatbotVisible)}
        id="chatbot-toggle"
        ref={toggleRef}
      />
      <Chatbot isVisible={chatbotVisible} displayMode={displayMode} ref={chatbotRef}>
        &nbsp;
      </Chatbot>
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/SquareChatbotToggle.tsx
================================================
import React from 'react';
import ChatbotToggle from '@patternfly/chatbot/dist/dynamic/ChatbotToggle';

export const SquareChatbotToggle: React.FunctionComponent = () => {
  const [chatbotVisible, setChatbotVisible] = React.useState<boolean>(false);
  return (
    <ChatbotToggle
      tooltipLabel="Chatbot"
      isChatbotVisible={chatbotVisible}
      onToggleChatbot={() => setChatbotVisible(!chatbotVisible)}
      isRound={false}
    />
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/TermsOfUse.tsx
================================================
import React from 'react';
import {
  Button,
  Checkbox,
  SkipToContent,
  MenuToggle,
  MenuToggleElement,
  Select,
  SelectList,
  SelectOption,
  Stack
} from '@patternfly/react-core';
import TermsOfUse from '@patternfly/chatbot/dist/dynamic/TermsOfUse';
import Chatbot, { ChatbotDisplayMode } from '@patternfly/chatbot/dist/dynamic/Chatbot';
import termsAndConditionsHeader from './PF-TermsAndConditionsHeader.svg';

export const TermsOfUseExample: React.FunctionComponent = () => {
  const [isModalOpen, setIsModalOpen] = React.useState(true);
  const [displayMode, setDisplayMode] = React.useState(ChatbotDisplayMode.default);
  const [hasImage, setHasImage] = React.useState(true);
  const chatbotRef = React.useRef<HTMLDivElement>(null);
  const termsRef = React.useRef<HTMLDivElement>(null);
  const [isOpen, setIsOpen] = React.useState(false);
  const [selected, setSelected] = React.useState<string>('Select display mode');

  const handleSkipToContent = (e) => {
    e.preventDefault();
    if (!isModalOpen && chatbotRef.current) {
      chatbotRef.current.focus();
    }
    if (isModalOpen && termsRef.current) {
      termsRef.current.focus();
    }
  };

  const handleModalToggle = (_event: React.MouseEvent | MouseEvent | KeyboardEvent) => {
    setIsModalOpen(!isModalOpen);
  };

  const onPrimaryAction = () => {
    // eslint-disable-next-line no-console
    console.log('Clicked primary action');
  };

  const onSecondaryAction = () => {
    // eslint-disable-next-line no-console
    console.log('Clicked secondary action');
  };
  const onSelect = (_event: React.MouseEvent<Element, MouseEvent> | undefined, value: string | number | undefined) => {
    setSelected(value as string);
    setIsOpen(false);
    if (value === 'Default') {
      setDisplayMode(ChatbotDisplayMode.default);
    }
    if (value === 'Docked') {
      setDisplayMode(ChatbotDisplayMode.docked);
    }
    if (value === 'Fullscreen') {
      setDisplayMode(ChatbotDisplayMode.fullscreen);
    }
    if (value === 'Embedded') {
      setDisplayMode(ChatbotDisplayMode.embedded);
    }
  };

  const onToggleClick = () => {
    setIsOpen(!isOpen);
  };

  const toggle = (toggleRef: React.Ref<MenuToggleElement>) => (
    <MenuToggle
      ref={toggleRef}
      onClick={onToggleClick}
      isExpanded={isOpen}
      style={
        {
          width: '200px'
        } as React.CSSProperties
      }
    >
      {selected}
    </MenuToggle>
  );

  const introduction = (
    <>
      <p>
        Welcome to PatternFly! These terms and conditions outline the rules and regulations for the use of PatternFly's
        website, located at <a href="https://patternfly.org">www.patternfly.org.</a>
      </p>
      <p>
        By accessing this website, you are agreeing with our terms and conditions. If you do not agree to all of these
        terms and conditions, do not continue to use PatternFly.
      </p>
    </>
  );

  const terminology = (
    <>
      <p>
        The following terminology applies to these Terms and Conditions, Privacy Statement, Disclaimer Notice, and all
        Agreements:
      </p>
      <ul>
        <li>
          "Client", "You", and "Your" refer to you, the person using this website who is compliant with the Company's
          terms and conditions.
        </li>
        <li>
          "The Company", "Ourselves", "We", "Our", and "Us", refer to our Company. "Party", "Parties", or "Us", refers
          to both the Client and ourselves.
        </li>
      </ul>
    </>
  );

  const body = (
    <>
      <h2>Introduction</h2>
      {introduction}
      <h2>Terminology</h2>
      {terminology}
    </>
  );

  return (
    <>
      <SkipToContent style={{ zIndex: '999' }} onClick={handleSkipToContent} href="#">
        Skip to chatbot
      </SkipToContent>
      <div
        style={{
          position: 'fixed',
          padding: 'var(--pf-t--global--spacer--lg)',
          zIndex: '601',
          boxShadow: 'var(--pf-t--global--box-shadow--lg)'
        }}
      >
        <Stack hasGutter>
          <Select
            id="single-select"
            isOpen={isOpen}
            selected={selected}
            onSelect={onSelect}
            onOpenChange={(isOpen) => setIsOpen(isOpen)}
            toggle={toggle}
            shouldFocusToggleOnSelect
          >
            <SelectList>
              <SelectOption value="Default">Default</SelectOption>
              <SelectOption value="Docked">Docked</SelectOption>
              <SelectOption value="Fullscreen">Fullscreen</SelectOption>
              <SelectOption value="Embedded">Embedded</SelectOption>
            </SelectList>
          </Select>
          <Checkbox
            isChecked={hasImage}
            aria-label="Toggle whether terms and conditions has a header image"
            id="toggle-header-image"
            name="toggle-header-image"
            label="Has image in header"
            onChange={(_event, checked) => setHasImage(checked)}
          ></Checkbox>
          <Button onClick={handleModalToggle}>Launch modal</Button>
        </Stack>
      </div>
      <Chatbot ref={chatbotRef} displayMode={displayMode} isVisible></Chatbot>
      <TermsOfUse
        ref={termsRef}
        displayMode={displayMode}
        isModalOpen={isModalOpen}
        handleModalToggle={handleModalToggle}
        onPrimaryAction={onPrimaryAction}
        onSecondaryAction={onSecondaryAction}
        image={hasImage ? termsAndConditionsHeader : undefined}
        altText={hasImage ? 'Open book' : undefined}
      >
        {body}
      </TermsOfUse>
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/TermsOfUseCompact.tsx
================================================
import React from 'react';
import {
  Button,
  SkipToContent,
  MenuToggle,
  MenuToggleElement,
  Select,
  SelectList,
  SelectOption,
  Stack
} from '@patternfly/react-core';
import TermsOfUse from '@patternfly/chatbot/dist/dynamic/TermsOfUse';
import Chatbot, { ChatbotDisplayMode } from '@patternfly/chatbot/dist/dynamic/Chatbot';

export const TermsOfUseCompactExample: React.FunctionComponent = () => {
  const [isModalOpen, setIsModalOpen] = React.useState(true);
  const [displayMode, setDisplayMode] = React.useState(ChatbotDisplayMode.default);
  const chatbotRef = React.useRef<HTMLDivElement>(null);
  const termsRef = React.useRef<HTMLDivElement>(null);
  const [isOpen, setIsOpen] = React.useState(false);
  const [selected, setSelected] = React.useState<string>('Select display mode');

  const handleSkipToContent = (e) => {
    e.preventDefault();
    if (!isModalOpen && chatbotRef.current) {
      chatbotRef.current.focus();
    }
    if (isModalOpen && termsRef.current) {
      termsRef.current.focus();
    }
  };

  const handleModalToggle = (_event: React.MouseEvent | MouseEvent | KeyboardEvent) => {
    setIsModalOpen(!isModalOpen);
  };

  const onPrimaryAction = () => {
    // eslint-disable-next-line no-console
    console.log('Clicked primary action');
  };

  const onSecondaryAction = () => {
    // eslint-disable-next-line no-console
    console.log('Clicked secondary action');
  };

  const onSelect = (_event: React.MouseEvent<Element, MouseEvent> | undefined, value: string | number | undefined) => {
    setSelected(value as string);
    setIsOpen(false);
    if (value === 'Default') {
      setDisplayMode(ChatbotDisplayMode.default);
    }
    if (value === 'Docked') {
      setDisplayMode(ChatbotDisplayMode.docked);
    }
    if (value === 'Fullscreen') {
      setDisplayMode(ChatbotDisplayMode.fullscreen);
    }
    if (value === 'Embedded') {
      setDisplayMode(ChatbotDisplayMode.embedded);
    }
  };

  const onToggleClick = () => {
    setIsOpen(!isOpen);
  };

  const toggle = (toggleRef: React.Ref<MenuToggleElement>) => (
    <MenuToggle
      ref={toggleRef}
      onClick={onToggleClick}
      isExpanded={isOpen}
      style={
        {
          width: '200px'
        } as React.CSSProperties
      }
    >
      {selected}
    </MenuToggle>
  );

  const introduction = (
    <>
      <p>
        Welcome to PatternFly! These terms and conditions outline the rules and regulations for the use of PatternFly's
        website, located at <a href="https://patternfly.org">www.patternfly.org.</a>
      </p>
      <p>
        By accessing this website, you are agreeing with our terms and conditions. If you do not agree to all of these
        terms and conditions, do not continue to use PatternFly.
      </p>
    </>
  );

  const terminology = (
    <>
      <p>
        The following terminology applies to these Terms and Conditions, Privacy Statement, Disclaimer Notice, and all
        Agreements:
      </p>
      <ul>
        <li>
          "Client", "You", and "Your" refer to you, the person using this website who is compliant with the Company's
          terms and conditions.
        </li>
        <li>
          "The Company", "Ourselves", "We", "Our", and "Us", refer to our Company. "Party", "Parties", or "Us", refers
          to both the Client and ourselves.
        </li>
      </ul>
    </>
  );

  const body = (
    <>
      <h2>Introduction</h2>
      {introduction}
      <h2>Terminology</h2>
      {terminology}
    </>
  );

  return (
    <>
      <SkipToContent style={{ zIndex: '999' }} onClick={handleSkipToContent} href="#">
        Skip to chatbot
      </SkipToContent>
      <div
        style={{
          position: 'fixed',
          padding: 'var(--pf-t--global--spacer--lg)',
          zIndex: '601',
          boxShadow: 'var(--pf-t--global--box-shadow--lg)'
        }}
      >
        <Stack hasGutter>
          <Select
            id="single-select"
            isOpen={isOpen}
            selected={selected}
            onSelect={onSelect}
            onOpenChange={(isOpen) => setIsOpen(isOpen)}
            toggle={toggle}
            shouldFocusToggleOnSelect
          >
            <SelectList>
              <SelectOption value="Default">Default</SelectOption>
              <SelectOption value="Docked">Docked</SelectOption>
              <SelectOption value="Fullscreen">Fullscreen</SelectOption>
              <SelectOption value="Embedded">Embedded</SelectOption>
            </SelectList>
          </Select>
          <Button onClick={handleModalToggle}>Launch modal</Button>
        </Stack>
      </div>
      <Chatbot ref={chatbotRef} displayMode={displayMode} isVisible></Chatbot>
      <TermsOfUse
        ref={termsRef}
        displayMode={displayMode}
        isModalOpen={isModalOpen}
        handleModalToggle={handleModalToggle}
        onPrimaryAction={onPrimaryAction}
        onSecondaryAction={onSecondaryAction}
        isCompact
      >
        {body}
      </TermsOfUse>
    </>
  );
};



================================================
FILE: packages/module/patternfly-docs/content/extensions/chatbot/examples/UI/UI.md
================================================
---
# Sidenav top-level section
# should be the same for all markdown files
section: PatternFly-AI
subsection: ChatBot
# Sidenav secondary level section
# should be the same for all markdown files
id: UI
# Tab (react | react-demos | html | html-demos | design-guidelines | accessibility)
source: react
# If you use typescript, the name of the interface to display props for
# These are found through the sourceProps function provided in patternfly-docs.source.js
propComponents:
  [
    'Chatbot',
    'ChatbotContent',
    'MessageBox',
    'ChatbotWelcomePrompt',
    'WelcomePrompt',
    'ChatbotToggle',
    'ChatbotHeader',
    'ChatbotHeaderMain',
    'ChatbotHeaderMenu',
    'ChatbotHeaderActions',
    'ChatbotHeaderTitle',
    'ChatbotHeaderOptionsDropdown',
    'ChatbotHeaderSelectorDropdown',
    'ChatbotFooter',
    'MessageBar',
    'ChatbotFootnote',
    'ChatbotFootnotePopover',
    'ChatbotFootnotePopoverCTA',
    'ChatbotFootnotePopoverBannerImage',
    'ChatbotFootnotePopoverLink',
    'MessageBarWithAttachMenuProps',
    'SourceDetailsMenuItem',
    'ChatbotConversationHistoryNav',
    'Conversation'
  ]
sortValue: 2
---

import Chatbot, { ChatbotDisplayMode } from '@patternfly/chatbot/dist/dynamic/Chatbot';
import ChatbotContent from '@patternfly/chatbot/dist/dynamic/ChatbotContent';
import ChatbotWelcomePrompt from '@patternfly/chatbot/dist/dynamic/ChatbotWelcomePrompt';
import MessageBox from '@patternfly/chatbot/dist/dynamic/MessageBox';
import ChatbotToggle from '@patternfly/chatbot/dist/dynamic/ChatbotToggle';
import Message from '@patternfly/chatbot/dist/dynamic/Message';
import AttachmentEdit from '@patternfly/chatbot/dist/dynamic/AttachmentEdit';
import FileDetails from '@patternfly/chatbot/dist/dynamic/FileDetails';
import FileDetailsLabel from '@patternfly/chatbot/dist/dynamic/FileDetailsLabel';
import FileDropZone from '@patternfly/chatbot/dist/dynamic/FileDropZone';
import { PreviewAttachment } from '@patternfly/chatbot/dist/dynamic/PreviewAttachment';
import ChatbotAlert from '@patternfly/chatbot/dist/dynamic/ChatbotAlert';
import TermsOfUse from '@patternfly/chatbot/dist/dynamic/TermsOfUse';
import {
ChatbotHeader,
ChatbotHeaderCloseButton,
ChatbotHeaderMain,
ChatbotHeaderMenu,
ChatbotHeaderActions,
ChatbotHeaderTitle,
ChatbotHeaderOptionsDropdown,
ChatbotHeaderSelectorDropdown
} from '@patternfly/chatbot/dist/dynamic/ChatbotHeader';
import { ChatbotFooter, ChatbotFootnote } from '@patternfly/chatbot/dist/dynamic/ChatbotFooter';
import { MessageBar } from '@patternfly/chatbot/dist/dynamic/MessageBar';
import SourceDetailsMenuItem from '@patternfly/chatbot/dist/dynamic/SourceDetailsMenuItem';
import { ChatbotModal } from '@patternfly/chatbot/dist/dynamic/ChatbotModal';
import SettingsForm from '@patternfly/chatbot/dist/dynamic/Settings';
import { BellIcon, CalendarAltIcon, ClipboardIcon, CodeIcon, UploadIcon } from '@patternfly/react-icons';
import { useDropzone } from 'react-dropzone';

import ChatbotConversationHistoryNav from '@patternfly/chatbot/dist/dynamic/ChatbotConversationHistoryNav';
import { DropdownItem, DropdownList, Checkbox } from '@patternfly/react-core';

import OutlinedWindowRestoreIcon from '@patternfly/react-icons/dist/esm/icons/outlined-window-restore-icon';
import ExpandIcon from '@patternfly/react-icons/dist/esm/icons/expand-icon';
import OpenDrawerRightIcon from '@patternfly/react-icons/dist/esm/icons/open-drawer-right-icon';
import CogIcon from '@patternfly/react-icons/dist/esm/icons/cog-icon';
import PFHorizontalLogoColor from './PF-HorizontalLogo-Color.svg';
import PFHorizontalLogoReverse from './PF-HorizontalLogo-Reverse.svg';
import userAvatar from '../Messages/user_avatar.svg';
import patternflyAvatar from '../Messages/patternfly_avatar.jpg';
import termsAndConditionsHeader from './PF-TermsAndConditionsHeader.svg';
import { CloseIcon, SearchIcon, OutlinedCommentsIcon } from '@patternfly/react-icons';

## Structure

### Container

The PatternFly ChatBot is a separate window that overlays or is embedded within other UI content. This container can be shown and hidden via [the ChatBot toggle.](/patternfly-ai/chatbot/ui#toggle)

The `<Chatbot>` component is the container that encompasses the ChatBot experience. It adapts to various display modes (overlay/default, docked, fullscreen, and embedded) and supports both light and dark themes.

The "embedded" display mode is meant to be used within a [PatternFly page](/components/page) or other container within your product.

```js file="./ChatbotContainer.tsx" isFullscreen

```

### Content and message box

The `<ChatbotContent>` component is the container that is placed within the `<Chatbot>`, between the [`<ChatbotHeader>`](/patternfly-ai/chatbot/ui#header) and [`<ChatbotFooter>`.](/patternfly-ai/chatbot/ui#footer)

`<ChatbotContent>` usually contains a `<ChatbotMessageBox>` for displaying messages.

Your code structure should look like this:

```noLive
<Chatbot>
  <ChatbotHeader ... />
  <ChatbotContent>
    <ChatbotMessageBox>
    ...
    <ChatbotMessageBox>
  </ChatbotContent>
  <ChatbotFooter ... />
</Chatbot>
```

**Note**: When messages update, it is important to announce new messages to users of assistive technology. To do this, make sure to set the `announcement` prop on `<MessageBox>` whenever you display a new message in `<MessageBox>`. You can view this in action in our [basic ChatBot](/patternfly-ai/chatbot/overview/demo#basic-chatbot) and [embedded ChatBot](/patternfly-ai/chatbot/overview/demo#embedded-chatbot) demos.

### Welcome message

To introduce users to the ChatBot experience, display a welcome message before they input their first message. This brief message should follow our [conversation design guidelines](/patternfly-ai/conversation-design) to welcome users to the ChatBot experience and encourage them to interact.

This message can be dismissed once a user sends their first message. To change the arrangement of the message within the message box, specify the `position` in the `<MessageBox>` component.

```js file="./ChatbotWelcomeInteraction.tsx" isFullscreen

```

### Welcome prompt

To provide users with a more specific direction, you can also include optional welcome prompts.

```js file="./ChatbotWelcomePrompt.tsx"

```

### Skip to content

To provide page context, we recommend using a "Skip to chatbot" button. This allows you to skip past other content on the page, directly to the ChatBot content, using a [PatternFly skip to content component](/components/skip-to-content). To display this button, you must tab into the main window.

When using default or docked modes, we recommend putting focus on the toggle if the ChatBot is closed, and the ChatBot when it is open. For fullscreen and embedded, we recommend putting the focus on the first focusable item in the ChatBot, such as a menu toggle. This can be seen in our more fully-featured demos for the [default, embedded, and fullscreen ChatBot](/patternfly-ai/chatbot/overview/demo#basic-chatbot) and the [embedded ChatBot](/patternfly-ai/chatbot/overview/demo#embedded-chatbot).

```js file="./SkipToContent.tsx" isFullscreen

```

## Toggle

### Basic toggle

To allow users to open and close the ChatBot window as needed, add a toggle.

```js file="./ChatbotToggleBasic.tsx" isFullscreen

```

### Custom toggle icon

A custom icon can be passed to the toggle. To ensure the icon is visible in both light and dark themes, use an SVG image and set `fill="currentColor"`.

```js file="./CustomClosedIcon.tsx" isFullscreen

```

### Custom toggle shape

A custom shape can be set for the toggle. To override the default circle shape, set `isRound` to `false`. This will set the toggle to a square shape, but you can pass in additional classes to further customize the shape.

```js file="./SquareChatbotToggle.tsx" isFullscreen

```

## Header

### Header sections

The ChatBot header is persistent, and contains the title for the ChatBot window, as well as any related controls and actions.

The `<ChatbotHeader>` has 2 sections:

- `<ChatbotHeaderMain>` contains the title and an optional menu toggle:
  - `<ChatbotHeaderTitle>` handles the layout and display of a title or image at different responsive sizes.
  - `<ChatbotHeaderMenu>` (optional) is placed on the left side of the header and used to toggle a chat history menu.
- `<ChatbotHeaderActions>` contains any additional controls:
  - The `<ChatbotHeaderSelectorDropdown>` component is a standard PatternFly dropdown that matches the ChatBot styles.
  - The `<ChatbotHeaderOptionsDropdown>` component is a dropdown with a menu toggle that is intended to be used to update ChatBot settings (like the display mode).

Your `<ChatbotHeader>` code structure should look like this:

```noLive
<ChatbotHeader>
  <ChatbotHeaderMain>
    <ChatbotHeaderMenu ... />
    <ChatbotHeaderTitle ... />
  </ChatbotHeaderMain>
  <ChatbotHeaderActions>
    <ChatbotHeaderSelectorDropdown ... />
    <ChatbotHeaderOptionsDropdown ... />
  </ChatbotHeaderActions>
</ChatbotHeader>
```

### Header title

By default, `<HeaderTitle>` renders any children that are passed in. Optionally, you can pass in a `displayMode`, `showOnEmbedded`, `showOnDocked`, `showOnFullScreen`, and/or `showOnDefault` to render content conditionally.

```js file="./ChatbotHeaderTitle.tsx"

```

### Header options

There are a variety of options and customizations you can make to the header, to adjust how information is displayed, or to add additional controls.

In this example, select the respective checkbox to toggle these features:

- **Menu:** Users can select the menu toggle to open a menu of additional options or actions.
- **Left-aligned logo**
- **Centered logo**
- **Selector dropdown:** Users can choose from preselected options in a dropdown menu. For example, they can toggle between AI models.
- **Options dropdown:** Users can select ChatBot options from a menu. For example, they can switch between ChatBot display modes.

```js file="./ChatbotHeaderBasic.tsx"

```

## Footer

### Footnote with popover

A footnote can be placed in the ChatBot footer to communicate any legal disclaimers or information about the ChatBot.
Footnotes can be static text or a button that opens a popover.

```js file="./ChatbotFootnote.tsx"

```

### Message bar with speech recognition and file attachment

In Safari and Chrome, you will see a microphone button in the message bar if `hasMicrophoneButton` is passed to `<MessageBar>`. The button will only appear if `'SpeechRecognition'` or `'webkitSpeechRecognition'` are available in `window`. This does not currently work in Firefox.

By default the message bar supports file uploads via an attach button. Setting `hasAttachButton` to `false` will disable that feature.

```js file="./ChatbotMessageBar.tsx"

```

### Message bar with speech recognition in a different language

Speech recognition defaults to en-US. You can update the locale as needed. Locale codes are a combination of the [ISO 639-1 language code](https://www.iso.org/iso-639-language-code) and the [ISO 3166-1 country code](https://www.iso.org/iso-3166-country-codes.html), separated by a hyphen.

In this example, the locale is set to to ja-JP. You can try it out by saying "hajimemashite" (初めまして).

```js file="./ChatbotMessageBarLanguage.tsx"

```

### Message bar with always-shown send button

By default, the send button is only shown once a user has entered a valid message. If you choose to keep the send button visible at all times, disable the button when there is no valid message to send.

To always show the send button in the message bar, use the `alwaysShowSendButton` prop. Use the `isSendButtonDisabled` prop to disable the button as needed. If you want to enable or disable the send button based on the presence of text in the message bar, you can detect text via the `onChange` prop for `<MessageBar>`.

To disable the send button in the following example, select the "Disable send button" checkbox. When the button is disabled, you also cannot send via the enter key.

```js file="./ChatbotMessageBarDisabled.tsx"

```

### Message bar with attach menu appended to attach button

You can change the behavior of the attach button to open a menu, rather than the default file viewer for your operating system. This menu can display different actions related to attachments.

Attachments can also be added to the ChatBot via [drag and drop.](/patternfly-ai/chatbot/messages#attachment-dropzone)

```js file="./ChatbotMessageBarAttach.tsx"

```

### Footer with message bar and footnote

A simple footer with a message bar and footnote would have this code structure:

```noLive
<ChatbotFooter>
  <MessageBar ... />
  <ChatbotFootnote .../>
</ChatbotFooter>
```

```js file="./ChatbotFooter.tsx"

```

### Message bar with stop button

If you are using streaming, you can add a stop button to the message bar that allows users to stop a response from a ChatBot.

To enable the stop button, set `hasStopButton` to `true` and pass in a `handleStopButton` callback function. You can use this callback to trigger an [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) configured as part of your API call.

```js file="./ChatbotMessageBarStop.tsx"

```

## Navigation

### Side nav in a drawer

The ChatBot conversation history is contained in an interactive drawer, where users can interact with previous conversations or start a new conversation.

The `<ChatbotConversationHistoryNav>` component is a wrapper placed within `<Chatbot>`, which contains all other ChatBot components in `drawerContent`. There is a focus trap so users can only tab within the drawer while it is open.

The code structure will look like this:

```noLive
<Chatbot>
  <ChatbotConversationHistoryNav
    ...
    drawerContent={
        <>
            <ChatbotContent>
                <ChatbotMessageBox>
                ...
                <ChatbotMessageBox>
            </ChatbotContent>
            <ChatbotFooter ... />
        </>
    }>
  </ChatbotConversationHistoryNav>
</Chatbot>
```

The conversation history drawer looks different depending on the `displayMode` of the parent `<Chatbot>`. (As shown in the [main ChatBot demo](/patternfly-ai/chatbot/overview/demo#basic-chatbot).):

- `Default` and `docked` display modes display the conversation history on top of the rest of the ChatBot content, with a PatternFly backdrop between the drawer panel and drawer content.
- `Fullscreen` and `embedded` display modes display the conversation history in line with the drawer content.

### Drawer with search and "new chat" button

In the conversation history drawer, users can search previous ChatBot conversations via an input field. To customize the placeholder text, use `searchInputPlaceholder`. Provide an aria label via `searchInputAriaLabel`.

They can also start new conversations via a "New chat" button. To customize the button label, use `newChatButtonText`.

Both the search input field and "New chat" buttons are optional. The `reverseButtonOrder` prop allows you to invert the positions of the Close and "New chat" buttons within the drawer when set to `true`.

```js file="./ChatbotHeaderDrawer.tsx"

```

### Drawer with conversation actions

Actions can be added to conversations with `menuItems`. Optionally, you can also add a `className` to the menu via `menuClassName`, change the default aria-label and tooltip content via `label`, or add an `onSelect` callback for when a user selects an item.

```js file="./ChatbotHeaderDrawerWithActions.tsx"

```

### Drawer with active conversation

If you're showing a conversation that is already active, you can set the `activeItemId` prop on your `<ChatbotConversationHistoryNav>` to apply an active visual state.

```js file="./ChatbotHeaderDrawerWithSelection.tsx"

```

### Resizable drawer

By default, the conversation history drawer has a fixed width (384px) and a focus trap. To provide users with more flexibility as they navigate their conversation history, or to better support embedded ChatBots on tablet-sized devices or smaller browser windows, you can instead make the drawer resizable. By default, even resizable drawers will still open to their full width on mobile devices.

In this example, the drawer can be resized up to the max size of the parent and resized down to 200px wide. To customize this behavior further (including width, style, and focus behavior) use PatternFly [`<Drawer>` props](/components/drawer#props), [`<DrawerPanelContent>` props](/components/drawer/#drawerpanelcontent), or any other drawer subcomponents.

```js file="./ChatbotHeaderDrawerResizable.tsx"

```

### Drawer with simple menu

The drawer can also be used to display a list of basic menu items.

```js file="./ChatbotHeaderDrawerNavigation.tsx"

```

### Terms of use

Based on the [PatternFly modal](/components/modal), this modal adapts to the ChatBot display mode and is meant to display terms and conditions for using a ChatBot in your project. The image in the header can be toggled on or off depending on whether the `image` and `altText` props are provided.

This example also includes an example of how to use [skip to content](/patternfly-ai/chatbot/ui#skip-to-content). When the terms of use modal is open, focus is placed on the terms of use container. When it is closed, focus is placed on the ChatBot. In a real example with a functioning ChatBot toggle, you would also want to place focus on the toggle when appropriate.

```js file="./TermsOfUse.tsx" isFullscreen

```

### Compact terms of use

To apply compact styling to the terms of use modal, pass `isCompact` to `<TermsOfUse>`. This will remove the header image and adjust the spacing of text, so that there is less white space in the modal.
```js file="./TermsOfUseCompact.tsx" isFullscreen

```

### Settings

To contain user preference controls and other ChatBot setting options, you can create a separate settings page that can accept any number of buttons, dropdown menus, toggles, labels, and so on. This settings page will render all components appropriately within all 4 display modes.

In this demo, you can toggle the settings page by clicking the "Settings" button in the display mode menu.

```js file="./Settings.tsx" isFullscreen

```

### Compact settings

To make the settings menu compact, with less spacing between the menu contents, pass `isCompact` to the `<SettingsForm>`.
```js file="./CompactSettings.tsx" isFullscreen

```

## Modals

### Modal

Based on the [PatternFly modal](/components/modal), this modal adapts to the ChatBot display mode and accepts components typically used in a modal. It is primarily used and tested in the context of the attachment modals, but you can customize this modal to adapt it to other use cases as needed. The modal will overlay the ChatBot in default and docked modes, and will behave more like a traditional PatternFly modal in fullscreen and embedded modes.

```js file="./ChatbotModal.tsx" isFullscreen

```







================================================
FILE: packages/module/patternfly-docs/pages/index.js
================================================
import React from 'react';
import { Title, PageSection } from '@patternfly/react-core';

const centerStyle = {
  flexGrow: 1,
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center'
};

const IndexPage = () => {
  return (
    <PageSection variant="light" style={centerStyle}>
      <div style={{ flex: 'none', textAlign: 'center' }}>
        <Title size="4xl" headingLevel="h1">
          My extension docs
        </Title>
        <Title size="2xl" headingLevel="h2">
          {'Hi people!'}
        </Title>
        <p>Welcome to my extension docs.</p>
      </div>
    </PageSection>
  );
};

export default IndexPage;



================================================
FILE: packages/module/src/index.ts
================================================
// this file is autogenerated by generate-index.js, modifying it manually will have no effect

export { default as AttachmentEdit } from './AttachmentEdit';
export * from './AttachmentEdit';

export { default as AttachMenu } from './AttachMenu';
export * from './AttachMenu';

export { default as Chatbot } from './Chatbot';
export * from './Chatbot';

export { default as ChatbotAlert } from './ChatbotAlert';
export * from './ChatbotAlert';

export { default as ChatbotContent } from './ChatbotContent';
export * from './ChatbotContent';

export { default as ChatbotConversationHistoryNav } from './ChatbotConversationHistoryNav';
export * from './ChatbotConversationHistoryNav';

export { default as ChatbotFooter } from './ChatbotFooter';
export * from './ChatbotFooter';

export { default as ChatbotHeader } from './ChatbotHeader';
export * from './ChatbotHeader';

export { default as ChatbotModal } from './ChatbotModal';
export * from './ChatbotModal';

export { default as ChatbotPopover } from './ChatbotPopover';
export * from './ChatbotPopover';

export { default as ChatbotToggle } from './ChatbotToggle';
export * from './ChatbotToggle';

export { default as ChatbotWelcomePrompt } from './ChatbotWelcomePrompt';
export * from './ChatbotWelcomePrompt';

export { default as CodeModal } from './CodeModal';
export * from './CodeModal';

export { default as Compare } from './Compare';
export * from './Compare';

export { default as FileDetails } from './FileDetails';
export * from './FileDetails';

export { default as FileDetailsLabel } from './FileDetailsLabel';
export * from './FileDetailsLabel';

export { default as FileDropZone } from './FileDropZone';
export * from './FileDropZone';

export { default as LoadingMessage } from './LoadingMessage';
export * from './LoadingMessage';

export { default as Message } from './Message';
export * from './Message';

export { default as MessageBar } from './MessageBar';
export * from './MessageBar';

export { default as MessageBox } from './MessageBox';
export * from './MessageBox';

export { default as PreviewAttachment } from './PreviewAttachment';
export * from './PreviewAttachment';

export { default as ResponseActions } from './ResponseActions';
export * from './ResponseActions';

export { default as Settings } from './Settings';
export * from './Settings';

export { default as SourceDetailsMenuItem } from './SourceDetailsMenuItem';
export * from './SourceDetailsMenuItem';

export { default as SourcesCard } from './SourcesCard';
export * from './SourcesCard';

export { default as TermsOfUse } from './TermsOfUse';
export * from './TermsOfUse';

export { default as tracking } from './tracking';
export * from './tracking';



================================================
FILE: packages/module/src/main.scss
================================================
@import './AttachMenu/AttachMenu';
@import './Chatbot/Chatbot';
@import './ChatbotAlert/ChatbotAlert';
@import './ChatbotContent/ChatbotContent';
@import './ChatbotConversationHistoryNav/ChatbotConversationHistoryNav';
@import './ChatbotFooter/ChatbotFooter';
@import './ChatbotHeader/ChatbotHeader';
@import './ChatbotModal/ChatbotModal';
@import './ChatbotPopover/ChatbotPopover';
@import './ChatbotToggle/ChatbotToggle';
@import './ChatbotWelcomePrompt/ChatbotWelcomePrompt';
@import './CodeModal/CodeModal';
@import './Compare/Compare';
@import './FileDetails/FileDetails';
@import './FileDetailsLabel/FileDetailsLabel';
@import './FileDropZone/FileDropZone';
@import './Message/Message';
@import './Message/CodeBlockMessage/CodeBlockMessage';
@import './Message/ImageMessage/ImageMessage';
@import './Message/TextMessage/TextMessage';
@import './Message/ListMessage/ListMessage';
@import './Message/TableMessage/TableMessage';
@import './Message/MessageLoading';
@import './Message/QuickStarts/QuickStartTile';
@import './Message/QuickResponse/QuickResponse';
@import './Message/UserFeedback/UserFeedback';
@import './MessageBar/MessageBar';
@import './MessageBox/MessageBox';
@import './MessageBox/JumpButton';
@import './ResponseActions/ResponseActions';
@import './Settings/Settings';
@import './SourcesCard/SourcesCard.scss';
@import './SourceDetailsMenuItem/SourceDetailsMenuItem';
@import './TermsOfUse/TermsOfUse';

:where(:root) {
  // ============================================================================
  // Chatbot Custom Default Tokens
  // ============================================================================

  --pf-t--chatbot--heading--font-family: var(
    --pf-v6-c-content--heading--FontFamily,
    redhatdisplayvf,
    redhatdisplay,
    helvetica,
    arial,
    sans-serif
  );

  --pf-t--chatbot--illustration--fill: var(--pf-t--color--red--50);
  --pf-t--chatbot--code--background: var(--pf-t--color--gray--20);

  --pf-t--chatbot-toggle--background--hover: var(--pf-t--color--gray--70);

  --pf-t--chatbot--blue-icon--background--color--hover: rgba(
    146,
    197,
    249,
    0.25
  ); // --pf-t--global--color--nonstatus--blue--default @ 25%
  --pf-t--chatbot--blue-icon--fill--hover: var(--pf-t--global--color--brand--hover);

  // ============================================================================
  // Chatbot Default tokens using PF semantic tokens
  // ============================================================================
  --pf-t--chatbot-toggle--color: var(--pf-t--global--icon--color--inverse);
  --pf-t--chatbot--background: var(--pf-t--global--background--color--secondary--default);
  --pf-t--chatbot--border: var(--pf-t--global--border--color--default);

  --pf-t--chatbot--icon--fill--active: var(--pf-t--global--text--color--regular);

  --pf-t--chatbot--blue-icon--fill: var(--pf-t--global--color--brand--default);
}

// ============================================================================
// Chatbot Custom Dark Theme Tokens
// ============================================================================
:where(.pf-v6-theme-dark) {
  --pf-t--chatbot--illustration--fill: var(--pf-t--color--white);
  --pf-t--chatbot--code--background: var(--pf-t--color--gray--60);

  --pf-t--chatbot-toggle--background--hover: var(--pf-t--color--gray--20);

  --pf-t--chatbot--blue-icon--background--color--hover: var(--pf-t--global--color--brand--hover);
  --pf-t--chatbot--blue-icon--fill--hover: var(--pf-t--global--icon--color--inverse);
}

.ws-full-page-utils {
  left: 0 !important;
  right: auto !important;
}



================================================
FILE: packages/module/src/__mocks__/rehype-external-links.ts
================================================
const rehypeExternalLinks = jest.fn((children) => children);

export default rehypeExternalLinks;



================================================
FILE: packages/module/src/__mocks__/rehype-sanitize.ts
================================================
const rehypeSanitize = jest.fn(() => null);

export default rehypeSanitize;



================================================
FILE: packages/module/src/__mocks__/rehype-unwrap-images.tsx
================================================
const rehypeUnwrapImages = jest.fn(() => null);

export default rehypeUnwrapImages;



================================================
FILE: packages/module/src/AttachmentEdit/AttachmentEdit.test.tsx
================================================
import React from 'react';
import { fireEvent, render, screen } from '@testing-library/react';
import AttachmentEdit, { AttachmentEditProps } from './AttachmentEdit';

describe('AttachmentEdit', () => {
  it('should open AttachmentEdit modal', () => {
    const props: AttachmentEditProps = {
      code: 'code',
      fileName: 'fileName',
      onCancel: jest.fn(),
      onSave: jest.fn(),
      isModalOpen: true,
      handleModalToggle: jest.fn()
    };

    render(<AttachmentEdit {...props} />);
    expect(screen.getByText('Edit attachment')).toBeTruthy();
  });

  it('should call onSave handler when the save button is clicked', () => {
    const onSaveHandler = jest.fn();
    const props: AttachmentEditProps = {
      code: 'code',
      fileName: 'fileName',
      onCancel: jest.fn(),
      onSave: onSaveHandler,
      isModalOpen: true,
      handleModalToggle: jest.fn()
    };

    render(<AttachmentEdit {...props} />);

    // Click on save button
    fireEvent.click(screen.getByText('Save'));
    expect(onSaveHandler).toHaveBeenCalledWith(expect.any(Object), 'code');
  });

  it('should call cancel handler when the cancel button is clicked', () => {
    const onCancelHandler = jest.fn();
    const props: AttachmentEditProps = {
      code: 'code',
      fileName: 'fileName',
      onCancel: onCancelHandler,
      onSave: jest.fn(),
      isModalOpen: true,
      handleModalToggle: jest.fn()
    };

    render(<AttachmentEdit {...props} />);

    // Click on cancel button
    fireEvent.click(screen.getByText('Cancel'));
    expect(onCancelHandler).toHaveBeenCalled();
  });
});



================================================
FILE: packages/module/src/AttachmentEdit/AttachmentEdit.tsx
================================================
// ============================================================================
// Attachment Edit - Chatbot Code Snippet Editor
// ============================================================================
import React from 'react';
import CodeModal from '../CodeModal';
import { ChatbotDisplayMode } from '../Chatbot';

export interface AttachmentEditProps {
  /** Text shown in code editor */
  code: string;
  /** Filename, including extension, of file shown in editor */
  fileName: string;
  /** Function that runs when cancel button is clicked  */
  onCancel: (event: React.MouseEvent | MouseEvent | KeyboardEvent) => void;
  /** Function that runs when save button is clicked; allows consumers to use the edited code string  */
  onSave: (event: React.MouseEvent | MouseEvent | KeyboardEvent, code: string) => void;
  /** Function that opens and closes modal */
  handleModalToggle: (event: React.MouseEvent | MouseEvent | KeyboardEvent) => void;
  /** Whether modal is open */
  isModalOpen: boolean;
  /** Title of modal */
  title?: string;
  /** Display mode for the Chatbot parent; this influences the styles applied */
  displayMode?: ChatbotDisplayMode;
  /** Sets modal to compact styling. */
  isCompact?: boolean;
}

export const AttachmentEdit: React.FunctionComponent<AttachmentEditProps> = ({
  fileName,
  code,
  handleModalToggle,
  isModalOpen,
  onCancel,
  onSave,
  title = 'Edit attachment',
  displayMode = ChatbotDisplayMode.default,
  isCompact
}: AttachmentEditProps) => {
  const handleSave = (_event: React.MouseEvent | MouseEvent | KeyboardEvent, code) => {
    handleModalToggle(_event);
    onSave(_event, code);
  };

  const handleCancel = (_event: React.MouseEvent | MouseEvent | KeyboardEvent) => {
    handleModalToggle(_event);
    onCancel(_event);
  };

  return (
    <CodeModal
      code={code}
      fileName={fileName}
      handleModalToggle={handleModalToggle}
      isModalOpen={isModalOpen}
      onPrimaryAction={handleSave}
      onSecondaryAction={handleCancel}
      primaryActionBtn="Save"
      secondaryActionBtn="Cancel"
      title={title}
      displayMode={displayMode}
      isCompact={isCompact}
    />
  );
};

export default AttachmentEdit;



================================================
FILE: packages/module/src/AttachmentEdit/index.ts
================================================
export { default } from './AttachmentEdit';

export * from './AttachmentEdit';



================================================
FILE: packages/module/src/AttachMenu/AttachMenu.scss
================================================
.pf-chatbot__menu.pf-v6-c-menu {
  --pf-v6-c-menu--BorderRadius: var(--pf-t--global--border--radius--large);
  --pf-v6-c-menu__list-item--hover--BackgroundColor: var(--pf-t--global--background--color--secondary--default);
}

.pf-chatbot__menu {
  /* search input */
  .pf-v6-c-text-input-group {
    --pf-v6-c-text-input-group__text--BorderStartStartRadius: var(--pf-t--global--border--radius--pill);
    --pf-v6-c-text-input-group__text--BorderStartEndRadius: var(--pf-t--global--border--radius--pill);
    --pf-v6-c-text-input-group__text--BorderEndStartRadius: var(--pf-t--global--border--radius--pill);
    --pf-v6-c-text-input-group__text--BorderEndEndRadius: var(--pf-t--global--border--radius--pill);
  }
  .pf-v6-c-text-input-group__text-input:focus-visible {
    border-radius: var(--pf-t--global--border--radius--pill);
  }

  .pf-v6-c-menu__group {
    /* there is spacing between groups because of this normally, even if there's no title */
    .pf-v6-c-menu__group-title {
      height: 0;
      --pf-v6-c-menu__group-title--PaddingBlockStart: var(--pf-t--global--spacer--sm);
      --pf-v6-c-menu__group-title--PaddingBlockEnd: 0;
      --pf-v6-c-menu__group-title--PaddingInlineStart: 0;
      --pf-v6-c-menu__group-title--PaddingInlineEnd: 0;
    }
  }

  /* spacing between icon and text in menu item */
  .pf-v6-c-menu__item-main {
    --pf-v6-c-menu__item-main--ColumnGap: var(--pf-t--global--spacer--md);
  }

  .pf-v6-c-menu__list {
    padding: 0rem var(--pf-t--global--spacer--md) 0rem var(--pf-t--global--spacer--md);
  }

  /* handles hover state, which uses a background */
  .pf-v6-c-menu__list-item {
    border-radius: var(--pf-t--global--border--radius--small);
    overflow: hidden;
  }

  .pf-v6-c-menu__item {
    padding-inline-start: var(--pf-t--global--spacer--md);
    padding-inline-end: var(--pf-t--global--spacer--md);
  }

  .pf-v6-c-menu__item-icon {
    display: flex;
    justify-content: center;
    width: 21px;
  }

  .pf-v6-c-menu__item-description {
    font-weight: var(--pf-t--global--font--weight--body--bold);
  }

  .pf-v6-c-divider {
    padding: 0 var(--pf-t--global--spacer--md) 0 var(--pf-t--global--spacer--md);
  }
}



================================================
FILE: packages/module/src/AttachMenu/AttachMenu.tsx
================================================
// ============================================================================
// Chatbot Attachment Menu
// ============================================================================
import React from 'react';

// Import PatternFly components
import {
  MenuSearch,
  MenuSearchInput,
  SearchInput,
  DropdownProps,
  Dropdown,
  DropdownToggleProps,
  DropdownPopperProps
} from '@patternfly/react-core';

export interface ExtendedDropdownPopperProps extends DropdownPopperProps {
  distance: string;
}

export interface AttachMenuProps extends DropdownProps {
  /** Items in menu */
  filteredItems: React.ReactNode;
  /** A callback for when the input value changes. */
  handleTextInputChange: (value: string) => void;
  /** Flag to indicate if menu is opened. */
  isOpen: boolean;
  /** Additional properties to pass to the Popper */
  popperProps?: ExtendedDropdownPopperProps;
  /** Callback to change the open state of the menu. Triggered by clicking outside of the menu. */
  onOpenChange: (isOpen: boolean) => void;
  /** Keys that trigger onOpenChange, defaults to tab and escape. It is highly recommended to include Escape in the array, while Tab may be omitted if the menu contains non-menu items that are focusable. */
  onOpenChangeKeys?: string[];
  /** Function callback called when user selects item. */
  onSelect?: (event?: React.MouseEvent<Element, MouseEvent>, value?: string | number) => void;
  /** Placeholder for search input */
  searchInputPlaceholder?: string;
  /** Aria label for search input */
  searchInputAriaLabel?: string;
  /** Toggle to be rendered */
  toggle: DropdownToggleProps | ((toggleRef: React.RefObject<any>) => React.ReactNode);
}

export const AttachMenu: React.FunctionComponent<AttachMenuProps> = ({
  className,
  filteredItems,
  handleTextInputChange,
  isOpen,
  popperProps = undefined,
  onOpenChange,
  onOpenChangeKeys,
  onSelect,
  searchInputPlaceholder,
  searchInputAriaLabel = 'Filter menu items',
  toggle,
  ...props
}: AttachMenuProps) => (
  <Dropdown
    className={`pf-chatbot__menu ${className ?? ''}`}
    isOpen={isOpen}
    onOpenChange={(isOpen) => onOpenChange(isOpen)}
    onOpenChangeKeys={onOpenChangeKeys ?? ['Esc']}
    toggle={toggle}
    popperProps={popperProps}
    onSelect={onSelect}
    {...props}
  >
    <MenuSearch>
      <MenuSearchInput>
        <SearchInput
          aria-label={searchInputAriaLabel}
          onChange={(_event, value) => handleTextInputChange(value)}
          placeholder={searchInputPlaceholder}
        />
      </MenuSearchInput>
    </MenuSearch>
    {filteredItems}
  </Dropdown>
);

export default AttachMenu;



================================================
FILE: packages/module/src/AttachMenu/index.ts
================================================
export { default } from './AttachMenu';

export * from './AttachMenu';



================================================
FILE: packages/module/src/Chatbot/Chatbot.scss
================================================
// ============================================================================
// Chatbot
// ============================================================================
.pf-chatbot {
  position: fixed;
  inset-block-end: var(--pf-t--global--spacer--800); // no associated semantic token
  inset-inline-end: var(--pf-t--global--spacer--lg);
  display: flex;
  flex-direction: column;
  width: 30rem;
  height: 70vh;
  background-color: var(--pf-t--chatbot--background);
  border-radius: var(--pf-t--global--border--radius--medium);
  box-shadow: var(--pf-t--global--box-shadow--lg);
  font-size: var(--pf-t--global--font--size--md);
  z-index: var(--pf-t--global--z-index--md);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;

  // Hide chatbot
  &--hidden {
    pointer-events: none;
  }

  // 32 rem is the width of the overlay chatbot plus the insets
  // if the screen is smaller, we want to be 100%
  @media screen and (max-width: 32rem) {
    width: 100vw;
    inset-inline-end: 0;
  }

  // allows for zoom conditions; try zooming to 200% to see
  @media screen and (max-height: 518px) {
    overflow: auto;
  }
}

// ============================================================================
// Chatbot Display Mode - Docked
// ============================================================================
.pf-chatbot--docked {
  inset-block-end: 0;
  inset-inline-end: 0;
  padding: 0;
  height: 100%;
  border-radius: 0;
  box-shadow: var(--pf-t--global--box-shadow--lg--left);
  overflow: inherit;

  // 30rem is the width of the docked chatbot
  // if the screen is smaller, we want to be 100%
  @media screen and (max-width: 30rem) {
    width: 100%;
  }
}

// ============================================================================
// Chatbot Display Mode - Fullscreen
// ============================================================================
.pf-chatbot--fullscreen {
  inset-block-end: 0;
  inset-inline-end: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  border-radius: 0;
  box-shadow: none;
}

// ============================================================================
// Chatbot Display Mode - Embedded
// ============================================================================
.pf-chatbot--embedded {
  position: static;
  width: 100%;
  min-height: 100%;
  border-radius: 0;
  box-shadow: none;
}

.pf-chatbot-container {
  height: 100%;
  width: 100%;
  display: flex;
  flex-direction: column;
  border-radius: var(--pf-t--global--border--radius--medium);
  overflow: hidden;

  // Hide chatbot
  &--hidden {
    pointer-events: none;
  }

  // allows for zoom conditions; try zooming to 200% to see
  @media screen and (max-height: 518px) {
    overflow: auto;
  }
}

.pf-chatbot-container--embedded {
  min-height: 100%;
}

.pf-chatbot-container--docked,
.pf-chatbot-container--embedded,
.pf-chatbot-container--fullscreen {
  border-radius: unset;
}

// ============================================================================
// Chatbot Display Mode - Drawer
// ============================================================================
.pf-chatbot--drawer {
  inset-block-end: 0;
  inset-inline-end: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  border-radius: 0;
  box-shadow: none;
  border-left: var(--pf-t--global--border--width--divider--default) solid;
  border-color: var(--pf-t--global--border--color--default);

  .pf-chatbot-container {
    border-radius: var(--pf-t--global--border--radius--sharp);
  }
}

// ============================================================================
// Information density styles
// ============================================================================
.pf-chatbot.pf-m-compact {
  font-size: var(--pf-t--global--font--size--sm);
}



================================================
FILE: packages/module/src/Chatbot/Chatbot.test.tsx
================================================
import '@testing-library/jest-dom';
import React from 'react';
import { render, screen } from '@testing-library/react';
import Chatbot from './Chatbot';

describe('Chatbot', () => {
  it('should render Chatbot with default display mode', () => {
    render(<Chatbot>Chatbot Content</Chatbot>);
    expect(screen.getByText('Chatbot Content')).toBeTruthy();
  });

  it('should render Chatbot with custom ariaLabel', () => {
    render(<Chatbot ariaLabel="Chatbot">Chatbot Content</Chatbot>);
    expect(screen.getByLabelText('Chatbot')).toBeTruthy();
  });

  it('should render Chatbot with custom className', () => {
    const { container } = render(
      <Chatbot ariaLabel="Chatbot" className="custom-class">
        Chatbot Content
      </Chatbot>
    );
    const chatbotElement = container.querySelector('.custom-class');
    expect(chatbotElement).toBeInTheDocument();
  });

  it('should not render Chatbot', () => {
    render(<Chatbot isVisible={false}>Chatbot Content</Chatbot>);
    expect(screen.queryByLabelText('Chatbot')).toBeFalsy();
  });

  it('should handle isCompact', () => {
    render(
      <Chatbot data-testid="chatbot" isVisible={true} isCompact>
        Chatbot Content
      </Chatbot>
    );
    expect(screen.getByTestId('chatbot')).toHaveClass('pf-m-compact');
  });
});



================================================
FILE: packages/module/src/Chatbot/Chatbot.tsx
================================================
// ============================================================================
// Chatbot
// ============================================================================
import React from 'react';
import { motion } from 'framer-motion';

export interface ChatbotProps {
  /** Content to be displayed in the chatbot */
  children: React.ReactNode;
  /** Display Mode for the Chatbot */
  displayMode?: ChatbotDisplayMode;
  /** Visibility flag for the chatbot */
  isVisible?: boolean;
  /** Custom classname for the Chatbot component */
  className?: string;
  /** Ref applied to chatbot  */
  innerRef?: React.Ref<HTMLDivElement>;
  /** Custom aria label applied to focusable container */
  ariaLabel?: string;
  /** Density of information within the ChatBot */
  isCompact?: boolean;
}

export enum ChatbotDisplayMode {
  default = 'default',
  embedded = 'embedded',
  docked = 'docked',
  fullscreen = 'fullscreen',
  drawer = 'drawer'
}

const ChatbotBase: React.FunctionComponent<ChatbotProps> = ({
  children,
  displayMode = ChatbotDisplayMode.default,
  isVisible = true,
  className,
  innerRef,
  ariaLabel,
  isCompact,
  ...props
}: ChatbotProps) => {
  // Configure animations
  const motionChatbot = {
    visible: { opacity: 1, y: 0 },
    hidden: { opacity: 0, y: '16px' }
  };

  return (
    <motion.div
      className={`pf-chatbot pf-chatbot--${displayMode} ${!isVisible ? 'pf-chatbot--hidden' : ''}  ${isCompact ? 'pf-m-compact' : ''} ${className ?? ''}`}
      variants={motionChatbot}
      initial="hidden"
      animate={isVisible ? 'visible' : 'hidden'}
      {...props}
    >
      {/* Ref is intended for use with skip to chatbot links, etc. */}
      {/* Motion.div does not accept refs */}
      {isVisible ? (
        <section
          aria-label={ariaLabel ?? 'Chatbot'}
          className={`pf-chatbot-container pf-chatbot-container--${displayMode} ${!isVisible ? 'pf-chatbot-container--hidden' : ''}`}
          tabIndex={-1}
          ref={innerRef}
        >
          {children}
        </section>
      ) : undefined}
    </motion.div>
  );
};

const Chatbot = React.forwardRef((props: ChatbotProps, ref: React.Ref<HTMLDivElement>) => (
  <ChatbotBase innerRef={ref} {...props} />
));

export default Chatbot;



================================================
FILE: packages/module/src/Chatbot/index.ts
================================================
export { default } from './Chatbot';

export * from './Chatbot';



================================================
FILE: packages/module/src/ChatbotAlert/ChatbotAlert.scss
================================================
.pf-chatbot__alert {
  position: sticky;
  top: var(--pf-t--global--spacer--lg);
  z-index: var(--pf-t--global--z-index--sm);
}



================================================
FILE: packages/module/src/ChatbotAlert/ChatbotAlert.test.tsx
================================================
import React from 'react';
import { fireEvent, render, screen } from '@testing-library/react';
import ChatbotAlert from './ChatbotAlert';

describe('ChatbotAlert', () => {
  it('should render ChatbotAlert with default variant', () => {
    render(<ChatbotAlert title="Chatbot Alert" />);
    expect(screen.getByText('Chatbot Alert')).toBeTruthy();
  });

  it('should render ChatbotAlert with children', () => {
    render(<ChatbotAlert title="Chatbot Alert">Chatbot Alert Content</ChatbotAlert>);
    expect(screen.getByText('Chatbot Alert Content')).toBeTruthy();
  });

  it('should call onClose handler when onClose button is clicked', () => {
    const onCloseHandler = jest.fn();
    render(
      <ChatbotAlert title="Chatbot Alert" onClose={onCloseHandler}>
        Chatbot Alert Content
      </ChatbotAlert>
    );

    expect(screen.getByText('Chatbot Alert')).toBeTruthy();
    expect(screen.getByText('Chatbot Alert Content')).toBeTruthy();

    // click on the close button
    fireEvent.click(screen.getByRole('button'));
    expect(onCloseHandler).toHaveBeenCalled();
  });
});



================================================
FILE: packages/module/src/ChatbotAlert/ChatbotAlert.tsx
================================================
import React from 'react';
import { Alert, AlertActionCloseButton, AlertProps } from '@patternfly/react-core';

export interface ChatbotAlert extends AlertProps {
  /** Callback for when close button is clicked; if none is provided, there will be no way to dismiss the alert */
  onClose?: () => void;
}

export const ChatbotAlert: React.FunctionComponent<ChatbotAlert> = ({
  variant = 'info',
  title,
  children = '',
  onClose,
  ...props
}: ChatbotAlert) => (
  <div className="pf-chatbot__alert">
    <Alert
      variant={variant}
      isInline
      title={title}
      component="h6"
      {...(onClose && {
        actionClose: <AlertActionCloseButton onClose={onClose} />
      })}
      {...props}
    >
      {children}
    </Alert>
  </div>
);

export default ChatbotAlert;



================================================
FILE: packages/module/src/ChatbotAlert/index.ts
================================================
export { default } from './ChatbotAlert';

export * from './ChatbotAlert';



================================================
FILE: packages/module/src/ChatbotContent/ChatbotContent.scss
================================================
// ============================================================================
// Chatbot Content
// ============================================================================
.pf-chatbot__content {
  position: relative;
  background-color: var(--pf-t--chatbot--background);
  overflow-y: auto;
  overflow: hidden; // needed in Red Hat Developer Hub workspace
  flex: 1; // needed in Composer AI

  // allows for zoom conditions; try zooming to 200% to see
  @media screen and (max-height: 518px) {
    overflow: unset;
  }
}

// ============================================================================
// Chatbot Display Mode - Fullscreen and Embedded
// ============================================================================
@media screen and (min-width: 64rem) {
  .pf-chatbot--drawer,
  .pf-chatbot--fullscreen,
  .pf-chatbot--embedded {
    .pf-chatbot__content {
      display: flex;
      justify-content: center;
    }
  }
}



================================================
FILE: packages/module/src/ChatbotContent/ChatbotContent.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import ChatbotContent from './ChatbotContent';

describe('ChatbotContent', () => {
  it('should render ChatbotContent with children', () => {
    render(<ChatbotContent>Chatbot Content</ChatbotContent>);
    expect(screen.getByText('Chatbot Content')).toBeTruthy();
  });

  it('should render ChatbotContent with custom classname', () => {
    const { container } = render(<ChatbotContent className="custom-class">Chatbot Content</ChatbotContent>);
    expect(container.querySelector('.custom-class')).toBeTruthy();
  });
});



================================================
FILE: packages/module/src/ChatbotContent/ChatbotContent.tsx
================================================
// ============================================================================
// Chatbot Main
// ============================================================================
import React from 'react';

export interface ChatbotContentProps extends React.HTMLProps<HTMLDivElement> {
  /** Content to be displayed in the chatbot */
  children: React.ReactNode;
  /** Custom classname for the ChatbotContent component */
  className?: string;
}

export const ChatbotContent: React.FunctionComponent<ChatbotContentProps> = ({
  children,
  className,
  ...props
}: ChatbotContentProps) => (
  <div className={`pf-chatbot__content ${className ?? ''}`} {...props}>
    {children}
  </div>
);

export default ChatbotContent;



================================================
FILE: packages/module/src/ChatbotContent/index.ts
================================================
export { default } from './ChatbotContent';

export * from './ChatbotContent';



================================================
FILE: packages/module/src/ChatbotConversationHistoryNav/ChatbotConversationHistoryDropdown.test.tsx
================================================
import React from 'react';
import '@testing-library/jest-dom';
import { DropdownItem } from '@patternfly/react-core';
import { fireEvent, render, screen, waitFor } from '@testing-library/react';
import ChatbotConversationHistoryDropdown from './ChatbotConversationHistoryDropdown';

describe('ChatbotConversationHistoryDropdown', () => {
  const onSelect = jest.fn();
  const menuItems = (
    <>
      <DropdownItem>Rename</DropdownItem>
      <DropdownItem>Delete</DropdownItem>
    </>
  );

  it('should render the dropdown', () => {
    render(<ChatbotConversationHistoryDropdown menuItems={menuItems} menuClassName="custom-class" />);
    expect(screen.queryByRole('menuitem', { name: /Conversation options/i })).toBeInTheDocument();
  });

  it('should display the dropdown menuItems', () => {
    render(<ChatbotConversationHistoryDropdown menuItems={menuItems} />);

    const toggle = screen.queryByRole('menuitem', { name: /Conversation options/i })!;

    expect(toggle).toBeInTheDocument();
    fireEvent.click(toggle);

    waitFor(() => {
      expect(screen.getByText('Rename')).toBeInTheDocument();
      expect(screen.getByText('Delete')).toBeInTheDocument();
    });
  });

  it('should invoke onSelect callback when menuitem is clicked', () => {
    render(<ChatbotConversationHistoryDropdown menuItems={menuItems} onSelect={onSelect} />);
    const toggle = screen.queryByRole('menuitem', { name: /Conversation options/i })!;
    fireEvent.click(toggle);
    fireEvent.click(screen.getByText('Rename'));

    expect(onSelect).toHaveBeenCalled();
  });

  it('should toggle the dropdown when menuitem is clicked', () => {
    render(<ChatbotConversationHistoryDropdown menuItems={menuItems} onSelect={onSelect} />);
    const toggle = screen.queryByRole('menuitem', { name: /Conversation options/i })!;
    fireEvent.click(toggle);
    fireEvent.click(screen.getByText('Delete'));

    expect(onSelect).toHaveBeenCalled();

    expect(screen.queryByText('Delete')).not.toBeInTheDocument();
  });

  it('should close the dropdown when user clicks outside', () => {
    render(<ChatbotConversationHistoryDropdown menuItems={menuItems} onSelect={onSelect} />);
    const toggle = screen.queryByRole('menuitem', { name: /Conversation options/i })!;
    fireEvent.click(toggle);

    expect(screen.queryByText('Delete')).toBeInTheDocument();
    fireEvent.click(toggle.parentElement!);

    expect(screen.queryByText('Delete')).not.toBeInTheDocument();
  });

  it('should show the tooltip when the user hovers over the toggle button', async () => {
    render(<ChatbotConversationHistoryDropdown menuItems={menuItems} label="Actions dropdown" />);
    const toggle = screen.queryByRole('menuitem', { name: /Actions dropdown/i })!;

    fireEvent(
      toggle,
      new MouseEvent('mouseenter', {
        bubbles: false,
        cancelable: false
      })
    );

    await waitFor(() => {
      expect(screen.queryByText('Actions dropdown')).toBeInTheDocument();
    });
  });
});



================================================
FILE: packages/module/src/ChatbotConversationHistoryNav/ChatbotConversationHistoryDropdown.tsx
================================================
// ============================================================================
// Chatbot Header - Chatbot Conversation History Nav
// ============================================================================
import React from 'react';

// Import PatternFly components
import { MenuToggleElement, Tooltip, MenuToggle, Dropdown, DropdownProps } from '@patternfly/react-core';

import EllipsisIcon from '@patternfly/react-icons/dist/esm/icons/ellipsis-v-icon';

export interface ChatbotConversationHistoryDropdownProps extends Omit<DropdownProps, 'toggle'> {
  /** Dropdown items rendered in conversation settings dropdown */
  menuItems: React.ReactNode;
  /** Optional classname applied to conversation settings dropdown */
  menuClassName?: string;
  /** Tooltip content and aria-label applied to conversation settings dropdown */
  label?: string;
  /** Callback for when user selects item. */
  onSelect?: (event?: React.MouseEvent, value?: string | number) => void;
}

export const ChatbotConversationHistoryDropdown: React.FunctionComponent<ChatbotConversationHistoryDropdownProps> = ({
  menuItems,
  menuClassName,
  onSelect,
  label
}: ChatbotConversationHistoryDropdownProps) => {
  const [isOpen, setIsOpen] = React.useState(false);

  const toggle = (toggleRef: React.Ref<MenuToggleElement>) => (
    <Tooltip
      className="pf-chatbot__tooltip"
      content={label ?? 'Conversation options'}
      position="bottom"
      // prevents VO announcements of both aria label and tooltip
      aria="none"
    >
      <MenuToggle
        className="pf-chatbot__history-actions"
        variant="plain"
        aria-label={label ?? 'Conversation options'}
        ref={toggleRef}
        isExpanded={isOpen}
        onClick={() => setIsOpen(!isOpen)}
        role="menuitem"
      >
        <EllipsisIcon />
      </MenuToggle>
    </Tooltip>
  );

  return (
    <Dropdown
      className={`pf-chatbot__selections ${menuClassName ?? ''}`}
      isOpen={isOpen}
      onSelect={(props) => {
        onSelect?.(props);
        setIsOpen((prev) => !prev);
      }}
      onOpenChange={(isOpen) => setIsOpen(isOpen)}
      popperProps={{ position: 'right' }}
      shouldFocusToggleOnSelect
      shouldFocusFirstItemOnOpen
      toggle={toggle}
    >
      {menuItems}
    </Dropdown>
  );
};

export default ChatbotConversationHistoryDropdown;



================================================
FILE: packages/module/src/ChatbotConversationHistoryNav/ChatbotConversationHistoryNav.scss
================================================
// ============================================================================
// Chatbot Header - Menu
// ============================================================================
.pf-chatbot__history {
  .pf-chatbot__drawer-backdrop {
    position: absolute;
    border-radius: var(--pf-t--global--border--radius--medium);
  }
  // Drawer input
  // ----------------------------------------------------------------------------
  .pf-chatbot__input {
    padding-inline-start: var(--pf-t--global--spacer--lg);
    padding-inline-end: var(--pf-t--global--spacer--lg);
  }

  // Drawer menu
  // ----------------------------------------------------------------------------
  .pf-v6-c-menu {
    --pf-v6-c-menu--PaddingBlockStart: 0;
    --pf-v6-c-menu--BackgroundColor: var(--pf-t--global--background--color--floating--default);
    overflow: initial;
    position: relative;
  }
  .pf-v6-c-menu__item-main {
    --pf-v6-c-menu__item-main--ColumnGap: var(--pf-t--global--spacer--md);
  }
  .pf-chatbot__menu-item-header > .pf-v6-c-menu__group-title {
    color: var(--pf-t--global--text--color--subtle);
    font-weight: var(--pf-t--global--font--weight--body--bold);
    font-size: var(--pf-t--global--icon--size--font--sm);
    --pf-v6-c-menu__group-title--PaddingInlineStart: var(--pf-t--global--spacer--sm);
    --pf-v6-c-menu__group-title--PaddingInlineEnd: var(--pf-t--global--spacer--sm);
    position: -webkit-sticky;
    position: sticky;
    top: 0;
    background-color: var(--pf-t--global--background--color--floating--default);
    z-index: var(--pf-t--global--z-index--md);
  }
  .pf-chatbot__menu-item {
    --pf-v6-c-menu__item--PaddingInlineStart: var(--pf-t--global--spacer--sm);
    --pf-v6-c-menu__item--PaddingInlineEnd: var(--pf-t--global--spacer--sm);
    padding-block-start: var(--pf-t--global--spacer--xs);
    padding-block-end: var(--pf-t--global--spacer--xs);
    color: var(--pf-t--global--text--color--regular);
    font-size: var(--pf-t--global--font--size--body--lg);
    font-weight: var(--pf-t--global--font--weight--body--default);
    border-radius: var(--pf-t--global--border--radius--small);
  }
  // allows focus state to have border radius
  .pf-v6-c-menu__list-item.pf-chatbot__menu-item {
    overflow: hidden;
  }
  .pf-chatbot__history-actions {
    transform: rotate(90deg);
  }

  .pf-chatbot__menu-item--active {
    background-color: var(--pf-t--global--background--color--action--plain--clicked);
  }

  button.pf-chatbot__menu-item--active {
    background-color: initial;
  }
}

// Chatbot Header - Drawer
// ----------------------------------------------------------------------------
.pf-chatbot__history.pf-v6-c-drawer {
  --pf-v6-c-drawer__panel--MinWidth: 24rem;
  --pf-v6-c-drawer__panel--xl--MinWidth: 24rem;
  height: 70vh;

  // Drawer panel
  .pf-v6-c-drawer__panel {
    --pf-v6-c-drawer__panel--BackgroundColor: var(--pf-t--global--background--color--floating--default);
    --pf-v6-c-drawer__panel--PaddingBlockStart: var(--pf-t--global--spacer--lg);
    --pf-v6-c-drawer__panel--PaddingBlockEnd: var(--pf-t--global--spacer--lg);
    --pf-v6-c-drawer__panel--RowGap: var(--pf-t--global--spacer--lg);
    overflow-x: hidden;
    overflow-y: hidden;
  }

  // Drawer head
  .pf-v6-c-drawer__head {
    --pf-v6-c-drawer__head--PaddingBlockStart: 0;
    --pf-v6-c-drawer__head--PaddingBlockEnd: 0;
    --pf-v6-c-drawer__head--PaddingInlineStart: var(--pf-t--global--spacer--lg);
    --pf-v6-c-drawer__head--PaddingInlineEnd: var(--pf-t--global--spacer--lg);

    display: flex;
    align-items: center;
    justify-content: space-between;
    height: var(--pf-t--global--spacer--2xl);
  }

  // Drawer actions
  .pf-v6-c-drawer__actions {
    --pf-v6-c-drawer__actions--MarginBlockStart: 0;
    --pf-v6-c-drawer__actions--MarginInlineEnd: 0;

    display: flex;
    align-items: center;
    justify-content: space-between;
    align-self: center;
    width: 100%;
    height: 100%;
  }

  .pf-v6-c-drawer__actions--reversed {
    flex-direction: row-reverse;
  }

  // Close drawer
  .pf-v6-c-drawer__close {
    .pf-v6-c-button {
      width: var(--pf-t--global--spacer--2xl);
      height: var(--pf-t--global--spacer--2xl);
      border-radius: var(--pf-t--global--border--radius--pill);
      justify-content: center;
      align-items: center;
    }
  }

  // Drawer body
  .pf-v6-c-drawer__body {
    --pf-v6-c-drawer__panel__body--PaddingBlockStart: 0;
    --pf-v6-c-drawer__panel__body--PaddingBlockEnd: 0;
    --pf-v6-c-drawer__panel__body--PaddingInlineStart: var(--pf-t--global--spacer--lg);
    --pf-v6-c-drawer__panel__body--PaddingInlineEnd: var(--pf-t--global--spacer--lg);

    overflow-y: auto;
    display: flex;
    flex-direction: column;
    height: 70vh;
  }

  // Resizable drawer spacing is different - needs manual adjustment for gaps between buttons, inputs, etc.
  .pf-v6-c-drawer__panel.pf-m-resizable {
    .pf-v6-c-drawer__panel-main {
      row-gap: var(--pf-v6-c-drawer__panel--RowGap);
    }
  }
}

// ============================================================================
// Chatbot Display Mode - Docked
// ============================================================================
.pf-chatbot--docked {
  .pf-chatbot__history.pf-v6-c-drawer {
    height: 100vh;
  }
}

// ============================================================================
// Chatbot Display Mode - Fullscreen
// ============================================================================
.pf-chatbot--drawer,
.pf-chatbot--fullscreen {
  .pf-chatbot__history.pf-v6-c-drawer {
    height: 100vh;
    .pf-v6-c-drawer__body {
      width: 100%;
    }
  }
}

// ============================================================================
// Chatbot Display Mode - embedded
// ============================================================================
.pf-chatbot--embedded {
  .pf-chatbot__history.pf-v6-c-drawer {
    height: 100%;
    .pf-v6-c-drawer__body {
      width: 100%;
      height: 100%;
    }
    .pf-v6-c-drawer__panel {
      height: 100%;
    }
  }
}

.pf-chatbot--docked,
.pf-chatbot--drawer,
.pf-chatbot--embedded,
.pf-chatbot--fullscreen {
  .pf-chatbot__history {
    .pf-chatbot__drawer-backdrop {
      border-radius: unset;
    }
  }
}

.pf-chatbot__history-loading {
  display: flex;
  padding: var(--pf-t--global--spacer--lg);
  flex-direction: column;
  gap: var(--pf-t--global--spacer--lg);
}

.pf-chatbot__history-loading-block {
  display: flex;
  flex-direction: column;
  gap: var(--pf-t--global--spacer--sm);
  align-self: stretch;
}

.pf-chatbot__history.pf-m-compact {
  .pf-v6-c-drawer__main {
    .pf-v6-c-drawer__panel {
      --pf-v6-c-drawer__panel--PaddingBlockStart: var(--pf-t--global--spacer--sm);
      --pf-v6-c-drawer__panel--PaddingBlockEnd: var(--pf-t--global--spacer--sm);
      --pf-v6-c-drawer__head--PaddingInlineStart: var(--pf-t--global--spacer--md);
      --pf-v6-c-drawer__head--PaddingInlineEnd: var(--pf-t--global--spacer--md);
      --pf-v6-c-drawer__panel--RowGap: var(--pf-t--global--spacer--md);
    }

    .pf-v6-c-drawer__body {
      --pf-v6-c-drawer__panel__body--PaddingInlineStart: var(--pf-t--global--spacer--md);
      --pf-v6-c-drawer__panel__body--PaddingInlineEnd: var(--pf-t--global--spacer--md);
    }
  }

  .pf-chatbot__menu-item {
    font-size: var(--pf-t--global--font--size--body--md);
  }

  .pf-v6-c-drawer__head {
    --pf-v6-c-drawer__head--PaddingInlineStart: var(--pf-t--global--spacer--lg);
    --pf-v6-c-drawer__head--PaddingInlineEnd: var(--pf-t--global--spacer--lg);
  }
  .pf-v6-c-drawer__close {
    .pf-v6-c-button {
      width: 2rem;
      height: 2rem;
      --pf-v6-c-button--m-plain--PaddingInlineEnd: var(--pf-t--global--spacer--xs);
      --pf-v6-c-button--m-plain--PaddingInlineStart: var(--pf-t--global--spacer--xs);
      --pf-v6-c-button--PaddingBlockStart: var(--pf-t--global--spacer--xs);
      --pf-v6-c-button--PaddingBlockEnd: var(--pf-t--global--spacer--xs);
    }
  }
}



================================================
FILE: packages/module/src/ChatbotConversationHistoryNav/ChatbotConversationHistoryNav.test.tsx
================================================
import React from 'react';
import '@testing-library/jest-dom';
import { fireEvent, render, screen, waitFor } from '@testing-library/react';

import { ChatbotDisplayMode } from '../Chatbot/Chatbot';
import ChatbotConversationHistoryNav, { Conversation } from './ChatbotConversationHistoryNav';
import { EmptyStateStatus, Spinner } from '@patternfly/react-core';
import { OutlinedCommentsIcon, SearchIcon } from '@patternfly/react-icons';

const ERROR = {
  bodyText: (
    <>
      To try again, check your connection and reload this page. If the issue persists,{' '}
      <a href="">contact the support team</a>.
    </>
  ),
  buttonText: 'Reload',
  buttonIcon: <Spinner size="sm" />,
  hasButton: true,
  titleText: 'Could not load chat history',
  status: EmptyStateStatus.danger,
  onClick: () => alert('Clicked Reload')
};

const NO_RESULTS = {
  bodyText: 'Adjust your search query and try again. Check your spelling or try a more general term.',
  titleText: 'No results found',
  icon: SearchIcon
};

const EMPTY_STATE = {
  bodyText: 'Access timely assistance by starting a conversation with an AI model.',
  titleText: 'Start a new chat',
  icon: OutlinedCommentsIcon
};

const ERROR_WITHOUT_BUTTON = {
  bodyText: (
    <>
      To try again, check your connection and reload this page. If the issue persists,{' '}
      <a href="">contact the support team</a>.
    </>
  ),
  buttonText: 'Reload',
  buttonIcon: <Spinner size="sm" />,
  hasButton: false,
  titleText: 'Could not load chat history',
  status: EmptyStateStatus.danger,
  onClick: () => alert('Clicked Reload')
};

describe('ChatbotConversationHistoryNav', () => {
  const onDrawerToggle = jest.fn();

  const initialConversations: Conversation[] = [
    {
      id: '1',
      text: 'ChatBot documentation'
    }
  ];

  it('should open the conversation history navigation drawer', () => {
    render(
      <ChatbotConversationHistoryNav
        onDrawerToggle={onDrawerToggle}
        isDrawerOpen={true}
        displayMode={ChatbotDisplayMode.fullscreen}
        setIsDrawerOpen={jest.fn()}
        conversations={initialConversations}
      />
    );
    expect(screen.queryByText('ChatBot documentation')).toBeInTheDocument();
  });

  it('should display the conversations for grouped conversations', () => {
    const groupedConversations: { [key: string]: Conversation[] } = {
      Today: [...initialConversations, { id: '2', text: 'Chatbot extension' }]
    };

    render(
      <ChatbotConversationHistoryNav
        onDrawerToggle={onDrawerToggle}
        isDrawerOpen={true}
        displayMode={ChatbotDisplayMode.fullscreen}
        setIsDrawerOpen={jest.fn()}
        conversations={groupedConversations}
      />
    );
    expect(screen.queryByText('Chatbot extension')).toBeInTheDocument();
  });

  it('should apply the reversed class when reverseButtonOrder is true', () => {
    render(
      <ChatbotConversationHistoryNav
        onDrawerToggle={onDrawerToggle}
        isDrawerOpen={true}
        displayMode={ChatbotDisplayMode.fullscreen}
        setIsDrawerOpen={jest.fn()}
        reverseButtonOrder
        conversations={initialConversations}
      />
    );

    expect(screen.getByTestId('chatbot-nav-drawer-actions')).toHaveClass('pf-v6-c-drawer__actions--reversed');
  });

  it('should not apply the reversed class when reverseButtonOrder is false', () => {
    render(
      <ChatbotConversationHistoryNav
        onDrawerToggle={onDrawerToggle}
        isDrawerOpen={true}
        displayMode={ChatbotDisplayMode.fullscreen}
        setIsDrawerOpen={jest.fn()}
        reverseButtonOrder={false}
        conversations={initialConversations}
      />
    );
    expect(screen.getByTestId('chatbot-nav-drawer-actions')).not.toHaveClass('pf-v6-c-drawer__actions--reversed');
  });

  it('should invoke handleTextInputChange callback when user searches for conversations', () => {
    const handleSearch = jest.fn();
    const groupedConversations: { [key: string]: Conversation[] } = {
      Today: [...initialConversations, { id: '2', text: 'Chatbot extension' }]
    };

    render(
      <ChatbotConversationHistoryNav
        onDrawerToggle={onDrawerToggle}
        isDrawerOpen={true}
        displayMode={ChatbotDisplayMode.fullscreen}
        setIsDrawerOpen={jest.fn()}
        reverseButtonOrder={false}
        conversations={groupedConversations}
        handleTextInputChange={handleSearch}
      />
    );

    const searchInput = screen.getByPlaceholderText(/Search/i);

    fireEvent.change(searchInput, { target: { value: 'Chatbot' } });

    expect(handleSearch).toHaveBeenCalledWith('Chatbot');
  });

  it('should close the drawer when escape key is pressed', async () => {
    render(
      <ChatbotConversationHistoryNav
        onDrawerToggle={onDrawerToggle}
        isDrawerOpen={true}
        displayMode={ChatbotDisplayMode.fullscreen}
        setIsDrawerOpen={jest.fn()}
        reverseButtonOrder={false}
        handleTextInputChange={jest.fn()}
        conversations={initialConversations}
      />
    );

    fireEvent.keyDown(screen.getByPlaceholderText(/Search/i), {
      key: 'Escape',
      code: 'Escape',
      keyCode: 27,
      charCode: 27
    });

    waitFor(() => {
      expect(screen.queryByText('ChatBot documentation')).not.toBeInTheDocument();
    });
  });

  it('should be resizable', () => {
    render(
      <ChatbotConversationHistoryNav
        onDrawerToggle={onDrawerToggle}
        isDrawerOpen={true}
        displayMode={ChatbotDisplayMode.fullscreen}
        setIsDrawerOpen={jest.fn()}
        conversations={initialConversations}
        drawerPanelContentProps={{ isResizable: true, minSize: '200px' }}
      />
    );
    expect(screen.getByRole('dialog', { name: /Resize/i })).toBeTruthy();
    expect(screen.getByRole('separator', { name: /Resize/i })).toBeTruthy();
    expect(screen.getByRole('dialog', { name: /Resize/i })).toHaveAttribute(
      'style',
      '--pf-v6-c-drawer__panel--md--FlexBasis: 384px; --pf-v6-c-drawer__panel--md--FlexBasis--min: 200px;'
    );
  });

  it('should accept drawerContentProps', () => {
    const { container } = render(
      <ChatbotConversationHistoryNav
        onDrawerToggle={onDrawerToggle}
        isDrawerOpen={true}
        displayMode={ChatbotDisplayMode.fullscreen}
        setIsDrawerOpen={jest.fn()}
        conversations={initialConversations}
        drawerContentProps={{ className: 'test' }}
      />
    );
    const element = container.querySelector('.test');
    expect(element).toBeInTheDocument();
  });

  it('should accept drawerContentBodyProps', () => {
    const { container } = render(
      <ChatbotConversationHistoryNav
        onDrawerToggle={onDrawerToggle}
        isDrawerOpen={true}
        displayMode={ChatbotDisplayMode.fullscreen}
        setIsDrawerOpen={jest.fn()}
        conversations={initialConversations}
        drawerContentBodyProps={{ className: 'test' }}
      />
    );
    const element = container.querySelector('.test');
    expect(element).toBeInTheDocument();
  });

  it('should accept drawerHeadProps', () => {
    const { container } = render(
      <ChatbotConversationHistoryNav
        onDrawerToggle={onDrawerToggle}
        isDrawerOpen={true}
        displayMode={ChatbotDisplayMode.fullscreen}
        setIsDrawerOpen={jest.fn()}
        conversations={initialConversations}
        drawerHeadProps={{ className: 'test' }}
      />
    );
    const element = container.querySelector('.test');
    expect(element).toBeInTheDocument();
  });

  it('should accept drawerActionsProps', () => {
    const { container } = render(
      <ChatbotConversationHistoryNav
        onDrawerToggle={onDrawerToggle}
        isDrawerOpen={true}
        displayMode={ChatbotDisplayMode.fullscreen}
        setIsDrawerOpen={jest.fn()}
        conversations={initialConversations}
        drawerActionsProps={{ className: 'test' }}
      />
    );
    const element = container.querySelector('.test');
    expect(element).toBeInTheDocument();
  });

  it('should accept drawerCloseButtonProps', () => {
    const { container } = render(
      <ChatbotConversationHistoryNav
        onDrawerToggle={onDrawerToggle}
        isDrawerOpen={true}
        displayMode={ChatbotDisplayMode.fullscreen}
        setIsDrawerOpen={jest.fn()}
        conversations={initialConversations}
        drawerCloseButtonProps={{ className: 'test' }}
      />
    );
    const element = container.querySelector('.test');
    expect(element).toBeInTheDocument();
  });

  it('should accept drawerPanelBodyProps', () => {
    const { container } = render(
      <ChatbotConversationHistoryNav
        onDrawerToggle={onDrawerToggle}
        isDrawerOpen={true}
        displayMode={ChatbotDisplayMode.fullscreen}
        setIsDrawerOpen={jest.fn()}
        conversations={initialConversations}
        drawerPanelBodyProps={{ className: 'test' }}
      />
    );
    const element = container.querySelector('.test');
    expect(element).toBeInTheDocument();
  });

  it('should show loading state if triggered', () => {
    render(
      <ChatbotConversationHistoryNav
        onDrawerToggle={onDrawerToggle}
        isDrawerOpen={true}
        displayMode={ChatbotDisplayMode.fullscreen}
        setIsDrawerOpen={jest.fn()}
        reverseButtonOrder={false}
        handleTextInputChange={jest.fn()}
        conversations={initialConversations}
        isLoading
      />
    );
    expect(screen.getByRole('dialog', { name: /Loading chatbot conversation history/i })).toBeTruthy();
    expect(screen.getByRole('button', { name: /Close drawer panel/i })).toBeTruthy();
  });

  it('should pass alternative aria label to loading state', () => {
    render(
      <ChatbotConversationHistoryNav
        onDrawerToggle={onDrawerToggle}
        isDrawerOpen={true}
        displayMode={ChatbotDisplayMode.fullscreen}
        setIsDrawerOpen={jest.fn()}
        reverseButtonOrder={false}
        handleTextInputChange={jest.fn()}
        conversations={initialConversations}
        isLoading
        loadingState={{ screenreaderText: 'I am a test' }}
      />
    );
    expect(screen.getByRole('dialog', { name: /I am a test/i })).toBeTruthy();
  });

  it('should accept errorState', () => {
    render(
      <ChatbotConversationHistoryNav
        onDrawerToggle={onDrawerToggle}
        isDrawerOpen={true}
        displayMode={ChatbotDisplayMode.fullscreen}
        setIsDrawerOpen={jest.fn()}
        reverseButtonOrder={false}
        handleTextInputChange={jest.fn()}
        conversations={initialConversations}
        errorState={ERROR}
      />
    );
    expect(
      screen.getByRole('dialog', {
        name: /Could not load chat history To try again, check your connection and reload this page. If the issue persists, contact the support team . Loading... Reload/i
      })
    ).toBeTruthy();
    expect(screen.getByRole('button', { name: /Close drawer panel/i })).toBeTruthy();
    expect(screen.getByRole('button', { name: /Loading... Reload/i })).toBeTruthy();
    expect(screen.getByRole('textbox', { name: /Filter menu items/i })).toBeTruthy();
    expect(screen.getByRole('heading', { name: /Could not load chat history/i })).toBeTruthy();
  });

  it('should accept errorState without button', () => {
    render(
      <ChatbotConversationHistoryNav
        onDrawerToggle={onDrawerToggle}
        isDrawerOpen={true}
        displayMode={ChatbotDisplayMode.fullscreen}
        setIsDrawerOpen={jest.fn()}
        reverseButtonOrder={false}
        handleTextInputChange={jest.fn()}
        conversations={initialConversations}
        errorState={ERROR_WITHOUT_BUTTON}
      />
    );
    expect(
      screen.getByRole('dialog', {
        name: /Could not load chat history To try again, check your connection and reload this page. If the issue persists, contact the support team ./i
      })
    ).toBeTruthy();
    expect(screen.getByRole('button', { name: /Close drawer panel/i })).toBeTruthy();
    expect(screen.queryByRole('button', { name: /Loading... Reload/i })).toBeFalsy();
    expect(screen.getByRole('textbox', { name: /Filter menu items/i })).toBeTruthy();
    expect(screen.getByRole('heading', { name: /Could not load chat history/i })).toBeTruthy();
  });

  it('should show loading state over error state if both are supplied', () => {
    render(
      <ChatbotConversationHistoryNav
        onDrawerToggle={onDrawerToggle}
        isDrawerOpen={true}
        displayMode={ChatbotDisplayMode.fullscreen}
        setIsDrawerOpen={jest.fn()}
        reverseButtonOrder={false}
        handleTextInputChange={jest.fn()}
        conversations={initialConversations}
        isLoading
        errorState={ERROR}
      />
    );
    expect(screen.getByRole('dialog', { name: /Loading/i })).toBeTruthy();
  });

  it('should accept emptyState', () => {
    render(
      <ChatbotConversationHistoryNav
        onDrawerToggle={onDrawerToggle}
        isDrawerOpen={true}
        displayMode={ChatbotDisplayMode.fullscreen}
        setIsDrawerOpen={jest.fn()}
        reverseButtonOrder={false}
        handleTextInputChange={jest.fn()}
        conversations={initialConversations}
        emptyState={EMPTY_STATE}
      />
    );
    expect(
      screen.getByRole('dialog', {
        name: /Start a new chat Access timely assistance by starting a conversation with an AI model./i
      })
    ).toBeTruthy();
  });

  it('should accept no results state', () => {
    render(
      <ChatbotConversationHistoryNav
        onDrawerToggle={onDrawerToggle}
        isDrawerOpen={true}
        displayMode={ChatbotDisplayMode.fullscreen}
        setIsDrawerOpen={jest.fn()}
        reverseButtonOrder={false}
        handleTextInputChange={jest.fn()}
        conversations={initialConversations}
        noResultsState={NO_RESULTS}
      />
    );
    expect(
      screen.getByRole('dialog', {
        name: /No results found Adjust your search query and try again. Check your spelling or try a more general term./i
      })
    ).toBeTruthy();
  });

  it('should handle isCompact', () => {
    render(
      <ChatbotConversationHistoryNav
        onDrawerToggle={onDrawerToggle}
        isDrawerOpen={true}
        displayMode={ChatbotDisplayMode.fullscreen}
        setIsDrawerOpen={jest.fn()}
        reverseButtonOrder={false}
        handleTextInputChange={jest.fn()}
        conversations={initialConversations}
        noResultsState={NO_RESULTS}
        isCompact
        data-testid="drawer"
      />
    );
    expect(screen.getByTestId('drawer')).toHaveClass('pf-m-compact');
  });
});



================================================
FILE: packages/module/src/ChatbotConversationHistoryNav/ChatbotConversationHistoryNav.tsx
================================================
// ============================================================================
// Chatbot Header - Chatbot Conversation History Nav
// ============================================================================
import React from 'react';

// Import PatternFly components
import {
  Button,
  Drawer,
  DrawerPanelContent,
  DrawerContent,
  DrawerPanelBody,
  DrawerProps,
  DrawerHead,
  DrawerActions,
  DrawerCloseButton,
  DrawerContentBody,
  SearchInput,
  Menu,
  MenuList,
  MenuGroup,
  MenuItem,
  MenuContent,
  MenuItemProps,
  MenuProps,
  DrawerPanelContentProps,
  DrawerContentProps,
  DrawerContentBodyProps,
  DrawerHeadProps,
  DrawerActionsProps,
  DrawerCloseButtonProps,
  DrawerPanelBodyProps,
  SkeletonProps
} from '@patternfly/react-core';

import { OutlinedCommentAltIcon } from '@patternfly/react-icons';
import { ChatbotDisplayMode } from '../Chatbot/Chatbot';
import ConversationHistoryDropdown from './ChatbotConversationHistoryDropdown';
import LoadingState from './LoadingState';
import HistoryEmptyState, { HistoryEmptyStateProps } from './EmptyState';

export interface Conversation {
  /** Conversation id */
  id: string;
  /** Conversation icon */
  icon?: React.ReactNode;
  /** Flag for no icon */
  noIcon?: boolean;
  /** Conversation */
  text: string;
  /** Dropdown items rendered in conversation settings dropdown */
  menuItems?: React.ReactNode;
  /** Optional classname applied to conversation settings dropdown */
  menuClassName?: string;
  /** Tooltip content and aria-label applied to conversation settings dropdown */
  label?: string;
  /** Callback for when user selects item. */
  onSelect?: (event?: React.MouseEvent, value?: string | number) => void;
  /** Additional props passed to conversation menu item */
  additionalProps?: MenuItemProps;
}
export interface ChatbotConversationHistoryNavProps extends DrawerProps {
  /** Function called to toggle drawer */
  onDrawerToggle: (event: React.KeyboardEvent | React.MouseEvent | React.TransitionEvent) => void;
  /** Flag to indicate whether drawer is open */
  isDrawerOpen: boolean;
  /** Function called to close drawer */
  setIsDrawerOpen: (bool: boolean) => void;
  /* itemId of the currently active item. */
  activeItemId?: string | number;
  /** Callback function for when an item is selected */
  onSelectActiveItem?: (event?: React.MouseEvent, itemId?: string | number) => void;
  /** Items shown in conversation history */
  conversations: Conversation[] | { [key: string]: Conversation[] };
  /** Text shown in blue button */
  newChatButtonText?: string;
  /** Callback function for when blue button is clicked. Omit to hide blue "new chat button" */
  onNewChat?: () => void;
  /** Content wrapped by conversation history nav */
  drawerContent?: React.ReactNode;
  /** Placeholder for search input */
  searchInputPlaceholder?: string;
  /** Aria label for search input */
  searchInputAriaLabel?: string;
  /** A callback for when the input value changes. Omit to hide input field */
  handleTextInputChange?: (value: string) => void;
  /** Display mode of chatbot */
  displayMode: ChatbotDisplayMode;
  /** Reverses the order of the drawer action buttons */
  reverseButtonOrder?: boolean;
  /** Custom test id for the drawer actions */
  drawerActionsTestId?: string;
  /** Additional props applied to menu  */
  menuProps?: MenuProps;
  /** Additional props applied to panel */
  drawerPanelContentProps?: DrawerPanelContentProps;
  /** Additional props applied to drawer content */
  drawerContentProps?: Omit<DrawerContentProps, 'panelContent'>;
  /** Additional props applied to drawer content body */
  drawerContentBodyProps?: DrawerContentBodyProps;
  /** Additional props applied to drawer head */
  drawerHeadProps?: DrawerHeadProps;
  /** Additional props applied to drawer actions */
  drawerActionsProps?: DrawerActionsProps;
  /** Additional props applied to drawer close button */
  drawerCloseButtonProps?: DrawerCloseButtonProps;
  /** Additional props appleid to drawer panel body */
  drawerPanelBodyProps?: DrawerPanelBodyProps;
  /** Whether to show drawer loading state */
  isLoading?: boolean;
  /** Additional props for loading state */
  loadingState?: SkeletonProps;
  /** Content to show in error state. Error state will appear once content is passed in. */
  errorState?: HistoryEmptyStateProps;
  /** Content to show in empty state. Empty state will appear once content is passed in. */
  emptyState?: HistoryEmptyStateProps;
  /** Content to show in no results state. No results state will appear once content is passed in. */
  noResultsState?: HistoryEmptyStateProps;
  /** Sets drawer to compact styling. */
  isCompact?: boolean;
}

export const ChatbotConversationHistoryNav: React.FunctionComponent<ChatbotConversationHistoryNavProps> = ({
  onDrawerToggle,
  isDrawerOpen,
  setIsDrawerOpen,
  activeItemId,
  onSelectActiveItem,
  conversations,
  newChatButtonText = 'New chat',
  drawerContent,
  onNewChat,
  searchInputPlaceholder = 'Search previous conversations...',
  searchInputAriaLabel = 'Filter menu items',
  handleTextInputChange,
  displayMode,
  reverseButtonOrder = false,
  drawerActionsTestId = 'chatbot-nav-drawer-actions',
  menuProps,
  drawerPanelContentProps,
  drawerContentProps,
  drawerContentBodyProps,
  drawerHeadProps,
  drawerActionsProps,
  drawerCloseButtonProps,
  drawerPanelBodyProps,
  isLoading,
  loadingState,
  errorState,
  emptyState,
  noResultsState,
  isCompact,
  ...props
}: ChatbotConversationHistoryNavProps) => {
  const drawerRef = React.useRef<HTMLDivElement>(null);

  const onExpand = () => {
    drawerRef.current && drawerRef.current.focus();
  };

  const getNavItem = (conversation: Conversation) => (
    <MenuItem
      className={`pf-chatbot__menu-item ${activeItemId && activeItemId === conversation.id ? 'pf-chatbot__menu-item--active' : ''}`}
      itemId={conversation.id}
      key={conversation.id}
      {...(conversation.noIcon ? {} : { icon: conversation.icon ?? <OutlinedCommentAltIcon /> })}
      /* eslint-disable indent */
      {...(conversation.menuItems
        ? {
            actions: (
              <ConversationHistoryDropdown
                menuClassName={conversation.menuClassName}
                onSelect={conversation.onSelect}
                menuItems={conversation.menuItems}
                label={conversation.label}
              />
            )
          }
        : {})}
      {...conversation.additionalProps}
      /* eslint-enable indent */
    >
      {conversation.text}
    </MenuItem>
  );

  const buildMenu = () => {
    if (Array.isArray(conversations)) {
      // Render for array of MenuItemObject
      return (
        <MenuList>
          {conversations.map((conversation) => (
            <React.Fragment key={conversation.id}>{getNavItem(conversation)}</React.Fragment>
          ))}
        </MenuList>
      );
    } else {
      // Render for object with NavItemObject arrays as values
      return (
        <>
          {Object.keys(conversations).map((navGroup) => (
            <MenuGroup className="pf-chatbot__menu-item-header" label={navGroup} key={navGroup}>
              <MenuList>
                {conversations[navGroup].map((conversation) => (
                  <React.Fragment key={conversation.id}>{getNavItem(conversation)}</React.Fragment>
                ))}
              </MenuList>
            </MenuGroup>
          ))}
        </>
      );
    }
  };

  // Menu Content
  // - Consumers should pass an array to <Chatbot> of the list of conversations
  // - Groups could be optional, but items need to be ordered by date
  const renderMenuContent = () => {
    if (errorState) {
      return <HistoryEmptyState {...errorState} />;
    }

    if (emptyState) {
      return <HistoryEmptyState {...emptyState} />;
    }

    if (noResultsState) {
      return <HistoryEmptyState {...noResultsState} />;
    }
    return (
      <Menu isPlain onSelect={onSelectActiveItem} activeItemId={activeItemId} {...menuProps}>
        <MenuContent>{buildMenu()}</MenuContent>
      </Menu>
    );
  };

  const renderDrawerContent = () => (
    <>
      {handleTextInputChange && (
        <div className="pf-chatbot__input">
          <SearchInput
            aria-label={searchInputAriaLabel}
            onChange={(_event, value) => handleTextInputChange(value)}
            placeholder={searchInputPlaceholder}
          />
        </div>
      )}
      <DrawerPanelBody {...drawerPanelBodyProps}>{renderMenuContent()}</DrawerPanelBody>
    </>
  );

  const renderPanelContent = () => {
    const drawer = (
      <>
        <DrawerHead {...drawerHeadProps}>
          <DrawerActions
            data-testid={drawerActionsTestId}
            className={reverseButtonOrder ? 'pf-v6-c-drawer__actions--reversed' : ''}
            {...drawerActionsProps}
          >
            <DrawerCloseButton onClick={onDrawerToggle} {...drawerCloseButtonProps} />
            {onNewChat && (
              <Button size={isCompact ? 'sm' : undefined} onClick={onNewChat}>
                {newChatButtonText}
              </Button>
            )}
          </DrawerActions>
        </DrawerHead>
        {isLoading ? <LoadingState {...loadingState} /> : renderDrawerContent()}
      </>
    );
    return (
      <DrawerPanelContent
        aria-live="polite"
        focusTrap={{ enabled: true }}
        defaultSize="384px"
        {...drawerPanelContentProps}
      >
        {drawer}
      </DrawerPanelContent>
    );
  };

  // An onKeyDown property must be passed to the Drawer component to handle closing
  // the drawer panel and deactivating the focus trap via the Escape key.
  const onEscape = (event: React.KeyboardEvent) => {
    if (event.key === 'Escape') {
      // prevents using escape key on menu buttons from closing the panel, but I'm not sure if this is allowed
      if (event.target instanceof HTMLInputElement && event.target.type !== 'button') {
        setIsDrawerOpen(false);
      }
    }
  };

  return (
    <Drawer
      className={`pf-chatbot__history ${isCompact ? 'pf-m-compact' : ''}`}
      isExpanded={isDrawerOpen}
      onExpand={onExpand}
      position="start"
      onKeyDown={onEscape}
      isInline={displayMode === ChatbotDisplayMode.fullscreen || displayMode === ChatbotDisplayMode.embedded}
      {...props}
    >
      <DrawerContent panelContent={renderPanelContent()} {...drawerContentProps}>
        <DrawerContentBody {...drawerContentBodyProps}>
          <>
            <div
              className={`${isDrawerOpen && (displayMode === ChatbotDisplayMode.default || displayMode === ChatbotDisplayMode.docked || displayMode === ChatbotDisplayMode.drawer) ? 'pf-v6-c-backdrop pf-chatbot__drawer-backdrop' : undefined} `}
            ></div>
            {drawerContent}
          </>
        </DrawerContentBody>
      </DrawerContent>
    </Drawer>
  );
};

export default ChatbotConversationHistoryNav;



================================================
FILE: packages/module/src/ChatbotConversationHistoryNav/EmptyState.tsx
================================================
import {
  Button,
  EmptyState,
  EmptyStateActions,
  EmptyStateBody,
  EmptyStateFooter,
  EmptyStateProps
} from '@patternfly/react-core';
import React from 'react';

export interface HistoryEmptyStateProps extends EmptyStateProps {
  onClick?: () => void;
  bodyText?: string | React.ReactNode;
  buttonText?: string;
  buttonIcon?: React.ReactNode;
  hasButton?: boolean;
}

export const HistoryEmptyState: React.FunctionComponent<HistoryEmptyStateProps> = ({
  bodyText,
  buttonIcon,
  buttonText,
  status,
  titleText,
  headingLevel,
  onClick,
  hasButton = false,
  ...props
}: HistoryEmptyStateProps) => (
  <EmptyState status={status} titleText={titleText} headingLevel={headingLevel} {...props}>
    <EmptyStateBody>{bodyText}</EmptyStateBody>
    {hasButton && (
      <EmptyStateFooter>
        <EmptyStateActions>
          <Button icon={buttonIcon} variant="secondary" onClick={onClick}>
            {buttonText}
          </Button>
        </EmptyStateActions>
      </EmptyStateFooter>
    )}
  </EmptyState>
);

export default HistoryEmptyState;



================================================
FILE: packages/module/src/ChatbotConversationHistoryNav/index.ts
================================================
export { default } from './ChatbotConversationHistoryNav';

export * from './ChatbotConversationHistoryNav';
export * from './ChatbotConversationHistoryDropdown';



================================================
FILE: packages/module/src/ChatbotConversationHistoryNav/LoadingState.tsx
================================================
import { Skeleton, SkeletonProps } from '@patternfly/react-core';
import React from 'react';

export const LoadingState: React.FunctionComponent<SkeletonProps> = ({ screenreaderText, ...rest }: SkeletonProps) => (
  <div className="pf-chatbot__history-loading">
    <div className="pf-chatbot__history-loading-block">
      <Skeleton
        screenreaderText={screenreaderText ?? 'Loading chatbot conversation history'}
        fontSize="3xl"
        {...rest}
      />
    </div>
    <div className="pf-chatbot__history-loading-block">
      <Skeleton fontSize="sm" width="70%" {...rest} />
      <Skeleton fontSize="3xl" {...rest} />
      <Skeleton fontSize="3xl" {...rest} />
    </div>
    <div className="pf-chatbot__history-loading-block">
      <Skeleton fontSize="sm" width="70%" {...rest} />
      <Skeleton fontSize="3xl" {...rest} />
      <Skeleton fontSize="3xl" {...rest} />
      <Skeleton fontSize="3xl" {...rest} />
    </div>
    <div className="pf-chatbot__history-loading-block">
      <Skeleton fontSize="sm" width="70%" {...rest} />
      <Skeleton fontSize="3xl" {...rest} />
      <Skeleton fontSize="3xl" {...rest} />
      <Skeleton fontSize="3xl" {...rest} />
      <Skeleton fontSize="3xl" {...rest} />
    </div>
    <div className="pf-chatbot__history-loading-block">
      <Skeleton fontSize="sm" width="70%" {...rest} />
      <Skeleton fontSize="3xl" {...rest} />
    </div>
  </div>
);

export default LoadingState;



================================================
FILE: packages/module/src/ChatbotFooter/ChatbotFooter.scss
================================================
// Import related component scss files.
@import './ChatbotFootnote';

// ============================================================================
// Chatbot Footer
// ============================================================================
.pf-chatbot__footer {
  --pf-chatbot__footer--RowGap: var(--pf-t--global--spacer--md);
  background-color: var(--pf-t--chatbot--background);
  display: flex;
  flex-direction: column;
  row-gap: var(--pf-chatbot__footer--RowGap);
  position: relative; // this is so focus ring on parent chatbot doesn't include footer
}
.pf-chatbot__footer-container {
  padding: 0 var(--pf-t--global--spacer--lg) var(--pf-t--global--spacer--lg) var(--pf-t--global--spacer--lg);
  display: flex;
  flex-direction: column;
  justify-content: stretch;
  row-gap: var(--pf-chatbot__footer--RowGap);
}

// ============================================================================
// Chatbot Display Mode - Fullscreen and Embedded
// ============================================================================
@media screen and (min-width: 64rem) {
  .pf-chatbot--embedded,
  .pf-chatbot--fullscreen {
    .pf-chatbot__footer {
      align-items: center;
      .pf-v6-c-divider {
        display: none;
      }
    }
    .pf-chatbot__footer-container {
      width: 90%;
      max-width: 60rem;
      padding: var(--pf-t--global--spacer--sm) 0;
    }
  }
}

// ============================================================================
// Chatbot Display Mode - Docked
// ============================================================================
.pf-chatbot--docked {
  .pf-chatbot__footer-container {
    padding: var(--pf-t--global--spacer--sm) var(--pf-t--global--spacer--lg);
  }
}

// ============================================================================
// Chatbot Display Mode - Drawer
// ============================================================================
.pf-chatbot--drawer {
  .pf-chatbot__footer-container {
    padding: var(--pf-t--global--spacer--sm) var(--pf-t--global--spacer--lg);
  }
}

.pf-chatbot__footer.pf-m-compact .pf-chatbot__footer-container {
  padding: 0 var(--pf-t--global--spacer--sm) var(--pf-t--global--spacer--sm) var(--pf-t--global--spacer--sm);
  row-gap: var(--pf-t--global--spacer--sm);
}



================================================
FILE: packages/module/src/ChatbotFooter/ChatbotFooter.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import ChatbotFooter from './ChatbotFooter';
import '@testing-library/jest-dom';

describe('ChatbotFooter', () => {
  it('should render ChatbotFooter with children', () => {
    render(<ChatbotFooter>Chatbot Content</ChatbotFooter>);
    expect(screen.getByText('Chatbot Content')).toBeTruthy();
  });

  it('should render ChatbotFooter with custom classname', () => {
    const { container } = render(<ChatbotFooter className="custom-class">Chatbot Content</ChatbotFooter>);
    expect(container.querySelector('.custom-class')).toBeTruthy();
  });

  it('should handle isCompact', () => {
    render(
      <ChatbotFooter className="custom-class" isCompact data-testid="footer">
        Chatbot Content
      </ChatbotFooter>
    );
    expect(screen.getByTestId('footer')).toHaveClass('pf-m-compact');
  });
});



================================================
FILE: packages/module/src/ChatbotFooter/ChatbotFooter.tsx
================================================
// ============================================================================
// Chatbot Footer
// ============================================================================

// Global footer component
// Supports:
// - Message bar
// - Footnote
// - Footnote popover

import React from 'react';

import { Divider } from '@patternfly/react-core';

export interface ChatbotFooterProps extends React.HTMLProps<HTMLDivElement> {
  /** Children for the Footer that supports MessageBar and FootNote components*/
  children?: React.ReactNode;
  /** Custom classname for the Footer component */
  className?: string;
  isCompact?: boolean;
}

export const ChatbotFooter: React.FunctionComponent<ChatbotFooterProps> = ({
  children,
  className,
  isCompact,
  ...props
}: ChatbotFooterProps) => (
  <div className={`pf-chatbot__footer ${isCompact ? 'pf-m-compact' : ''} ${className ?? ''}`} {...props}>
    <Divider />
    <div className="pf-chatbot__footer-container">{children}</div>
  </div>
);

export default ChatbotFooter;



================================================
FILE: packages/module/src/ChatbotFooter/ChatbotFooternote.test.tsx
================================================
import React from 'react';
import { act, fireEvent, render, screen, waitFor } from '@testing-library/react';
import ChatbotFootnote from './ChatbotFootnote';

describe('ChatbotFooternote', () => {
  const onClick = jest.fn();
  const popoverProps = {
    title: 'Verify accuracy',
    description: 'description',
    bannerImage: {
      src: 'src',
      alt: 'alt'
    },
    cta: {
      label: 'Got it',
      onClick
    },
    link: {
      label: 'label',
      url: 'url'
    }
  };

  it('should render ChatbotFooternote', () => {
    render(<ChatbotFootnote label="Chatbot footer" />);
    expect(screen.getByText('Chatbot footer')).toBeTruthy();
  });

  it('should render ChatbotFooternote with popover', async () => {
    render(<ChatbotFootnote label="Chatbot footer" popover={popoverProps} />);

    // click on the footer button
    act(() => {
      fireEvent.click(screen.getByRole('button'));
    });

    await waitFor(() => {
      // Check if the popover is visible and click on the cta button
      screen.getByLabelText('More information');
      screen.getByText('Verify accuracy');
      fireEvent.click(screen.getByRole('button', { name: 'Got it' }));
      expect(onClick).toHaveBeenCalled();
    });
  });
  it('should call onClick handler when popover cta button is clicked', async () => {
    render(<ChatbotFootnote label="Chatbot footer" popover={popoverProps} />);

    // click on the footer button
    act(() => {
      fireEvent.click(screen.getByRole('button'));
    });

    await waitFor(() => {
      // Check if the popover is visible and click on the cta button
      screen.getByLabelText('More information');
      screen.getByText('Verify accuracy');
      fireEvent.click(screen.getByRole('button', { name: 'Got it' }));
      expect(onClick).toHaveBeenCalled();
    });
  });
  it('should close the popover when escape is pressed', async () => {
    render(<ChatbotFootnote label="Chatbot footer" popover={popoverProps} />);

    // click on the footer button
    act(() => {
      fireEvent.click(screen.getByRole('button'));
    });

    await waitFor(() => {
      // Check if the popover is visible and click on the cta button
      screen.getByLabelText('More information');
      screen.getByText('Verify accuracy');
    });

    act(() => {
      // trigger escape to close the popover
      fireEvent.keyDown(document, { key: 'Escape', code: 'Escape' });
    });

    await waitFor(() => {
      expect(screen.queryByText('Verify accuracy')).toBeFalsy();
    });
  });
});



================================================
FILE: packages/module/src/ChatbotFooter/ChatbotFootnote.scss
================================================
// ============================================================================
// Chatbot Footer - Footnote
// ============================================================================

.pf-chatbot__footnote {
  align-self: center;

  .pf-v6-c-button {
    --pf-v6-c-button--BorderRadius: var(--pf-t--global--border--radius--pill);
    --pf-v6-c-button--FontSize: var(--pf-t--global--font--size--xs);
  }
}



================================================
FILE: packages/module/src/ChatbotFooter/ChatbotFootnote.tsx
================================================
// ============================================================================
// Chatbot Footer - Footnote
// ============================================================================

import React from 'react';

// Import Patternfly components
import { Button, Content, ContentVariants, Flex, PopoverProps } from '@patternfly/react-core';

// Import Patternfly icons
import { InfoCircleIcon } from '@patternfly/react-icons/dist/esm/icons/info-circle-icon';
import { ExternalLinkAltIcon } from '@patternfly/react-icons/dist/esm/icons/external-link-alt-icon';

// Import Chatbot components
import ChatbotPopover from '../ChatbotPopover/ChatbotPopover';

export interface ChatbotFootnoteProps extends React.HTMLProps<HTMLDivElement> {
  /** Label to show for the footnote */
  label: string;
  /** Config for the popover which opens up when footnote is clicked */
  popover?: ChatbotFootnotePopover;
  /** Custom classname for the Footnote component */
  className?: string;
}

export interface ChatbotFootnotePopover {
  /** Title for the Footnote popover */
  title: string;
  /** Description for the Footnote popover */
  description: string;
  /** Optional Banner Image that can be shown in the Footnote Popover */
  bannerImage?: ChatbotFootnotePopoverBannerImage;
  /** Optional CTA button that can be used to trigger an action and close the popover */
  cta?: ChatbotFootnotePopoverCTA;
  /** Optional link that can be used to show an external link like **View AI policy** */
  link?: ChatbotFootnotePopoverLink;
  /** Props for PF Popover */
  popoverProps?: PopoverProps;
}

export interface ChatbotFootnotePopoverCTA {
  /** Label for the CTA */
  label: string;
  /** Callback for the CTA */
  onClick: () => void;
}

export interface ChatbotFootnotePopoverBannerImage {
  /** Source for the banner image */
  src: string;
  /** Alternate text for the banner image */
  alt: string;
}
export interface ChatbotFootnotePopoverLink {
  /** Label for the Link */
  label: string;
  /** URL for the Link */
  url: string;
}

export const ChatbotFootnote: React.FunctionComponent<ChatbotFootnoteProps> = ({
  label,
  popover,
  className,
  ...props
}: ChatbotFootnoteProps) => {
  // Popover visibility state
  const [isVisible, setIsVisible] = React.useState<boolean>(false);

  // Define popover body content
  const popoverBodyContent = (
    <>
      {popover?.bannerImage && <img src={popover.bannerImage.src} alt={popover.bannerImage.alt} />}
      <Content component={ContentVariants.h3}>{popover?.title}</Content>
      <Content component={ContentVariants.p}>{popover?.description}</Content>
    </>
  );

  // Define popover footer content
  const popoverFooterContent = (
    <Flex gap={{ default: 'gapSm' }}>
      {popover?.cta && (
        <Button
          variant="secondary"
          onClick={() => {
            setIsVisible(false);
            popover.cta?.onClick();
          }}
        >
          {popover.cta?.label || 'Dismiss'}
        </Button>
      )}
      {popover?.link && (
        <Button
          variant="link"
          component="a"
          href={popover.link.url}
          target="_blank"
          icon={<ExternalLinkAltIcon />}
          iconPosition="end"
        >
          {popover.link.label}
        </Button>
      )}
    </Flex>
  );

  return (
    <div className={`pf-chatbot__footnote ${className ?? ''}`} {...props}>
      {popover && (
        <ChatbotPopover
          className="pf-chatbot__popover--footnote"
          aria-label={popover.popoverProps?.['aria-label'] || 'More information'}
          isVisible={isVisible}
          shouldOpen={(_event, _fn) => setIsVisible(true)}
          shouldClose={(_event, _fn) => setIsVisible(false)}
          bodyContent={popoverBodyContent}
          footerContent={popoverFooterContent}
          minWidth={popover.popoverProps?.minWidth || '432'}
          maxWidth={popover.popoverProps?.maxWidth || '432'}
          distance={popover.popoverProps?.distance || 16}
          showClose={false}
          {...popover.popoverProps}
        >
          <Button variant="link" size="sm">
            {label} <InfoCircleIcon />
          </Button>
        </ChatbotPopover>
      )}
      {!popover && <Content component={ContentVariants.small}>{label}</Content>}
    </div>
  );
};

export default ChatbotFootnote;



================================================
FILE: packages/module/src/ChatbotFooter/index.ts
================================================
export { default } from './ChatbotFooter';

export * from './ChatbotFooter';
export * from './ChatbotFootnote';



================================================
FILE: packages/module/src/ChatbotHeader/ChatbotHeader.scss
================================================
// ============================================================================
// Chatbot Header
// ============================================================================
.pf-chatbot__header-container {
  display: grid;
}
.pf-chatbot__header {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: var(--pf-t--global--spacer--sm);
  position: relative; // this is so focus ring on parent chatbot doesn't include header
  background-color: var(--pf-t--chatbot--background);
  justify-content: space-between;
  padding: var(--pf-t--global--spacer--lg);

  .pf-chatbot__header-main {
    display: flex;
    gap: var(--pf-t--global--spacer--sm);

    img {
      pointer-events: none; // prevent dragging on any brand images - interferes with FileDropZone
    }
  }

  // Title -or- Brand
  .pf-chatbot__title {
    display: flex;
    align-items: center;
    flex: 1;

    .pf-v6-l-bullseye {
      width: 100%;
    }

    img {
      max-height: 40px;
      vertical-align: middle;
    }
  }

  .pf-chatbot__menu {
    justify-self: start;
  }

  .pf-chatbot__actions {
    justify-self: end;
    display: flex;
    gap: var(--pf-t--global--spacer--sm);
    justify-content: flex-end;
    align-items: center;
    .pf-v6-c-menu-toggle.pf-m-secondary {
      width: 160px;
      --pf-v6-c-menu-toggle--BackgroundColor: var(--pf-t--global--background--color--control--default);
    }
  }
}

// ============================================================================
// Chatbot Display Mode - Fullscreen and Embedded
// ============================================================================
@media screen and (min-width: 64rem) {
  .pf-chatbot--fullscreen,
  .pf-chatbot--embedded {
    .pf-chatbot__header {
      background-color: var(--pf-t--global--background--color--primary--default);
    }
    .pf-chatbot__header__divider {
      display: none;
    }
  }
}

// ============================================================================
// Chatbot Display Mode - Docked and Drawer
// ============================================================================
.pf-chatbot--drawer,
.pf-chatbot--docked {
  .pf-chatbot__header {
    background-color: var(--pf-t--chatbot--background);
  }
}

// ============================================================================
// Toggle Options
// ============================================================================
.pf-chatbot__button--toggle-options,
.pf-chatbot__button--toggle-menu {
  width: 3rem;
  height: 3rem;
  border-radius: var(--pf-t--global--border--radius--pill);
  align-items: center;
  justify-content: center;

  .pf-v6-c-button__icon,
  .pf-v6-c-menu-toggle__icon,
  .pf-v6-c-icon__content {
    color: var(--pf-t--global--icon--color--subtle);
  }

  .pf-v6-c-button__icon,
  .pf-v6-c-menu-toggle__icon {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  // Interactive states
  &:hover,
  &:focus {
    .pf-v6-c-button__icon,
    .pf-v6-c-menu-toggle__icon,
    .pf-v6-c-icon__content {
      color: var(--pf-t--global--icon--color--regular);
    }
  }
}

// Rotate icon
.pf-chatbot__button--toggle-options {
  svg {
    transform: rotate(90deg);
  }
}

// ============================================================================
// Examples
// ============================================================================
.show-dark,
:where(.pf-v6-theme-dark) .show-light {
  display: none;
}

:where(.pf-v6-theme-dark) .show-dark {
  display: revert;
}

:where(.pf-v6-theme-dark) .show-dark .pf-m-picture {
  display: inline-flex;
}

// ============================================================================
// Information density styles
// ============================================================================
.pf-chatbot.pf-m-compact {
  .pf-chatbot__header {
    gap: var(--pf-t--global--spacer--sm);
    padding: var(--pf-t--global--spacer--sm);
  }

  .pf-chatbot__header .pf-chatbot__title img {
    max-height: 24px;
    vertical-align: middle;
  }
}

.pf-v6-c-menu-toggle.pf-chatbot__button--toggle-options.pf-m-compact,
.pf-chatbot__button--toggle-menu.pf-m-compact {
  width: 2rem;
  height: 2rem;
}

.pf-chatbot__header .pf-chatbot__actions .pf-v6-c-menu-toggle.pf-m-secondary.pf-m-compact {
  width: initial;
}



================================================
FILE: packages/module/src/ChatbotHeader/ChatbotHeader.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import ChatbotHeader from './ChatbotHeader';

describe('ChatbotHeader', () => {
  it('should render ChatbotHeader with children', () => {
    render(<ChatbotHeader>Chatbot Header</ChatbotHeader>);
    expect(screen.getByText('Chatbot Header')).toBeTruthy();
  });

  it('should render ChatbotHeader with custom classname', () => {
    const { container } = render(<ChatbotHeader className="custom-header-class">Chatbot Content</ChatbotHeader>);
    expect(container.querySelector('.custom-header-class')).toBeTruthy();
  });
});



================================================
FILE: packages/module/src/ChatbotHeader/ChatbotHeader.tsx
================================================
import React from 'react';

import { Divider } from '@patternfly/react-core';

export interface ChatbotHeaderProps extends React.HTMLProps<HTMLDivElement> {
  /** Content to be displayed in the chatbot header */
  children: React.ReactNode;
  /** Custom classname for the header component */
  className?: string;
}

export const ChatbotHeader: React.FunctionComponent<ChatbotHeaderProps> = ({
  className,
  children
}: ChatbotHeaderProps) => (
  <div className="pf-chatbot__header-container">
    <div className={`pf-chatbot__header${className ? ` ${className}` : ''}`}>{children}</div>
    <Divider className="pf-chatbot__header__divider" />
  </div>
);

export default ChatbotHeader;



================================================
FILE: packages/module/src/ChatbotHeader/ChatbotHeaderActions.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import ChatbotHeaderActions from './ChatbotHeaderActions';

describe('ChatbotHeaderActions', () => {
  it('should render ChatbotHeaderActions with children', () => {
    render(<ChatbotHeaderActions>Chatbot Header</ChatbotHeaderActions>);
    expect(screen.getByText('Chatbot Header')).toBeTruthy();
  });

  it('should render ChatbotHeaderActions with custom classname', () => {
    const { container } = render(
      <ChatbotHeaderActions className="custom-header-action-class">Chatbot Content</ChatbotHeaderActions>
    );
    expect(container.querySelector('.custom-header-action-class')).toBeTruthy();
  });
});



================================================
FILE: packages/module/src/ChatbotHeader/ChatbotHeaderActions.tsx
================================================
import React from 'react';

export interface ChatbotHeaderActionsProps {
  /** Content to be displayed in the chatbot header */
  children: React.ReactNode;
  /** Custom classname for the header component */
  className?: string;
}

export const ChatbotHeaderActions: React.FunctionComponent<ChatbotHeaderActionsProps> = ({
  className,
  children
}: ChatbotHeaderActionsProps) => <div className={`pf-chatbot__actions ${className || ''}`}>{children}</div>;

export default ChatbotHeaderActions;



================================================
FILE: packages/module/src/ChatbotHeader/ChatbotHeaderCloseButton.test.tsx
================================================
import React from 'react';
import { fireEvent, render, screen } from '@testing-library/react';
import { ChatbotHeaderCloseButton } from './ChatbotHeaderCloseButton';
import '@testing-library/jest-dom';

describe('ChatbotHeaderCloseButton', () => {
  it('should render ChatbotHeaderCloseButton', () => {
    const { container } = render(
      <ChatbotHeaderCloseButton className="custom-header-close-button" onClick={jest.fn()} />
    );

    expect(container.querySelector('.custom-header-close-button')).toBeTruthy();
  });

  it('should call onClick handler when close button is pressed', () => {
    const onClick = jest.fn();
    render(<ChatbotHeaderCloseButton className="custom-header-close-button" onClick={onClick} />);
    fireEvent.click(screen.getByRole('button', { name: 'Close' }));
    expect(onClick).toHaveBeenCalled();
  });

  it('should render button with isCompact', () => {
    render(<ChatbotHeaderCloseButton data-testid="close-button" onClick={jest.fn()} isCompact />);
    expect(screen.getByTestId('close-button')).toHaveClass('pf-m-compact');
  });
});



================================================
FILE: packages/module/src/ChatbotHeader/ChatbotHeaderCloseButton.tsx
================================================
import React from 'react';

import { Button, ButtonProps, Icon, Tooltip, TooltipProps } from '@patternfly/react-core';
import { CloseIcon } from '@patternfly/react-icons';

export interface ChatbotHeaderCloseButtonProps extends ButtonProps {
  /** Callback function for when button is clicked */
  onClick: () => void;
  /** Custom classname for the header component */
  className?: string;
  /** Props spread to the PF Tooltip component wrapping the display mode dropdown */
  tooltipProps?: TooltipProps;
  /** Aria label for menu */
  menuAriaLabel?: string;
  /** Ref applied to menu */
  innerRef?: React.Ref<HTMLButtonElement>;
  /** Content used in tooltip */
  tooltipContent?: string;
  /** Sets button to compact styling. */
  isCompact?: boolean;
}

const ChatbotHeaderCloseButtonBase: React.FunctionComponent<ChatbotHeaderCloseButtonProps> = ({
  className,
  onClick,
  tooltipProps,
  menuAriaLabel = 'Close',
  innerRef,
  tooltipContent = 'Close',
  isCompact,
  ...props
}: ChatbotHeaderCloseButtonProps) => (
  <div className={`pf-chatbot__menu${className ? ` ${className}` : ''}`}>
    <Tooltip
      content={tooltipContent}
      position="bottom"
      // prevents VO announcements of both aria label and tooltip
      aria="none"
      {...tooltipProps}
    >
      <Button
        className={`pf-chatbot__button--toggle-menu ${isCompact ? 'pf-m-compact' : ''}`}
        variant="plain"
        onClick={onClick}
        aria-label={menuAriaLabel}
        ref={innerRef}
        icon={
          <Icon size={isCompact ? 'lg' : 'xl'} isInline>
            <CloseIcon />
          </Icon>
        }
        size={isCompact ? 'sm' : undefined}
        {...props}
      />
    </Tooltip>
  </div>
);

export const ChatbotHeaderCloseButton = React.forwardRef(
  (props: ChatbotHeaderCloseButtonProps, ref: React.Ref<HTMLButtonElement>) => (
    <ChatbotHeaderCloseButtonBase innerRef={ref} {...props} />
  )
);



================================================
FILE: packages/module/src/ChatbotHeader/ChatbotHeaderMain.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import ChatbotHeaderMain from './ChatbotHeaderMain';

describe('ChatbotHeaderMain', () => {
  it('should render ChatbotHeaderMain with children', () => {
    render(<ChatbotHeaderMain>Chatbot Header Main</ChatbotHeaderMain>);
    expect(screen.getByText('Chatbot Header Main')).toBeTruthy();
  });

  it('should render ChatbotHeaderMain with custom classname', () => {
    const { container } = render(
      <ChatbotHeaderMain className="custom-header-class">Chatbot Content</ChatbotHeaderMain>
    );
    expect(container.querySelector('.custom-header-class')).toBeTruthy();
  });
});



================================================
FILE: packages/module/src/ChatbotHeader/ChatbotHeaderMain.tsx
================================================
import React from 'react';

export interface ChatbotHeaderMainProps {
  /** Custom classname for the header component */
  className?: string;
  /** Menu and/or chatbot header components */
  children: React.ReactNode;
}

export const ChatbotHeaderMain: React.FunctionComponent<ChatbotHeaderMainProps> = ({
  className,
  children
}: ChatbotHeaderMainProps) => (
  <div className={`pf-chatbot__header-main${className ? ` ${className}` : ''}`}>{children}</div>
);

export default ChatbotHeaderMain;



================================================
FILE: packages/module/src/ChatbotHeader/ChatbotHeaderMenu.test.tsx
================================================
import React from 'react';
import { fireEvent, render, screen } from '@testing-library/react';
import { ChatbotHeaderMenu } from './ChatbotHeaderMenu';
import '@testing-library/jest-dom';

describe('ChatbotHeaderMenu', () => {
  it('should render ChatbotHeaderMenu with custom class', () => {
    const { container } = render(<ChatbotHeaderMenu className="custom-header-menu" onMenuToggle={jest.fn()} />);

    expect(container.querySelector('.custom-header-menu')).toBeTruthy();
  });

  it('should call onMenuToggle when ChatbotHeaderMenu button is clicked', () => {
    const onMenuToggle = jest.fn();
    render(<ChatbotHeaderMenu className="custom-header-menu" onMenuToggle={onMenuToggle} />);
    fireEvent.click(screen.getByRole('button', { name: 'Toggle menu' }));

    expect(onMenuToggle).toHaveBeenCalled();
  });

  it('should handle isCompact', () => {
    render(
      <ChatbotHeaderMenu className="custom-header-menu" onMenuToggle={jest.fn()} isCompact data-testid="button" />
    );
    expect(screen.getByTestId('button')).toHaveClass('pf-m-compact');
  });
});



================================================
FILE: packages/module/src/ChatbotHeader/ChatbotHeaderMenu.tsx
================================================
import React from 'react';

import { Button, ButtonProps, Icon, Tooltip, TooltipProps } from '@patternfly/react-core';
import BarsIcon from '@patternfly/react-icons/dist/esm/icons/bars-icon';

export interface ChatbotHeaderMenuProps extends ButtonProps {
  /** Callback function to attach to menu toggle on top right of chatbot header. */
  onMenuToggle: () => void;
  /** Custom classname for the header component */
  className?: string;
  /** Props spread to the PF Tooltip component wrapping the display mode dropdown */
  tooltipProps?: TooltipProps;
  /** Aria label for menu */
  menuAriaLabel?: string;
  /** Ref applied to menu */
  innerRef?: React.Ref<HTMLButtonElement>;
  /** Content used in tooltip */
  tooltipContent?: string;
  isCompact?: boolean;
}

const ChatbotHeaderMenuBase: React.FunctionComponent<ChatbotHeaderMenuProps> = ({
  className,
  onMenuToggle,
  tooltipProps,
  menuAriaLabel = 'Toggle menu',
  innerRef,
  tooltipContent = 'Menu',
  isCompact,
  ...props
}: ChatbotHeaderMenuProps) => (
  <div className={`pf-chatbot__menu ${className}`}>
    <Tooltip
      content={tooltipContent}
      position="bottom"
      // prevents VO announcements of both aria label and tooltip
      aria="none"
      {...tooltipProps}
    >
      <Button
        className={`pf-chatbot__button--toggle-menu ${isCompact ? 'pf-m-compact' : ''}`}
        variant="plain"
        onClick={onMenuToggle}
        aria-label={menuAriaLabel}
        ref={innerRef}
        icon={
          <Icon size={isCompact ? 'lg' : 'xl'} isInline>
            <BarsIcon />
          </Icon>
        }
        size={isCompact ? 'sm' : undefined}
        {...props}
      />
    </Tooltip>
  </div>
);

export const ChatbotHeaderMenu = React.forwardRef(
  (props: ChatbotHeaderMenuProps, ref: React.Ref<HTMLButtonElement>) => (
    <ChatbotHeaderMenuBase innerRef={ref} {...props} />
  )
);



================================================
FILE: packages/module/src/ChatbotHeader/ChatbotHeaderOptionsDropdown.test.tsx
================================================
import React from 'react';
import { DropdownItem } from '@patternfly/react-core';
import { act, fireEvent, render, screen, waitFor } from '@testing-library/react';
import { ChatbotHeaderOptionsDropdown } from './ChatbotHeaderOptionsDropdown';
import '@testing-library/jest-dom';

describe('ChatbotHeaderOptionsDropdown', () => {
  const dropdownItems = (
    <>
      <DropdownItem>Option 1</DropdownItem>
      <DropdownItem>Option 2</DropdownItem>
      <DropdownItem>Option 3</DropdownItem>
    </>
  );

  it('should render ChatbotHeaderOptionsDropdown', () => {
    render(<ChatbotHeaderOptionsDropdown>{dropdownItems}</ChatbotHeaderOptionsDropdown>);

    expect(screen.getByRole('button', { name: 'Chatbot options' })).toBeTruthy();
  });

  it('should call onselect handler when a dropdown item is clicked', async () => {
    const onSelect = jest.fn();
    const { container } = render(
      <ChatbotHeaderOptionsDropdown className="custom-header-options-dropdown" onSelect={onSelect}>
        {dropdownItems}
      </ChatbotHeaderOptionsDropdown>
    );

    act(() => {
      fireEvent.click(screen.getByRole('button', { name: 'Chatbot options' }));
    });

    await waitFor(() => {
      expect(container.querySelector('.custom-header-options-dropdown')).toBeTruthy();

      expect(screen.getByText('Option 1'));
      expect(screen.getByText('Option 2'));
      expect(screen.getByText('Option 3'));

      fireEvent.click(screen.getByText('Option 3'));

      expect(onSelect).toHaveBeenCalled();
    });
  });

  it('should handle isCompact', () => {
    render(<ChatbotHeaderOptionsDropdown isCompact>{dropdownItems}</ChatbotHeaderOptionsDropdown>);
    expect(screen.getByRole('button', { name: 'Chatbot options' })).toHaveClass('pf-m-compact');
  });
});



================================================
FILE: packages/module/src/ChatbotHeader/ChatbotHeaderOptionsDropdown.tsx
================================================
import React from 'react';

import {
  Tooltip,
  TooltipProps,
  Dropdown,
  DropdownProps,
  MenuToggle,
  MenuToggleElement,
  Icon
} from '@patternfly/react-core';
import EllipsisIcon from '@patternfly/react-icons/dist/esm/icons/ellipsis-v-icon';

export interface ChatbotHeaderOptionsDropdownProps extends Omit<DropdownProps, 'toggle'> {
  /** Content to be displayed in the chatbot header */
  children: React.ReactNode;
  /** Custom classname for the header component */
  className?: string;
  /** Props spread to the PF Tooltip component wrapping the display mode dropdown */
  tooltipProps?: TooltipProps;
  /** Aria label for menu toggle */
  menuToggleAriaLabel?: string;
  isCompact?: boolean;
}

export const ChatbotHeaderOptionsDropdown: React.FunctionComponent<ChatbotHeaderOptionsDropdownProps> = ({
  className,
  children,
  onSelect,
  tooltipProps,
  menuToggleAriaLabel = 'Chatbot options',
  isCompact,
  ...props
}: ChatbotHeaderOptionsDropdownProps) => {
  const [isOptionsMenuOpen, setIsOptionsMenuOpen] = React.useState(false);

  const toggle = (toggleRef: React.Ref<MenuToggleElement>) => (
    <Tooltip
      className="pf-chatbot__tooltip"
      content="Chatbot options"
      position="bottom"
      // prevents VO announcements of both aria label and tooltip
      aria="none"
      {...tooltipProps}
    >
      <MenuToggle
        className={`pf-chatbot__button--toggle-options ${isCompact ? 'pf-m-compact' : ''}`}
        variant="plain"
        aria-label={menuToggleAriaLabel}
        ref={toggleRef}
        icon={
          <Icon size={isCompact ? 'lg' : 'xl'} isInline>
            <EllipsisIcon />
          </Icon>
        }
        isExpanded={isOptionsMenuOpen}
        onClick={() => setIsOptionsMenuOpen(!isOptionsMenuOpen)}
        size={isCompact ? 'sm' : undefined}
      />
    </Tooltip>
  );

  return (
    <Dropdown
      className={`pf-chatbot__options ${className ?? ''}`}
      isOpen={isOptionsMenuOpen}
      onSelect={(e, value) => {
        onSelect && onSelect(e, value);
        setIsOptionsMenuOpen(false);
      }}
      onOpenChange={(isOpen) => setIsOptionsMenuOpen(isOpen)}
      popperProps={{ position: 'right', preventOverflow: true, appendTo: 'inline' }}
      shouldFocusToggleOnSelect
      shouldFocusFirstItemOnOpen
      toggle={toggle}
      {...props}
    >
      {children}
    </Dropdown>
  );
};

export default ChatbotHeaderOptionsDropdown;



================================================
FILE: packages/module/src/ChatbotHeader/ChatbotHeaderSelectorDropdown.test.tsx
================================================
import React from 'react';
import { DropdownItem } from '@patternfly/react-core';
import { act, fireEvent, render, screen, waitFor } from '@testing-library/react';
import { ChatbotHeaderSelectorDropdown } from './ChatbotHeaderSelectorDropdown';
import '@testing-library/jest-dom';

describe('ChatbotHeaderSelectorDropdown', () => {
  const dropdownItems = (
    <>
      <DropdownItem>Option 1</DropdownItem>
      <DropdownItem>Option 2</DropdownItem>
      <DropdownItem>Option 3</DropdownItem>
    </>
  );

  it('should render ChatbotHeaderSelectorDropdown', () => {
    render(<ChatbotHeaderSelectorDropdown value="Option 1">{dropdownItems}</ChatbotHeaderSelectorDropdown>);

    expect(screen.getByRole('button', { name: /Select model/i })).toBeTruthy();
  });

  it('should call onselect handler when a dropdown item is clicked', async () => {
    const onSelect = jest.fn();
    const { container } = render(
      <ChatbotHeaderSelectorDropdown value="Option 1" className="custom-header-selector-dropdown" onSelect={onSelect}>
        {dropdownItems}
      </ChatbotHeaderSelectorDropdown>
    );

    act(() => {
      fireEvent.click(screen.getByRole('button', { name: /Select model/i }));
    });

    await waitFor(() => {
      expect(container.querySelector('.custom-header-selector-dropdown')).toBeTruthy();

      expect(screen.getByText('Option 3'));

      fireEvent.click(screen.getByText('Option 3'));

      expect(onSelect).toHaveBeenCalled();
    });
  });

  it('should handle isCompact', () => {
    render(
      <ChatbotHeaderSelectorDropdown value="Option 1" isCompact>
        {dropdownItems}
      </ChatbotHeaderSelectorDropdown>
    );
    expect(screen.getByRole('button', { name: /Select model/i })).toHaveClass('pf-m-compact');
  });
});



================================================
FILE: packages/module/src/ChatbotHeader/ChatbotHeaderSelectorDropdown.tsx
================================================
import React from 'react';

import { Tooltip, TooltipProps, Dropdown, DropdownProps, MenuToggle, MenuToggleElement } from '@patternfly/react-core';

export interface ChatbotHeaderSelectorDropdownProps extends Omit<DropdownProps, 'toggle'> {
  /** Value of the selected dropdown item */
  value: string;
  /** Content to be displayed in the chatbot header */
  children: React.ReactNode;
  /** Custom classname for the header component */
  className?: string;
  /** Props spread to the PF Tooltip component wrapping the display mode dropdown */
  tooltipProps?: TooltipProps;
  /** Aria label for menu toggle */
  menuToggleAriaLabel?: string;
  /** Text displayed in Tooltip wrapping the display mode dropdown */
  tooltipContent?: string;
  isCompact?: boolean;
}

export const ChatbotHeaderSelectorDropdown: React.FunctionComponent<ChatbotHeaderSelectorDropdownProps> = ({
  value,
  className,
  children,
  onSelect,
  tooltipProps,
  tooltipContent = 'Select model',
  menuToggleAriaLabel,
  isCompact,
  ...props
}: ChatbotHeaderSelectorDropdownProps) => {
  const [isOptionsMenuOpen, setIsOptionsMenuOpen] = React.useState(false);
  const [defaultAriaLabel, setDefaultAriaLabel] = React.useState('Select model');

  const toggle = (toggleRef: React.Ref<MenuToggleElement>) => (
    <Tooltip
      className="pf-chatbot__tooltip"
      content={tooltipContent}
      position="bottom"
      // prevents VO announcements of both aria label and tooltip
      aria="none"
      {...tooltipProps}
    >
      <MenuToggle
        variant="secondary"
        aria-label={menuToggleAriaLabel ?? defaultAriaLabel}
        ref={toggleRef}
        isExpanded={isOptionsMenuOpen}
        onClick={() => setIsOptionsMenuOpen(!isOptionsMenuOpen)}
        size={isCompact ? 'sm' : undefined}
        className={`${isCompact ? 'pf-m-compact' : ''}`}
      >
        {value}
      </MenuToggle>
    </Tooltip>
  );

  return (
    <Dropdown
      className={`pf-chatbot__selections ${className ?? ''}`}
      isOpen={isOptionsMenuOpen}
      onSelect={(e, value) => {
        onSelect && onSelect(e, value);
        setDefaultAriaLabel(`Select model: ${value}`);
        setIsOptionsMenuOpen(false);
      }}
      onOpenChange={(isOpen) => setIsOptionsMenuOpen(isOpen)}
      popperProps={{ position: 'right', appendTo: 'inline' }}
      shouldFocusToggleOnSelect
      shouldFocusFirstItemOnOpen
      toggle={toggle}
      {...props}
    >
      {children}
    </Dropdown>
  );
};

export default ChatbotHeaderSelectorDropdown;



================================================
FILE: packages/module/src/ChatbotHeader/ChatbotHeaderTitle.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import { ChatbotDisplayMode } from '../Chatbot/Chatbot';
import ChatbotHeaderTitle from './ChatbotHeaderTitle';

describe('ChatbotHeaderTitle', () => {
  it('should render ChatbotHeaderTitle with children', () => {
    render(<ChatbotHeaderTitle>Chatbot Header Title</ChatbotHeaderTitle>);
    expect(screen.getByText('Chatbot Header Title')).toBeTruthy();
  });

  it('should render ChatbotHeaderTitle with custom classname', () => {
    const { container } = render(
      <ChatbotHeaderTitle className="custom-header-class">Chatbot Header Title</ChatbotHeaderTitle>
    );
    expect(container.querySelector('.custom-header-class')).toBeTruthy();
  });

  it('should render title for default display mode', () => {
    render(<ChatbotHeaderTitle displayMode={ChatbotDisplayMode.default} showOnDefault="Default header title" />);
    expect(screen.getByText('Default header title')).toBeTruthy();
  });

  it('should render title for docked display mode', () => {
    render(<ChatbotHeaderTitle displayMode={ChatbotDisplayMode.docked} showOnDocked="Docked header title" />);
    expect(screen.getByText('Docked header title')).toBeTruthy();
  });

  it('should fallback to default title when docked display mode title is not configured', () => {
    render(<ChatbotHeaderTitle displayMode={ChatbotDisplayMode.docked} showOnDefault="Default header title" />);
    expect(screen.getByText('Default header title')).toBeTruthy();
  });

  it('should render title for embedded display mode', () => {
    render(<ChatbotHeaderTitle displayMode={ChatbotDisplayMode.embedded} showOnEmbedded="Embedded header title" />);
    expect(screen.getByText('Embedded header title')).toBeTruthy();
  });

  it('should fallback to default title when embedded display mode title is not configured', () => {
    render(<ChatbotHeaderTitle displayMode={ChatbotDisplayMode.embedded} showOnDefault="Default header title" />);
    expect(screen.getByText('Default header title')).toBeTruthy();
  });

  it('should render title for fullscreen display mode', () => {
    render(
      <ChatbotHeaderTitle
        displayMode={ChatbotDisplayMode.fullscreen}
        showOnFullScreen="Fullscreen header title"
        className="custom-header-class"
      />
    );
    expect(screen.getByText('Fullscreen header title')).toBeTruthy();
  });

  it('should fallback to default title when fullscreen display mode title is not configured', () => {
    render(<ChatbotHeaderTitle displayMode={ChatbotDisplayMode.fullscreen} showOnDefault="Default header title" />);
    expect(screen.getByText('Default header title')).toBeTruthy();
  });

  it('should render title for drawer display mode', () => {
    render(
      <ChatbotHeaderTitle
        displayMode={ChatbotDisplayMode.drawer}
        showOnDrawer="Drawer header title"
        className="custom-header-class"
      />
    );
    expect(screen.getByText('Drawer header title')).toBeTruthy();
  });

  it('should fallback to default title when drawer display mode title is not configured', () => {
    render(<ChatbotHeaderTitle displayMode={ChatbotDisplayMode.drawer} showOnDefault="Default header title" />);
    expect(screen.getByText('Default header title')).toBeTruthy();
  });
});



================================================
FILE: packages/module/src/ChatbotHeader/ChatbotHeaderTitle.tsx
================================================
import React from 'react';

import { SplitItem } from '@patternfly/react-core';
import { ChatbotDisplayMode } from '../Chatbot/Chatbot';

export interface ChatbotHeaderTitleProps {
  /** Content to be displayed in the chatbot header */
  children?: React.ReactNode;
  /** Custom classname for the header component */
  className?: string;
  /** Display mode of chatbot, in case you want to conditionally show a title */
  displayMode?: ChatbotDisplayMode;
  /** Content to display on full screen */
  showOnFullScreen?: React.ReactNode | string;
  /** Content to display on docked screen */
  showOnDocked?: React.ReactNode | string;
  /** Content to display on embedded screen */
  showOnEmbedded?: React.ReactNode | string;
  /** Content to display in drawer mode */
  showOnDrawer?: React.ReactNode | string;
  /** Content to display by default; this will be shown if a case is not explicitly set */
  showOnDefault?: React.ReactNode | string;
}

export const ChatbotHeaderTitle: React.FunctionComponent<ChatbotHeaderTitleProps> = ({
  className,
  children,
  displayMode,
  showOnFullScreen,
  showOnDocked,
  showOnEmbedded,
  showOnDrawer,
  showOnDefault
}: ChatbotHeaderTitleProps) => {
  const renderChildren = () => {
    if (displayMode) {
      /* eslint-disable indent */
      switch (displayMode) {
        case ChatbotDisplayMode.fullscreen:
          return showOnFullScreen ?? showOnDefault;
        case ChatbotDisplayMode.docked:
          return showOnDocked ?? showOnDefault;
        case ChatbotDisplayMode.embedded:
          return showOnEmbedded ?? showOnDefault;
        case ChatbotDisplayMode.drawer:
          return showOnDrawer ?? showOnDefault;
        default:
          return showOnDefault;
      }
      /* eslint-enable indent */
    } else {
      return children;
    }
  };
  return (
    <SplitItem isFilled className={`pf-chatbot__title ${className || ''}`}>
      {renderChildren()}
    </SplitItem>
  );
};

export default ChatbotHeaderTitle;



================================================
FILE: packages/module/src/ChatbotHeader/index.ts
================================================
export { default } from './ChatbotHeader';

export * from './ChatbotHeader';
export * from './ChatbotHeaderActions';
export * from './ChatbotHeaderMain';
export * from './ChatbotHeaderMenu';
export * from './ChatbotHeaderTitle';
export * from './ChatbotHeaderOptionsDropdown';
export * from './ChatbotHeaderSelectorDropdown';
export * from './ChatbotHeaderCloseButton';



================================================
FILE: packages/module/src/ChatbotModal/ChatbotModal.scss
================================================
.pf-chatbot__chatbot-modal-backdrop {
  position: static !important;
}

.pf-chatbot__chatbot-modal {
  --pf-v6-c-modal-box--BorderRadius: var(--pf-t--global--border--radius--medium) !important;
  position: fixed !important;
  inset-block-end: var(--pf-t--global--spacer--800); // no associated semantic token
  inset-inline-end: var(--pf-t--global--spacer--lg);
  width: 30rem !important;
  height: 70vh;
  background-color: var(--pf-t--global--background--color--secondary--default) !important;

  .pf-v6-c-modal-box__title {
    --pf-v6-c-modal-box__title--FontSize: var(--pf-t--global--font--size--heading--h3);
  }

  .pf-v6-c-modal-box__footer {
    padding-block-start: var(--pf-t--global--spacer--xl);
    padding-block-end: var(--pf-t--global--spacer--xl);
  }
  .pf-v6-c-modal-box__header {
    padding-block-end: var(--pf-t--global--spacer--lg);
  }
}

// ============================================================================
// Chatbot Display Mode - Fullscreen and Embedded
// ============================================================================
@media screen and (max-width: 600px) {
  .pf-chatbot__chatbot-modal--embedded,
  .pf-chatbot__chatbot-modal--fullscreen {
    inset-block-end: 0;
    inset-inline-end: 0;
    width: 100%;
    height: 100%;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }
}
@media screen and (min-width: 601px) {
  .pf-chatbot__chatbot-modal--embedded,
  .pf-chatbot__chatbot-modal--fullscreen {
    inset-block-end: 0;
    inset-inline-end: 0;
    width: 50% !important;
    height: fit-content !important;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }
}

// ============================================================================
// Chatbot Display Mode - Default
// ============================================================================
.pf-chatbot__chatbot-modal--default {
  box-shadow: unset !important;
}

// ============================================================================
// Chatbot Display Mode - Docked
// ============================================================================
.pf-chatbot__chatbot-modal--docked {
  height: 100vh;
  inset-block-end: 0;
  inset-inline-end: 0;
  border-radius: 0 !important;
  --pf-v6-c-modal-box--MaxHeight: 100vh !important;
  box-shadow: unset !important;
}

// ============================================================================
// Dark theme
// ============================================================================
.pf-v6-theme-dark {
  .pf-v6-c-modal-box.pf-chatbot__chatbot-modal {
    .pf-v6-c-modal-box__title {
      color: #fff;
    }
  }
}

// ============================================================================
// Backdrop
// ============================================================================
.pf-v6-c-backdrop.pf-chatbot__backdrop {
  position: absolute;
}

// ============================================================================
// Compact
// ============================================================================
.pf-chatbot__chatbot-modal.pf-m-compact {
  .pf-v6-c-modal-box__header {
    padding-block-end: 0;
  }

  .pf-v6-c-modal-box__footer {
    padding-block-start: var(--pf-t--global--spacer--lg);
    padding-block-end: var(--pf-t--global--spacer--lg);
  }
}



================================================
FILE: packages/module/src/ChatbotModal/ChatbotModal.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import ChatbotModal from './ChatbotModal';
import '@testing-library/jest-dom';
import { ModalBody, ModalHeader } from '@patternfly/react-core';

describe('ChatbotModal', () => {
  it('should render compact modal', () => {
    render(
      <ChatbotModal data-testid="modal" isCompact isOpen>
        <ModalHeader
          title="Modal with description"
          labelId="modal-with-description-title"
          description="A description is used when you want to provide more info about the modal than the title is able to describe. The content in the description is static and will not scroll with the rest of the modal body."
        />
        <ModalBody tabIndex={0} id="modal-box-body-with-description">
          Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore
          magna aliqua. Quis eleifend quam adipiscing vitae proin sagittis nisl rhoncus. Semper auctor neque vitae
          tempus. Diam donec adipiscing tristique risus. Augue eget arcu dictum varius duis. Ut enim blandit volutpat
          maecenas volutpat blandit aliquam. Sit amet mauris commodo quis imperdiet massa tincidunt. Habitant morbi
          tristique senectus et netus. Fames ac turpis egestas sed tempus urna. Neque laoreet suspendisse interdum
          consectetur libero id. Volutpat lacus laoreet non curabitur gravida arcu ac tortor. Porta nibh venenatis cras
          sed felis eget velit. Nullam non nisi est sit amet facilisis. Nunc mi ipsum faucibus vitae. Lorem sed risus
          ultricies tristique nulla aliquet enim tortor at. Egestas sed tempus urna et pharetra pharetra massa massa
          ultricies. Lacinia quis vel eros donec ac odio tempor orci. Malesuada fames ac turpis egestas integer eget
          aliquet.
          <br />
          <br />
          Neque aliquam vestibulum morbi blandit cursus risus at ultrices. Molestie at elementum eu facilisis sed odio
          morbi. Elit pellentesque habitant morbi tristique. Consequat nisl vel pretium lectus quam id leo in vitae.
          Quis varius quam quisque id diam vel quam elementum. Viverra nam libero justo laoreet sit amet cursus.
          Sollicitudin tempor id eu nisl nunc. Orci nulla pellentesque dignissim enim sit amet venenatis. Dignissim enim
          sit amet venenatis urna cursus eget. Iaculis at erat pellentesque adipiscing commodo elit. Faucibus pulvinar
          elementum integer enim neque volutpat. Nullam vehicula ipsum a arcu cursus vitae congue mauris. Nunc mattis
          enim ut tellus elementum sagittis vitae. Blandit cursus risus at ultrices. Tellus mauris a diam maecenas sed
          enim. Non diam phasellus vestibulum lorem sed risus ultricies tristique nulla.
          <br />
          <br />
          Nulla pharetra diam sit amet nisl suscipit adipiscing. Ac tortor vitae purus faucibus ornare suspendisse sed
          nisi. Sed felis eget velit aliquet sagittis id consectetur purus. Tincidunt tortor aliquam nulla facilisi cras
          fermentum. Volutpat est velit egestas dui id ornare arcu odio. Pharetra magna ac placerat vestibulum. Ultrices
          sagittis orci a scelerisque purus semper eget duis at. Nisi est sit amet facilisis magna etiam tempor orci eu.
          Convallis tellus id interdum velit. Facilisis sed odio morbi quis commodo odio aenean sed.
          <br />
          <br />
          Eu scelerisque felis imperdiet proin fermentum leo vel orci porta. Facilisi etiam dignissim diam quis enim
          lobortis scelerisque fermentum. Eleifend donec pretium vulputate sapien nec sagittis aliquam malesuada. Magna
          etiam tempor orci eu lobortis elementum. Quis auctor elit sed vulputate mi sit. Eleifend quam adipiscing vitae
          proin sagittis nisl rhoncus mattis rhoncus. Erat velit scelerisque in dictum non. Sit amet nulla facilisi
          morbi tempus iaculis urna. Enim ut tellus elementum sagittis vitae et leo duis ut. Lectus arcu bibendum at
          varius vel pharetra vel turpis. Morbi tristique senectus et netus et. Eget aliquet nibh praesent tristique
          magna sit amet purus gravida. Nisl purus in mollis nunc sed id semper risus. Id neque aliquam vestibulum
          morbi. Mauris a diam maecenas sed enim ut sem. Egestas tellus rutrum tellus pellentesque.
        </ModalBody>
      </ChatbotModal>
    );
    expect(screen.getByTestId('modal')).toHaveClass('pf-m-compact');
  });
});



================================================
FILE: packages/module/src/ChatbotModal/ChatbotModal.tsx
================================================
// ============================================================================
// Code Modal - Chatbot Modal with Code Editor
// ============================================================================
import React from 'react';

// Import PatternFly components
import { Modal, ModalProps } from '@patternfly/react-core';
import { ChatbotDisplayMode } from '../Chatbot';

export interface ChatbotModalProps extends Omit<ModalProps, 'ref'> {
  /** Display mode for the Chatbot parent; this influences the styles applied */
  displayMode?: ChatbotDisplayMode;
  /** Additional className applied to modal */
  className?: string;
  /** Sets modal to compact styling. */
  isCompact?: boolean;
}

export const ChatbotModal: React.FunctionComponent<ChatbotModalProps> = ({
  children,
  displayMode = ChatbotDisplayMode.default,
  className,
  isOpen,
  isCompact,
  ...props
}: ChatbotModalProps) => {
  const modal = (
    <Modal
      isOpen={isOpen}
      ouiaId="ChatbotModal"
      aria-labelledby="chatbot-modal-title"
      aria-describedby="chatbot-modal"
      className={`pf-chatbot__chatbot-modal pf-chatbot__chatbot-modal--${displayMode} ${isCompact ? 'pf-m-compact' : ''} ${className}`}
      backdropClassName="pf-chatbot__chatbot-modal-backdrop"
      {...props}
    >
      {children}
    </Modal>
  );

  if ((displayMode === ChatbotDisplayMode.fullscreen || displayMode === ChatbotDisplayMode.embedded) && isOpen) {
    return <div className="pf-v6-c-backdrop pf-chatbot__backdrop">{modal}</div>;
  }
  return modal;
};

export default ChatbotModal;



================================================
FILE: packages/module/src/ChatbotModal/index.ts
================================================
export { default } from './ChatbotModal';

export * from './ChatbotModal';



================================================
FILE: packages/module/src/ChatbotPopover/ChatbotPopover.scss
================================================
// ============================================================================
// Chatbot Popover
// ============================================================================
.pf-chatbot__popover {
  .pf-v6-c-popover__arrow {
    display: none;
  }

  // Footnote popover
  &--footnote.pf-chatbot__popover {
    // Contents
    img {
      border-radius: var(--pf-t--global--border--radius--small);
    }
    .pf-v6-c-content--h3 {
      font-weight: var(--pf-t--global--font--weight--body--bold);
    }
    .pf-v6-c-content--p {
      font-size: var(--pf-t--global--font--size--body--lg);
    }

    // Actions
    .pf-v6-c-button {
      font-weight: var(--pf-t--global--font--weight--body--bold);
      font-size: var(--pf-t--global--font--size--body--lg);
    }
    .pf-v6-c-content--a {
      font-size: var(--pf-t--global--font--size--body--lg);
    }
  }
}



================================================
FILE: packages/module/src/ChatbotPopover/ChatbotPopover.tsx
================================================
// ============================================================================
// Chatbot Popover
// ============================================================================
import React from 'react';

// Import PatternFly components
import { Popover, PopoverProps } from '@patternfly/react-core';

export const ChatbotPopover: React.FunctionComponent<PopoverProps> = ({ children, className, ...props }) => (
  <Popover className={`pf-chatbot__popover  ${className ?? ''}`} showClose={false} {...props}>
    {children}
  </Popover>
);

export default ChatbotPopover;



================================================
FILE: packages/module/src/ChatbotPopover/index.ts
================================================
export { default } from './ChatbotPopover';

export * from './ChatbotPopover';



================================================
FILE: packages/module/src/ChatbotToggle/ChatbotToggle.scss
================================================
// ============================================================================
// Toggle Chatbot
// ============================================================================
.pf-v6-c-button.pf-chatbot__button {
  position: fixed;
  inset-block-end: var(--pf-t--global--spacer--md);
  inset-inline-end: var(--pf-t--global--spacer--md);
  background-color: var(--pf-t--global--background--color--inverse--default);
  --pf-v6-c-button__icon--Color: var(--pf-t--chatbot-toggle--color);
  padding: var(--pf-t--global--spacer--md);

  &:hover,
  &:focus {
    background-color: var(--pf-t--chatbot-toggle--background--hover);
  }

  .pf-v6-c-button__icon {
    display: contents;
  }

  // Icon
  svg {
    width: var(--pf-t--global--spacer--lg);
    height: var(--pf-t--global--spacer--lg);
  }
}

.pf-chatbot__button--round {
  border-radius: var(--pf-t--global--border--radius--pill);
  width: 3rem;
  height: 3rem;
}



================================================
FILE: packages/module/src/ChatbotToggle/ChatbotToggle.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import userEvent from '@testing-library/user-event';
import ChatbotToggle from './ChatbotToggle';

describe('ChatbotToggle', () => {
  it('should render tooltipLabel correctly', async () => {
    render(<ChatbotToggle tooltipLabel="Tooltip" />);
    await userEvent.click(screen.getByRole('button', { name: /Tooltip toggle/i }));
    expect(screen.getByRole('tooltip', { name: /Tooltip/i })).toBeTruthy();
  });
  it('should render toggleButtonLabel correctly', async () => {
    render(<ChatbotToggle tooltipLabel="Chatbot" toggleButtonLabel="Button" />);
    expect(screen.getByRole('button', { name: /Button/i })).toBeTruthy();
  });
  it('should call onToggleChatbot when clicked', async () => {
    const spy = jest.fn();
    render(<ChatbotToggle tooltipLabel="Chatbot" onToggleChatbot={spy} />);
    await userEvent.click(screen.getByRole('button'));
    expect(spy).toHaveBeenCalledTimes(1);
  });
  it('should handle isChatbotVisible correctly when true', () => {
    render(<ChatbotToggle tooltipLabel="Chatbot" isChatbotVisible openIconTestId="Open" />);
    expect(screen.getByRole('button')).toHaveClass('pf-chatbot__button');
    expect(screen.getByRole('button')).toHaveClass('pf-chatbot__button--active');
    expect(screen.getByRole('button')).toHaveAttribute('aria-expanded', 'true');
    expect(screen.getByTestId('Open')).toBeTruthy();
  });
  it('should handle isChatbotVisible correctly when false', () => {
    render(<ChatbotToggle tooltipLabel="Chatbot" isChatbotVisible={false} openIconTestId="Open" />);
    expect(screen.getByRole('button')).toHaveClass('pf-chatbot__button');
    expect(screen.getByRole('button')).not.toHaveClass('pf-chatbot__button--active');
    expect(screen.getByRole('button')).toHaveAttribute('aria-expanded', 'false');
    expect(screen.queryByTestId('Open')).toBeFalsy();
  });
  it('should handle isRound correctly', () => {
    render(<ChatbotToggle tooltipLabel="Chatbot" isRound />);
    expect(screen.getByRole('button')).toHaveClass('pf-chatbot__button');
    expect(screen.getByRole('button')).toHaveClass('pf-chatbot__button--round');
  });
  it('should handle className correctly', () => {
    render(<ChatbotToggle tooltipLabel="Chatbot" className="test" />);
    expect(screen.getByRole('button')).toHaveClass('pf-chatbot__button');
    expect(screen.getByRole('button')).toHaveClass('test');
  });
});



================================================
FILE: packages/module/src/ChatbotToggle/ChatbotToggle.tsx
================================================
// ============================================================================
// Chatbot Toggle
// ============================================================================
import React from 'react';
import { Button, ButtonProps, Tooltip, TooltipProps, Icon } from '@patternfly/react-core';
import AngleDownIcon from '@patternfly/react-icons/dist/esm/icons/angle-down-icon';

export interface ChatbotToggleProps extends ButtonProps {
  /** Contents of the tooltip applied to the toggle button */
  tooltipLabel: React.ReactNode;
  /** Props spread to the PF Tooltip component */
  tooltipProps?: Omit<TooltipProps, 'content'>;
  /** Flag indicating visibility of the chatbot appended to the toggle */
  isChatbotVisible?: boolean;
  /** Callback fired when toggle button is clicked */
  onToggleChatbot?: () => void;
  /** Accessible label for the toggle button */
  toggleButtonLabel?: string;
  /** An image displayed in the chatbot toggle when it is closed */
  closedToggleIcon?: () => JSX.Element;
  /** Ref applied to toggle */
  innerRef?: React.Ref<HTMLButtonElement>;
  /** Whether toggle is a circle */
  isRound?: boolean;
  /** Class name applied to toggle */
  className?: string;
  /** Test id applied to default open icon */
  openIconTestId?: string;
}

const ChatIcon = () => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
    <path
      fill="var(--pf-t--global--icon--color--inverse)"
      stroke="var(--pf-t--global--icon--color--inverse)"
      strokeLinejoin="round"
      strokeWidth=".75"
      d="M3.577 14.382c0 .198.12.38.31.46l.19.04a.492.492 0 0 0 .349-.143l3.028-3.028h8.513a.489.489 0 0 0 .492-.492V2.491A.489.489 0 0 0 15.967 2H1.691a.489.489 0 0 0-.492.491v8.728c0 .135.056.262.143.349a.498.498 0 0 0 .349.143h1.878v2.663h.008v.008ZM2.19 10.72V2.983h13.278v7.729H7.24a.512.512 0 0 0-.35.143l-2.322 2.322v-1.974a.498.498 0 0 0-.142-.348.492.492 0 0 0-.35-.143H2.19v.008Z"
    />
    <path
      fill="var(--pf-t--global--text--color--inverse)"
      stroke="var(--pf-t--global--text--color--inverse)"
      strokeLinejoin="round"
      strokeWidth=".75"
      d="M22.301 9.135h-3.963a.489.489 0 0 0-.492.491c0 .27.222.492.492.492h3.472v7.737h-1.88a.404.404 0 0 0-.348.134.492.492 0 0 0-.143.35v1.973l-2.322-2.323a.492.492 0 0 0-.349-.142H8.532v-4.265a.489.489 0 0 0-.492-.492.494.494 0 0 0-.491.492v4.756c0 .277.222.492.491.492h8.514l3.028 3.028a.492.492 0 0 0 .349.142l.19-.04a.502.502 0 0 0 .31-.459V18.83h1.878c.111-.008.262-.048.349-.135a.491.491 0 0 0 .142-.349v-8.72a.489.489 0 0 0-.491-.491h-.008Z"
    />
  </svg>
);

const ChatbotToggleBase: React.FunctionComponent<ChatbotToggleProps> = ({
  tooltipLabel,
  isChatbotVisible,
  onToggleChatbot,
  tooltipProps,
  toggleButtonLabel,
  closedToggleIcon: ClosedToggleIcon,
  innerRef,
  isRound = true,
  className,
  openIconTestId,
  ...props
}: ChatbotToggleProps) => {
  // Configure icon
  const closedIcon = ClosedToggleIcon ? <ClosedToggleIcon /> : <ChatIcon />;
  const icon = isChatbotVisible ? <AngleDownIcon data-testid={openIconTestId} /> : closedIcon;

  return (
    <Tooltip
      content={tooltipLabel}
      // prevents VO announcements of both aria label and tooltip
      aria="none"
      {...tooltipProps}
    >
      <Button
        className={`pf-chatbot__button ${isChatbotVisible ? 'pf-chatbot__button--active' : ''} ${isRound ? 'pf-chatbot__button--round' : ''} ${className ? className : ''}`}
        variant="plain"
        aria-label={toggleButtonLabel || `${tooltipLabel} toggle`}
        onClick={onToggleChatbot}
        aria-expanded={isChatbotVisible}
        icon={<Icon isInline>{icon}</Icon>}
        ref={innerRef}
        {...props}
      >
        {/* Notification dot placeholder */}
      </Button>
    </Tooltip>
  );
};

const ChatbotToggle = React.forwardRef((props: ChatbotToggleProps, ref: React.Ref<any>) => (
  <ChatbotToggleBase innerRef={ref} {...props} />
));

export default ChatbotToggle;



================================================
FILE: packages/module/src/ChatbotToggle/index.ts
================================================
export { default } from './ChatbotToggle';

export * from './ChatbotToggle';



================================================
FILE: packages/module/src/ChatbotWelcomePrompt/ChatbotWelcomePrompt.scss
================================================
// ============================================================================
// Chatbot Layout - Chat - Welcome
// ============================================================================
.pf-chatbot--layout--welcome {
  padding-block-end: var(--pf-t--global--spacer--lg);
  flex-direction: column;
  display: flex;
  gap: var(--pf-t--global--spacer--lg);

  .pf-v6-c-content--h1 {
    --pf-v6-c-content--h1--FontWeight: var(--pf-t--global--font--weight--400);
    --pf-v6-c-content--h1--MarginBlockEnd: 0;
  }

  .pf-chatbot__hello {
    color: var(--pf-t--global--color--brand--default);
  }

  .pf-chatbot__question {
    color: var(--pf-t--global--text--color--subtle);
  }

  .pf-chatbot__prompt-suggestions {
    flex-direction: column;
    display: flex;
    gap: var(--pf-t--global--spacer--lg);
  }

  .pf-chatbot__prompt-suggestions > * {
    flex: 1;
    overflow: visible;
    height: 100%;
  }
}

.pf-chatbot--layout--welcome.pf-m-compact {
  gap: var(--pf-t--global--spacer--md);
  padding-block-end: var(--pf-t--global--spacer--md);

  .pf-chatbot__prompt-suggestions {
    gap: var(--pf-t--global--spacer--md);
  }
}

// ============================================================================
// Chatbot Display Mode - Fullscreen and Embedded
// ============================================================================
@media screen and (min-width: 64rem) {
  .pf-chatbot--fullscreen,
  .pf-chatbot--embedded {
    .pf-chatbot--layout--welcome {
      .pf-chatbot__prompt-suggestions {
        flex-direction: row;
        align-items: baseline;
      }
    }
  }
}



================================================
FILE: packages/module/src/ChatbotWelcomePrompt/ChatbotWelcomePrompt.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import ChatbotWelcomePrompt from './ChatbotWelcomePrompt';
import userEvent from '@testing-library/user-event';

describe('ChatbotWelcomePrompt', () => {
  it('should render welcome prompt', () => {
    const { container } = render(
      <ChatbotWelcomePrompt title="Hi, ChatBot User!" description="How can I help you today?" />
    );
    expect(container).toMatchSnapshot();
  });

  it('should render correctly', () => {
    render(<ChatbotWelcomePrompt title="Hi, ChatBot User!" description="How can I help you today?" />);
    expect(screen.getByText('Hi, ChatBot User!')).toBeTruthy();
    expect(screen.getByText('How can I help you today?')).toBeTruthy();
  });
  it('should render prompts with titles correctly', () => {
    render(
      <ChatbotWelcomePrompt
        title="Hi, ChatBot User!"
        description="How can I help you today?"
        prompts={[{ title: 'Set up account' }]}
      />
    );
    expect(screen.getByText('Set up account')).toBeTruthy();
  });
  it('should render prompts with messages correctly', () => {
    render(
      <ChatbotWelcomePrompt
        title="Hi, ChatBot User!"
        description="How can I help you today?"
        prompts={[
          { title: 'Set up account', message: 'Choose the necessary settings and preferences for your account.' }
        ]}
      />
    );
    expect(screen.getByText('Choose the necessary settings and preferences for your account.')).toBeTruthy();
  });
  it('should render prompts with onClick correctly', async () => {
    const spy = jest.fn();
    render(
      <ChatbotWelcomePrompt
        title="Hi, ChatBot User!"
        description="How can I help you today?"
        prompts={[
          {
            title: 'Set up account',
            message: 'Choose the necessary settings and preferences for your account.',
            onClick: spy
          }
        ]}
      />
    );
    await userEvent.click(screen.getByRole('button', { name: /Set up account/i }));
    expect(spy).toHaveBeenCalled();
  });
  it('should apply className appropriately', () => {
    render(
      <ChatbotWelcomePrompt
        title="Hi, ChatBot User!"
        description="How can I help you today?"
        className="test"
        testId="welcome-prompt"
      />
    );
    const element = screen.getByTestId('welcome-prompt');
    expect(element).toHaveClass('test');
  });

  it('should handle isCompact', () => {
    render(
      <ChatbotWelcomePrompt
        title="Hi, ChatBot User!"
        description="How can I help you today?"
        className="test"
        testId="welcome-prompt"
        isCompact
      />
    );
    expect(screen.getByTestId('welcome-prompt')).toHaveClass('pf-m-compact');
  });
});



================================================
FILE: packages/module/src/ChatbotWelcomePrompt/ChatbotWelcomePrompt.tsx
================================================
// ============================================================================
// Chatbot Layout - Chat - Welcome
// ============================================================================
import React from 'react';

import { Content, ContentVariants, Card, CardHeader, CardTitle, CardBody } from '@patternfly/react-core';

export interface ChatbotWelcomePromptProps extends React.HTMLProps<HTMLDivElement> {
  /** Title for the welcome message*/
  title: string;
  /** Welcome message */
  description: string;
  /** Custom basic prompts to help users coming for the first time to chatbot */
  prompts?: WelcomePrompt[];
  /** Custom classname for the WelcomePrompt component */
  className?: string;
  /** Custom test id for the WelcomePrompt component */
  testId?: string;
  isCompact?: boolean;
}

export interface WelcomePrompt {
  /** Message for the welcome prompt */
  message?: string;
  /** Title for the welcome prompt */
  title: string;
  /** Callback handler for the onClick event for welcome prompt */
  onClick?: () => void;
}

export const ChatbotWelcomePrompt: React.FunctionComponent<ChatbotWelcomePromptProps> = ({
  title,
  description,
  prompts,
  className,
  testId,
  isCompact = false,
  ...props
}: ChatbotWelcomePromptProps) => (
  <div
    data-testid={testId}
    className={`pf-chatbot--layout--welcome ${isCompact ? 'pf-m-compact' : ''} ${className ?? ''}`}
    {...props}
  >
    <Content component={ContentVariants.h1}>
      <span className="pf-chatbot__hello">{title}</span>
      <br />
      <span className="pf-chatbot__question">{description}</span>
    </Content>

    {prompts && (
      <div className="pf-chatbot__prompt-suggestions">
        {prompts?.map((prompt, index) => (
          <Card
            key={`welcome-prompt-${index}`}
            className="pf-chatbot__prompt-suggestion"
            isClickable
            isCompact={isCompact}
          >
            <CardHeader
              selectableActions={{
                onClickAction: prompt.onClick,
                selectableActionId: `welcome-prompt-input-${index}`,
                selectableActionAriaLabelledby: `welcome-prompt-title-${index}`
              }}
            >
              <CardTitle id={`welcome-prompt-title-${index}`}>{prompt.title}</CardTitle>
            </CardHeader>
            {prompt.message && <CardBody>{prompt.message}</CardBody>}
          </Card>
        ))}
      </div>
    )}
  </div>
);

export default ChatbotWelcomePrompt;



================================================
FILE: packages/module/src/ChatbotWelcomePrompt/index.ts
================================================
export { default } from './ChatbotWelcomePrompt';

export * from './ChatbotWelcomePrompt';



================================================
FILE: packages/module/src/ChatbotWelcomePrompt/__snapshots__/ChatbotWelcomePrompt.test.tsx.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`ChatbotWelcomePrompt should render welcome prompt 1`] = `
<div>
  <div
    class="pf-chatbot--layout--welcome  "
  >
    <h1
      class="pf-v6-c-content--h1"
      data-ouia-component-id="OUIA-Generated-Content-1"
      data-ouia-component-type="PF6/Content"
      data-ouia-safe="true"
      data-pf-content="true"
    >
      <span
        class="pf-chatbot__hello"
      >
        Hi, ChatBot User!
      </span>
      <br />
      <span
        class="pf-chatbot__question"
      >
        How can I help you today?
      </span>
    </h1>
  </div>
</div>
`;



================================================
FILE: packages/module/src/CodeModal/CodeModal.scss
================================================
.pf-chatbot__code-modal {
  .pf-v6-c-code-editor {
    --pf-v6-c-code-editor__main--BackgroundColor: #1f1f1f;
    --pf-v6-c-code-editor__main--BorderEndStartRadius: 0;
    --pf-v6-c-code-editor__main--BorderEndEndRadius: 0;
    --pf-v6-c-code-editor__tab--BorderStartEndRadius: var(--pf-t--global--border--radius--small);
    --pf-v6-c-code-editor--m-read-only__main--BackgroundColor: #1f1f1f;
  }
  .pf-v6-c-code-editor__header {
    background: #1f1f1f !important;
    /** this is for the attachment editor header */
    border-start-start-radius: var(--pf-t--global--border--radius--small);
    border-start-end-radius: var(--pf-t--global--border--radius--small);
  }
  .pf-chatbot__code-modal-body {
    gap: var(--pf-t--global--spacer--lg);
  }
  .pf-chatbot__code-modal--controls > .pf-v6-c-code-editor__header {
    flex-direction: row-reverse;
    border-radius: var(--pf-t--global--border--radius--small);
  }
  .pf-v6-c-code-editor__header::before {
    border-block-end: none;
  }
  .pf-v6-c-code-editor__header-content {
    --pf-v6-c-code-editor__header-content--BackgroundColor: #1f1f1f;
    --pf-v6-c-code-editor__header-content--m-plain--BackgroundColor: #1f1f1f;
    --pf-v6-c-code-editor__header-content--BorderStartStartRadius: var(
      --pf-t--global--border--radius--small
    ) !important;
    --pf-v6-c-code-editor__header-content--PaddingInlineEnd: 0;
    justify-content: flex-end;
  }
  .pf-chatbot__code-modal--controls > .pf-v6-c-code-editor__header > .pf-v6-c-code-editor__header-content {
    --pf-v6-c-code-editor__header-content--BorderStartStartRadius: 0;
    border-start-end-radius: var(--pf-t--global--border--radius--small);
  }
  .pf-v6-c-code-editor__tab {
    --pf-v6-c-code-editor__tab--BackgroundColor: #1f1f1f;
    --pf-v6-c-code-editor__tab--Color: #fff;
    border: none;
    --pf-v6-c-code-editor__tab--BorderStartEndRadius: 0;
    border-start-start-radius: var(--pf-t--global--border--radius--small);
    --pf-t--global--font--weight--body--default: var(--pf-t--global--font--weight--body--bold);
  }
  .pf-v6-c-code-editor__tab-icon {
    display: none;
  }
  .pf-v6-c-code-editor__main {
    border: unset;
    --pf-v6-c-code-editor__main--BorderEndStartRadius: var(--pf-t--global--border--radius--small);
    --pf-v6-c-code-editor__main--BorderEndEndRadius: var(--pf-t--global--border--radius--small);
  }
  .pf-v6-c-code-editor__controls {
    padding-right: var(--pf-t--global--spacer--sm);
  }
  .pf-v6-c-code-editor__controls > div > .pf-v6-c-button {
    --pf-v6-c-button--m-plain__icon--Color: #fff;
    --pf-v6-c-button--hover__icon--Color: #fff;
  }
  .pf-v6-c-code-editor__header-main {
    display: none;
  }
  .pf-v6-c-modal-box__close {
    .pf-v6-c-button.pf-m-plain {
      --pf-v6-c-button__icon--Color: var(--pf-t--global--icon--color--subtle);
    }
  }
}

// ============================================================================
// Dark theme
// ============================================================================
.pf-v6-theme-dark {
  .pf-chatbot__code-modal {
    .pf-v6-c-code-editor__controls > div > button {
      --pf-v6-c-button--m-plain__icon--Color: #c7c7c7;
      --pf-v6-c-button--hover__icon--Color: #c7c7c7;
    }
  }
}

.pf-chatbot__code-modal-editor {
  flex: 1;
}

.pf-chatbot__code-modal--fullscreen {
  height: inherit !important; // override shared modal so code editor works in full screen
}

.pf-chatbot__code-modal.pf-m-compact {
  .pf-chatbot__code-modal-body {
    gap: var(--pf-t--global--spacer--md);
  }
}



================================================
FILE: packages/module/src/CodeModal/CodeModal.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import CodeModal from './CodeModal';

describe('ChatbotModal', () => {
  it('should render compact modal', () => {
    render(
      <CodeModal
        isCompact
        code="Hello world"
        fileName="greetings.txt"
        isModalOpen={true}
        handleModalToggle={jest.fn()}
        onPrimaryAction={jest.fn()}
        onSecondaryAction={jest.fn()}
        title="Preview attachment"
        primaryActionBtn="Submit"
        secondaryActionBtn="Cancel"
      ></CodeModal>
    );
    expect(screen.getByRole('dialog')).toHaveClass('pf-m-compact');
  });
});



================================================
FILE: packages/module/src/CodeModal/CodeModal.tsx
================================================
// ============================================================================
// Code Modal - Chatbot Modal with Code Editor
// ============================================================================
import React from 'react';
import path from 'path-browserify';

// Import PatternFly components
import { CodeEditor } from '@patternfly/react-code-editor';
import { Button, ModalBody, ModalFooter, ModalHeader, Stack, StackItem } from '@patternfly/react-core';
import FileDetails, { extensionToLanguage } from '../FileDetails';
import { ChatbotDisplayMode } from '../Chatbot';
import ChatbotModal from '../ChatbotModal/ChatbotModal';

export interface CodeModalProps {
  /** Class applied to code editor */
  codeEditorControlClassName?: string;
  /** Text shown in code editor */
  code: string;
  /** Filename, including extension, of file shown in editor */
  fileName: string;
  /** Whether copying code is allowed */
  isCopyEnabled?: boolean;
  /** Whether line numbers show in the code editor */
  isLineNumbersVisible?: boolean;
  /** Whether code is read-only */
  isReadOnly?: boolean;
  /** Action assigned to primary modal button */
  onPrimaryAction: (event: React.MouseEvent | MouseEvent | KeyboardEvent, code?: string) => void;
  /** Action assigned to secondary modal button */
  onSecondaryAction: (event: React.MouseEvent | MouseEvent | KeyboardEvent) => void;
  /** Name of primary modal button */
  primaryActionBtn: string;
  /** Name of secondary modal button */
  secondaryActionBtn: string;
  /** Function that handles modal toggle */
  handleModalToggle: (event: React.MouseEvent | MouseEvent | KeyboardEvent) => void;
  /** Whether modal is open */
  isModalOpen: boolean;
  /** Title of modal */
  title: string;
  /** Display mode for the Chatbot parent; this influences the styles applied */
  displayMode?: ChatbotDisplayMode;
  /** Sets modal to compact styling. */
  isCompact?: boolean;
}

export const CodeModal: React.FunctionComponent<CodeModalProps> = ({
  fileName,
  code,
  codeEditorControlClassName: codeEditorClassName,
  handleModalToggle,
  isCopyEnabled,
  isLineNumbersVisible,
  isModalOpen,
  isReadOnly,
  onPrimaryAction,
  onSecondaryAction,
  primaryActionBtn,
  secondaryActionBtn,
  title,
  displayMode = ChatbotDisplayMode.default,
  isCompact,
  ...props
}: CodeModalProps) => {
  const [newCode, setNewCode] = React.useState(code);

  const handlePrimaryAction = (_event: React.MouseEvent | MouseEvent | KeyboardEvent) => {
    handleModalToggle(_event);
    if (!isReadOnly) {
      onPrimaryAction(_event, newCode);
    } else {
      onPrimaryAction(_event);
    }
  };

  const handleSecondaryAction = (_event: React.MouseEvent | MouseEvent | KeyboardEvent) => {
    handleModalToggle(_event);
    onSecondaryAction(_event);
  };

  const onEditorDidMount = (editor, monaco) => {
    editor.layout();
    editor.focus();
    monaco.editor.getModels()[0].updateOptions({ tabSize: 5 });
  };

  const onCodeChange = (value: string) => {
    if (!isReadOnly) {
      setNewCode(value);
    }
  };

  const modal = (
    <ChatbotModal
      isOpen={isModalOpen}
      onClose={handleModalToggle}
      ouiaId="CodeModal"
      aria-labelledby="code-modal-title"
      aria-describedby="code-modal"
      className={`pf-chatbot__code-modal ${isCompact ? 'pf-m-compact' : ''} pf-chatbot__code-modal--${displayMode}`}
      displayMode={displayMode}
      isCompact={isCompact}
    >
      <ModalHeader title={title} labelId="code-modal-title" />
      <ModalBody id="code-modal-body">
        <Stack className="pf-chatbot__code-modal-body">
          <StackItem className="pf-chatbot__code-modal-file-details">
            <FileDetails fileName={fileName} />
          </StackItem>
          <StackItem className="pf-chatbot__code-modal-editor">
            <CodeEditor
              isDarkTheme
              isLineNumbersVisible={isLineNumbersVisible}
              isLanguageLabelVisible
              isCopyEnabled={isCopyEnabled}
              isReadOnly={isReadOnly}
              code={newCode}
              language={extensionToLanguage[path.extname(fileName).slice(1)]}
              onEditorDidMount={onEditorDidMount}
              onCodeChange={onCodeChange}
              className={codeEditorClassName}
              isFullHeight
              options={{
                glyphMargin: false,
                folding: false
              }}
              {...props}
            />
          </StackItem>
        </Stack>
      </ModalBody>
      <ModalFooter>
        <Button isBlock key="code-modal-primary" variant="primary" onClick={handlePrimaryAction} form="code-modal-form">
          {primaryActionBtn}
        </Button>
        <Button isBlock key="code-modal-secondary" variant="link" onClick={handleSecondaryAction}>
          {secondaryActionBtn}
        </Button>
      </ModalFooter>
    </ChatbotModal>
  );

  return modal;
};

export default CodeModal;



================================================
FILE: packages/module/src/CodeModal/index.ts
================================================
export { default } from './CodeModal';

export * from './CodeModal';



================================================
FILE: packages/module/src/Compare/Compare.scss
================================================
.pf-chatbot__compare-container {
  display: flex;
  flex-direction: column;
  position: relative;
  height: 100%;
}
.pf-chatbot__compare-toggle {
  width: 100%;

  .pf-v6-c-toggle-group__button {
    width: 100%;
    display: flex;
    justify-content: center;
  }
}
.pf-chatbot__compare {
  display: flex;
  height: 100%;
  width: 100%;

  @media screen and (max-width: 900px) {
    overflow-y: auto;
  }

  .pf-chatbot__compare-item:first-of-type {
    border-right: 1px solid var(--pf-t--global--border--color--default);

    @media screen and (max-width: 900px) {
      border-right: 0px;
    }
  }
}

.pf-chatbot__compare-item {
  flex: 1;

  .pf-chatbot--embedded .pf-chatbot__messagebox {
    width: 100%;
  }

  .pf-chatbot__content {
    padding: 0;
  }

  .pf-chatbot.pf-chatbot--embedded {
    @media screen and (max-width: 900px) {
      height: 100%;
    }
  }
}
.pf-chatbot__compare-item-hidden {
  display: block;

  @media screen and (max-width: 900px) {
    display: none;
  }
}

.pf-chatbot__compare-mobile-controls {
  padding: var(--pf-t--global--spacer--md) var(--pf-t--global--spacer--lg) 0 var(--pf-t--global--spacer--lg);
  display: none;
  background-color: var(--pf-t--global--background--color--secondary--default);
  position: sticky;
  top: 0;
  z-index: 9999;

  @media screen and (max-width: 900px) {
    display: flex;
    flex-direction: column;
    gap: var(--pf-t--global--spacer--md);
  }
}



================================================
FILE: packages/module/src/Compare/Compare.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import Compare from './Compare';

const firstChild = (
  <div>
    <h1>Child 1</h1>
  </div>
);

const secondChild = (
  <div>
    <h1>Child 2</h1>
  </div>
);

describe('Compare', () => {
  it('should render compare correctly', () => {
    render(
      <Compare
        firstChildDisplayName="Child 1"
        secondChildDisplayName="Child 2"
        firstChild={firstChild}
        secondChild={secondChild}
      />
    );
    expect(screen.getByRole('heading', { name: /Child 1/i })).toBeTruthy();
    expect(screen.getByRole('heading', { name: /Child 2/i })).toBeTruthy();
  });
});



================================================
FILE: packages/module/src/Compare/Compare.tsx
================================================
import React, { PropsWithChildren } from 'react';
import { ToggleGroup, ToggleGroupItem } from '@patternfly/react-core';

interface CompareProps {
  /** First of two children to render */
  firstChild: React.ReactNode;
  /** Second of two children to render */
  secondChild: React.ReactNode;
  /** Display name for first child, used in mobile toggle */
  firstChildDisplayName: string;
  /** Display name for second child, used in mobile toggle */
  secondChildDisplayName: string;
  /** Aria label for mobile toggle group */
  toggleGroupAriaLabel?: string;
  /** Callback for when mobile toggle is used */
  onToggleClick?: (event: MouseEvent | React.MouseEvent<any, MouseEvent> | React.KeyboardEvent<Element>) => void;
}

export const Compare = ({
  firstChild,
  secondChild,
  firstChildDisplayName,
  secondChildDisplayName,
  onToggleClick,
  toggleGroupAriaLabel = 'Select which chatbot to display'
}: PropsWithChildren<CompareProps>) => {
  const [isSelected, setIsSelected] = React.useState('toggle-group-chatbot-1');
  const [showFirstChatbot, setShowFirstChatbot] = React.useState(true);
  const [showSecondChatbot, setShowSecondChatbot] = React.useState(false);

  React.useEffect(() => {
    // we want to show the first if we switch to the mobile toggle view
    // and reset/switch back to normal otherwise
    const updateChatbotVisibility = () => {
      if (window.innerWidth >= 901) {
        setShowFirstChatbot(true);
        setShowSecondChatbot(true);
      } else {
        setShowFirstChatbot(true);
        setShowSecondChatbot(false);
        setIsSelected('toggle-group-chatbot-1');
      }
    };
    window.addEventListener('resize', updateChatbotVisibility);

    return () => {
      window.removeEventListener('resize', updateChatbotVisibility);
    };
  }, []);

  // this only happens on mobile
  const handleChildToggleClick = (
    event: MouseEvent | React.MouseEvent<any, MouseEvent> | React.KeyboardEvent<Element>
  ) => {
    const id = event.currentTarget.id;
    setIsSelected(id);
    setShowSecondChatbot(!showSecondChatbot);
    setShowFirstChatbot(!showFirstChatbot);
    onToggleClick && onToggleClick(event);
  };

  return (
    <>
      <div className="pf-chatbot__compare-mobile-controls">
        <ToggleGroup aria-label={toggleGroupAriaLabel}>
          <ToggleGroupItem
            className="pf-chatbot__compare-toggle"
            text={firstChildDisplayName}
            buttonId="toggle-group-chatbot-1"
            isSelected={isSelected === 'toggle-group-chatbot-1'}
            onChange={handleChildToggleClick}
          />
          <ToggleGroupItem
            className="pf-chatbot__compare-toggle"
            text={secondChildDisplayName}
            buttonId="toggle-group-chatbot-2"
            isSelected={isSelected === 'toggle-group-chatbot-2'}
            onChange={handleChildToggleClick}
          />
        </ToggleGroup>
      </div>
      <div className="pf-chatbot__compare">
        <div
          className={`pf-chatbot__compare-item ${!showFirstChatbot ? 'pf-chatbot__compare-item-hidden' : undefined}`}
        >
          {firstChild}
        </div>
        <div
          className={`pf-chatbot__compare-item ${!showSecondChatbot ? 'pf-chatbot__compare-item-hidden' : undefined}`}
        >
          {secondChild}
        </div>
      </div>
    </>
  );
};

export default Compare;



================================================
FILE: packages/module/src/Compare/index.ts
================================================
export { default } from './Compare';
export * from './Compare';



================================================
FILE: packages/module/src/FileDetails/FileDetails.scss
================================================
.pf-chatbot__code-language {
  color: var(--pf-t--global--text--color--subtle);
  display: flex; // this is needed for when FileDetailsLabel is clickable
  font-size: var(--pf-t--global--icon--size--font--xs);
  font-weight: var(--pf-t--global--font--weight--body--bold);
}

.pf-chatbot__code-icon {
  color: var(--pf-t--global--icon--color--status--custom--default);
  width: 24px;
  height: 24px;
}

.pf-chatbot__code-fileName {
  font-size: var(--pf-t--global--font--size--body--default);
}

// This is used in demos only
.pf-chatbot__file-details-example {
  background: var(--pf-t--global--background--color--secondary--default);
  height: 100px;
  display: flex;
  justify-content: center;
  align-items: center;
}



================================================
FILE: packages/module/src/FileDetails/FileDetails.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import FileDetails from './FileDetails';

describe('FileDetails', () => {
  it('should render file details', () => {
    const { container } = render(<FileDetails fileName="test.txt" />);
    expect(container).toMatchSnapshot();
  });

  it('should render file details correctly if an extension we support is passed in', () => {
    render(<FileDetails fileName="test.txt" languageTestId="language" />);
    expect(screen.getByText('test')).toBeTruthy();
    expect(screen.getByText('TEXT')).toBeTruthy();
    expect(screen.getByTestId('language')).toBeTruthy();
  });
  it('should skip language if we do not support an extension', () => {
    render(<FileDetails fileName="test.joke" languageTestId="language" />);
    expect(screen.getByText('test')).toBeTruthy();
    expect(screen.queryByTestId('language')).toBeFalsy();
  });
});



================================================
FILE: packages/module/src/FileDetails/FileDetails.tsx
================================================
import React, { PropsWithChildren } from 'react';
import { Flex, Stack, StackItem, Truncate } from '@patternfly/react-core';
import path from 'path-browserify';
interface FileDetailsProps {
  /** Class name applied to container */
  className?: string;
  /** Name of file, including extension */
  fileName: string;
  /** Custom test id for the component-generated language */
  languageTestId?: string;
  /** Class name applied to file name */
  fileNameClassName?: string;
}

// source https://gist.github.com/ppisarczyk/43962d06686722d26d176fad46879d41
// FIXME We could probably check against the PF Language hash to trim this down to what the code editor supports.
// I can also see an argument to leaving this open, or researching what the third-party we use for uploads is using
// so we can better scrape this from that. It gives us back stuff like 'application/x-yaml', while we really just need
// a mapping of 'yml' to 'yaml.' I'm leery of splitting strings with unknown format.
export const extensionToLanguage = {
  '1': 'Groff',
  '2': 'Groff',
  '3': 'Groff',
  '4': 'Groff',
  '5': 'Groff',
  '6': 'Groff',
  '7': 'Groff',
  '8': 'Groff',
  '9': 'Groff',
  abap: 'ABAP',
  asc: 'Public Key',
  ash: 'AGS Script',
  ampl: 'AMPL',
  mod: 'XML',
  g4: 'ANTLR',
  apib: 'API Blueprint',
  apl: 'APL',
  dyalog: 'APL',
  asp: 'ASP',
  asax: 'ASP',
  ascx: 'ASP',
  ashx: 'ASP',
  asmx: 'ASP',
  aspx: 'ASP',
  axd: 'ASP',
  dats: 'ATS',
  hats: 'ATS',
  sats: 'ATS',
  as: 'ActionScript',
  adb: 'Ada',
  ada: 'Ada',
  ads: 'Ada',
  agda: 'Agda',
  als: 'Alloy',
  apacheconf: 'ApacheConf',
  vhost: 'Nginx',
  cls: 'Visual Basic',
  applescript: 'AppleScript',
  scpt: 'AppleScript',
  arc: 'Arc',
  ino: 'Arduino',
  asciidoc: 'AsciiDoc',
  adoc: 'AsciiDoc',
  aj: 'AspectJ',
  asm: 'Assembly',
  a51: 'Assembly',
  inc: 'SourcePawn',
  nasm: 'Assembly',
  aug: 'Augeas',
  ahk: 'AutoHotkey',
  ahkl: 'AutoHotkey',
  au3: 'AutoIt',
  awk: 'Awk',
  auk: 'Awk',
  gawk: 'Awk',
  mawk: 'Awk',
  nawk: 'Awk',
  bat: 'Batchfile',
  cmd: 'Batchfile',
  befunge: 'Befunge',
  bison: 'Bison',
  bb: 'BlitzBasic',
  decls: 'BlitzBasic',
  bmx: 'BlitzMax',
  bsv: 'Bluespec',
  boo: 'Boo',
  b: 'Limbo',
  bf: 'HyPhy',
  brs: 'Brightscript',
  bro: 'Bro',
  c: 'C',
  cats: 'C',
  h: 'Objective-C',
  idc: 'C',
  w: 'C',
  cs: 'Smalltalk',
  cake: 'CoffeeScript',
  cshtml: 'C#',
  csx: 'C#',
  cpp: 'C++',
  'c++': 'C++',
  cc: 'C++',
  cp: 'Component Pascal',
  cxx: 'C++',
  'h++': 'C++',
  hh: 'Hack',
  hpp: 'C++',
  hxx: 'C++',
  inl: 'C++',
  ipp: 'C++',
  tcc: 'C++',
  tpp: 'C++',
  'c-objdump': 'C-ObjDump',
  chs: 'C2hs Haskell',
  clp: 'CLIPS',
  cmake: 'CMake',
  'cmake.in': 'CMake',
  cob: 'COBOL',
  cbl: 'COBOL',
  ccp: 'COBOL',
  cobol: 'COBOL',
  cpy: 'COBOL',
  css: 'CSS',
  csv: 'CSV',
  capnp: "Cap'n Proto",
  mss: 'CartoCSS',
  ceylon: 'Ceylon',
  chpl: 'Chapel',
  ch: 'xBase',
  ck: 'ChucK',
  cirru: 'Cirru',
  clw: 'Clarion',
  icl: 'Clean',
  dcl: 'Clean',
  click: 'Click',
  clj: 'Clojure',
  boot: 'Clojure',
  cl2: 'Clojure',
  cljc: 'Clojure',
  cljs: 'Clojure',
  'cljs.hl': 'Clojure',
  cljscm: 'Clojure',
  cljx: 'Clojure',
  hic: 'Clojure',
  coffee: 'CoffeeScript',
  _coffee: 'CoffeeScript',
  cjsx: 'CoffeeScript',
  cson: 'CoffeeScript',
  iced: 'CoffeeScript',
  cfm: 'ColdFusion',
  cfml: 'ColdFusion',
  cfc: 'ColdFusion CFC',
  lisp: 'NewLisp',
  asd: 'Common Lisp',
  cl: 'OpenCL',
  l: 'PicoLisp',
  lsp: 'NewLisp',
  ny: 'Common Lisp',
  podsl: 'Common Lisp',
  sexp: 'Common Lisp',
  cps: 'Component Pascal',
  coq: 'Coq',
  v: 'Verilog',
  cppobjdump: 'Cpp-ObjDump',
  'c++-objdump': 'Cpp-ObjDump',
  'c++objdump': 'Cpp-ObjDump',
  'cpp-objdump': 'Cpp-ObjDump',
  'cxx-objdump': 'Cpp-ObjDump',
  creole: 'Creole',
  cr: 'Crystal',
  feature: 'Cucumber',
  cu: 'Cuda',
  cuh: 'Cuda',
  cy: 'Cycript',
  pyx: 'Cython',
  pxd: 'Cython',
  pxi: 'Cython',
  d: 'Makefile',
  di: 'D',
  'd-objdump': 'D-ObjDump',
  com: 'DIGITAL Command Language',
  dm: 'DM',
  zone: 'DNS Zone',
  arpa: 'DNS Zone',
  darcspatch: 'Darcs Patch',
  dpatch: 'Darcs Patch',
  dart: 'Dart',
  diff: 'Diff',
  patch: 'Diff',
  dockerfile: 'Dockerfile',
  djs: 'Dogescript',
  dylan: 'Dylan',
  dyl: 'Dylan',
  intr: 'Dylan',
  lid: 'Dylan',
  E: 'E',
  ecl: 'ECLiPSe',
  eclxml: 'ECL',
  sch: 'KiCad',
  brd: 'KiCad',
  epj: 'Ecere Projects',
  e: 'Eiffel',
  ex: 'Elixir',
  exs: 'Elixir',
  elm: 'Elm',
  el: 'Emacs Lisp',
  emacs: 'Emacs Lisp',
  'emacs.desktop': 'Emacs Lisp',
  em: 'EmberScript',
  emberscript: 'EmberScript',
  erl: 'Erlang',
  es: 'JavaScript',
  escript: 'Erlang',
  hrl: 'Erlang',
  xrl: 'Erlang',
  yrl: 'Erlang',
  fs: 'GLSL',
  fsi: 'F#',
  fsx: 'F#',
  fx: 'HLSL',
  flux: 'FLUX',
  f90: 'FORTRAN',
  f: 'Forth',
  f03: 'FORTRAN',
  f08: 'FORTRAN',
  f77: 'FORTRAN',
  f95: 'FORTRAN',
  for: 'Forth',
  fpp: 'FORTRAN',
  factor: 'Factor',
  fy: 'Fancy',
  fancypack: 'Fancy',
  fan: 'Fantom',
  'eam.fs': 'Formatted',
  fth: 'Forth',
  '4th': 'Forth',
  forth: 'Forth',
  fr: 'Text',
  frt: 'Forth',
  ftl: 'FreeMarker',
  g: 'GAP',
  gco: 'G-code',
  gcode: 'G-code',
  gms: 'GAMS',
  gap: 'GAP',
  gd: 'GDScript',
  gi: 'GAP',
  tst: 'Scilab',
  s: 'GAS',
  ms: 'MAXScript',
  glsl: 'GLSL',
  fp: 'GLSL',
  frag: 'JavaScript',
  frg: 'GLSL',
  fsh: 'GLSL',
  fshader: 'GLSL',
  geo: 'GLSL',
  geom: 'GLSL',
  glslv: 'GLSL',
  gshader: 'GLSL',
  shader: 'GLSL',
  vert: 'GLSL',
  vrx: 'GLSL',
  vsh: 'GLSL',
  vshader: 'GLSL',
  gml: 'XML',
  kid: 'Genshi',
  ebuild: 'Gentoo Ebuild',
  eclass: 'Gentoo Eclass',
  po: 'Gettext Catalog',
  pot: 'Gettext Catalog',
  glf: 'Glyph',
  gp: 'Gnuplot',
  gnu: 'Gnuplot',
  gnuplot: 'Gnuplot',
  plot: 'Gnuplot',
  plt: 'Gnuplot',
  go: 'Go',
  golo: 'Golo',
  gs: 'JavaScript',
  gst: 'Gosu',
  gsx: 'Gosu',
  vark: 'Gosu',
  grace: 'Grace',
  gradle: 'Gradle',
  gf: 'Grammatical Framework',
  graphql: 'GraphQL',
  dot: 'Graphviz (DOT)',
  gv: 'Graphviz (DOT)',
  man: 'Groff',
  '1in': 'Groff',
  '1m': 'Groff',
  '1x': 'Groff',
  '3in': 'Groff',
  '3m': 'Groff',
  '3qt': 'Groff',
  '3x': 'Groff',
  me: 'Groff',
  n: 'Nemerle',
  rno: 'Groff',
  roff: 'Groff',
  groovy: 'Groovy',
  grt: 'Groovy',
  gtpl: 'Groovy',
  gvy: 'Groovy',
  gsp: 'Groovy Server Pages',
  hcl: 'HCL',
  tf: 'HCL',
  hlsl: 'HLSL',
  fxh: 'HLSL',
  hlsli: 'HLSL',
  html: 'HTML',
  htm: 'HTML',
  'html.hl': 'HTML',
  st: 'Smalltalk',
  xht: 'HTML',
  xhtml: 'HTML',
  mustache: 'HTML+Django',
  jinja: 'HTML+Django',
  eex: 'HTML+EEX',
  erb: 'HTML+ERB',
  'erb.deface': 'HTML+ERB',
  phtml: 'HTML+PHP',
  http: 'HTTP',
  php: 'PHP',
  haml: 'Haml',
  'haml.deface': 'Haml',
  handlebars: 'Handlebars',
  hbs: 'Handlebars',
  hb: 'Harbour',
  hs: 'Haskell',
  hsc: 'Haskell',
  hx: 'Haxe',
  hxsl: 'Haxe',
  hy: 'Hy',
  pro: 'QMake',
  dlm: 'IDL',
  ipf: 'IGOR Pro',
  ini: 'INI',
  cfg: 'INI',
  prefs: 'INI',
  properties: 'INI',
  irclog: 'IRC log',
  weechatlog: 'IRC log',
  idr: 'Idris',
  lidr: 'Idris',
  ni: 'Inform 7',
  i7x: 'Inform 7',
  iss: 'Inno Setup',
  io: 'Io',
  ik: 'Ioke',
  thy: 'Isabelle',
  ijs: 'J',
  flex: 'JFlex',
  jflex: 'JFlex',
  json: 'JSON',
  geojson: 'JSON',
  lock: 'JSON',
  topojson: 'JSON',
  json5: 'JSON5',
  jsonld: 'JSONLD',
  jq: 'JSONiq',
  jsx: 'JSX',
  jade: 'Jade',
  j: 'Objective-J',
  java: 'Java',
  jsp: 'Java Server Pages',
  js: 'JavaScript',
  _js: 'JavaScript',
  bones: 'JavaScript',
  es6: 'JavaScript',
  jake: 'JavaScript',
  jsb: 'JavaScript',
  jscad: 'JavaScript',
  jsfl: 'JavaScript',
  jsm: 'JavaScript',
  jss: 'JavaScript',
  njs: 'JavaScript',
  pac: 'JavaScript',
  sjs: 'JavaScript',
  ssjs: 'JavaScript',
  'sublime-build': 'JavaScript',
  'sublime-commands': 'JavaScript',
  'sublime-completions': 'JavaScript',
  'sublime-keymap': 'JavaScript',
  'sublime-macro': 'JavaScript',
  'sublime-menu': 'JavaScript',
  'sublime-mousemap': 'JavaScript',
  'sublime-project': 'JavaScript',
  'sublime-settings': 'JavaScript',
  'sublime-theme': 'JavaScript',
  'sublime-workspace': 'JavaScript',
  // eslint-disable-next-line camelcase
  sublime_metrics: 'JavaScript',
  // eslint-disable-next-line camelcase
  sublime_session: 'JavaScript',
  xsjs: 'JavaScript',
  xsjslib: 'JavaScript',
  jl: 'Julia',
  ipynb: 'Jupyter Notebook',
  krl: 'KRL',
  // eslint-disable-next-line camelcase
  kicad_pcb: 'KiCad',
  kit: 'Kit',
  kt: 'Kotlin',
  ktm: 'Kotlin',
  kts: 'Kotlin',
  lfe: 'LFE',
  ll: 'LLVM',
  lol: 'LOLCODE',
  lsl: 'LSL',
  lslp: 'LSL',
  lvproj: 'LabVIEW',
  lasso: 'Lasso',
  las: 'Lasso',
  lasso8: 'Lasso',
  lasso9: 'Lasso',
  ldml: 'Lasso',
  latte: 'Latte',
  lean: 'Lean',
  hlean: 'Lean',
  less: 'Less',
  lex: 'Lex',
  ly: 'LilyPond',
  ily: 'LilyPond',
  m: 'Objective-C',
  ld: 'Linker Script',
  lds: 'Linker Script',
  liquid: 'Liquid',
  lagda: 'Literate Agda',
  litcoffee: 'Literate CoffeeScript',
  lhs: 'Literate Haskell',
  ls: 'LoomScript',
  _ls: 'LiveScript',
  xm: 'Logos',
  x: 'Logos',
  xi: 'Logos',
  lgt: 'Logtalk',
  logtalk: 'Logtalk',
  lookml: 'LookML',
  lua: 'Lua',
  fcgi: 'Shell',
  nse: 'Lua',
  // eslint-disable-next-line camelcase
  pd_lua: 'Lua',
  rbxs: 'Lua',
  wlua: 'Lua',
  mumps: 'M',
  m4: 'M4Sugar',
  mcr: 'MAXScript',
  mtml: 'MTML',
  muf: 'MUF',
  mak: 'Makefile',
  mk: 'Makefile',
  mkfile: 'Makefile',
  mako: 'Mako',
  mao: 'Mako',
  md: 'Markdown',
  markdown: 'Markdown',
  mkd: 'Markdown',
  mkdn: 'Markdown',
  mkdown: 'Markdown',
  ron: 'Markdown',
  mask: 'Mask',
  mathematica: 'Mathematica',
  cdf: 'Mathematica',
  ma: 'Mathematica',
  mt: 'Mathematica',
  nb: 'Text',
  nbp: 'Mathematica',
  wl: 'Mathematica',
  wlt: 'Mathematica',
  matlab: 'Matlab',
  maxpat: 'Max',
  maxhelp: 'Max',
  maxproj: 'Max',
  mxt: 'Max',
  pat: 'Max',
  mediawiki: 'MediaWiki',
  wiki: 'MediaWiki',
  moo: 'Moocode',
  metal: 'Metal',
  minid: 'MiniD',
  druby: 'Mirah',
  duby: 'Mirah',
  mir: 'Mirah',
  mirah: 'Mirah',
  mo: 'Modelica',
  mms: 'Module Management System',
  mmk: 'Module Management System',
  monkey: 'Monkey',
  moon: 'MoonScript',
  myt: 'Myghty',
  ncl: 'Text',
  nl: 'NewLisp',
  nsi: 'NSIS',
  nsh: 'NSIS',
  axs: 'NetLinx',
  axi: 'NetLinx',
  'axs.erb': 'NetLinx+ERB',
  'axi.erb': 'NetLinx+ERB',
  nlogo: 'NetLogo',
  nginxconf: 'Nginx',
  nim: 'Nimrod',
  nimrod: 'Nimrod',
  ninja: 'Ninja',
  nit: 'Nit',
  nix: 'Nix',
  nu: 'Nu',
  numpy: 'NumPy',
  numpyw: 'NumPy',
  numsc: 'NumPy',
  ml: 'OCaml',
  eliom: 'OCaml',
  eliomi: 'OCaml',
  ml4: 'OCaml',
  mli: 'OCaml',
  mll: 'OCaml',
  mly: 'OCaml',
  objdump: 'ObjDump',
  mm: 'XML',
  sj: 'Objective-J',
  omgrofl: 'Omgrofl',
  opa: 'Opa',
  opal: 'Opal',
  opencl: 'OpenCL',
  p: 'OpenEdge ABL',
  scad: 'OpenSCAD',
  org: 'Org',
  ox: 'Ox',
  oxh: 'Ox',
  oxo: 'Ox',
  oxygene: 'Oxygene',
  oz: 'Oz',
  pwn: 'PAWN',
  aw: 'PHP',
  ctp: 'PHP',
  php3: 'PHP',
  php4: 'PHP',
  php5: 'PHP',
  phps: 'PHP',
  phpt: 'PHP',
  pls: 'PLSQL',
  pck: 'PLSQL',
  pkb: 'PLSQL',
  pks: 'PLSQL',
  plb: 'PLSQL',
  plsql: 'PLSQL',
  sql: 'SQLPL',
  pov: 'POV-Ray SDL',
  pan: 'Pan',
  psc: 'Papyrus',
  parrot: 'Parrot',
  pasm: 'Parrot Assembly',
  pir: 'Parrot Internal Representation',
  pas: 'Pascal',
  dfm: 'Pascal',
  dpr: 'Pascal',
  lpr: 'Pascal',
  pp: 'Puppet',
  pl: 'Prolog',
  al: 'Perl',
  cgi: 'Shell',
  perl: 'Perl',
  ph: 'Perl',
  plx: 'Perl',
  pm: 'Perl6',
  pod: 'Pod',
  psgi: 'Perl',
  t: 'Turing',
  '6pl': 'Perl6',
  '6pm': 'Perl6',
  nqp: 'Perl6',
  p6: 'Perl6',
  p6l: 'Perl6',
  p6m: 'Perl6',
  pl6: 'Perl6',
  pm6: 'Perl6',
  pkl: 'Pickle',
  pig: 'PigLatin',
  pike: 'Pike',
  pmod: 'Pike',
  pogo: 'PogoScript',
  pony: 'Pony',
  ps: 'PostScript',
  eps: 'PostScript',
  ps1: 'PowerShell',
  psd1: 'PowerShell',
  psm1: 'PowerShell',
  pde: 'Processing',
  prolog: 'Prolog',
  yap: 'Prolog',
  spin: 'Propeller Spin',
  proto: 'Protocol Buffer',
  pub: 'Public Key',
  pd: 'Pure Data',
  pb: 'PureBasic',
  pbi: 'PureBasic',
  purs: 'PureScript',
  py: 'Python',
  bzl: 'Python',
  gyp: 'Python',
  lmi: 'Python',
  pyde: 'Python',
  pyp: 'Python',
  pyt: 'Python',
  pyw: 'Python',
  rpy: "Ren'Py",
  tac: 'Python',
  wsgi: 'Python',
  xpy: 'Python',
  pytb: 'Python traceback',
  qml: 'QML',
  qbs: 'QML',
  pri: 'QMake',
  r: 'Rebol',
  rd: 'R',
  rsx: 'R',
  raml: 'RAML',
  rdoc: 'RDoc',
  rbbas: 'REALbasic',
  rbfrm: 'REALbasic',
  rbmnu: 'REALbasic',
  rbres: 'REALbasic',
  rbtbar: 'REALbasic',
  rbuistate: 'REALbasic',
  rhtml: 'RHTML',
  rmd: 'RMarkdown',
  rkt: 'Racket',
  rktd: 'Racket',
  rktl: 'Racket',
  scrbl: 'Racket',
  rl: 'Ragel in Ruby Host',
  raw: 'Raw token data',
  reb: 'Rebol',
  r2: 'Rebol',
  r3: 'Rebol',
  rebol: 'Rebol',
  red: 'Red',
  reds: 'Red',
  cw: 'Redcode',
  rs: 'Rust',
  rsh: 'RenderScript',
  robot: 'RobotFramework',
  rg: 'Rouge',
  rb: 'Ruby',
  builder: 'Ruby',
  gemspec: 'Ruby',
  god: 'Ruby',
  irbrc: 'Ruby',
  jbuilder: 'Ruby',
  mspec: 'Ruby',
  pluginspec: 'XML',
  podspec: 'Ruby',
  rabl: 'Ruby',
  rake: 'Ruby',
  rbuild: 'Ruby',
  rbw: 'Ruby',
  rbx: 'Ruby',
  ru: 'Ruby',
  ruby: 'Ruby',
  thor: 'Ruby',
  watchr: 'Ruby',
  'rs.in': 'Rust',
  sas: 'SAS',
  scss: 'SCSS',
  smt2: 'SMT',
  smt: 'SMT',
  sparql: 'SPARQL',
  rq: 'SPARQL',
  sqf: 'SQF',
  hqf: 'SQF',
  cql: 'SQL',
  ddl: 'SQL',
  prc: 'SQL',
  tab: 'SQL',
  udf: 'SQL',
  viw: 'SQL',
  db2: 'SQLPL',
  ston: 'STON',
  svg: 'SVG',
  sage: 'Sage',
  sagews: 'Sage',
  sls: 'Scheme',
  sass: 'Sass',
  scala: 'Scala',
  sbt: 'Scala',
  sc: 'SuperCollider',
  scaml: 'Scaml',
  scm: 'Scheme',
  sld: 'Scheme',
  sps: 'Scheme',
  ss: 'Scheme',
  sci: 'Scilab',
  sce: 'Scilab',
  self: 'Self',
  sh: 'Shell',
  bash: 'Shell',
  bats: 'Shell',
  command: 'Shell',
  ksh: 'Shell',
  'sh.in': 'Shell',
  tmux: 'Shell',
  tool: 'Shell',
  zsh: 'Shell',
  'sh-session': 'ShellSession',
  shen: 'Shen',
  sl: 'Slash',
  slim: 'Slim',
  smali: 'Smali',
  tpl: 'Smarty',
  sp: 'SourcePawn',
  sma: 'SourcePawn',
  nut: 'Squirrel',
  stan: 'Stan',
  ML: 'Standard ML',
  fun: 'Standard ML',
  sig: 'Standard ML',
  sml: 'Standard ML',
  do: 'Stata',
  ado: 'Stata',
  doh: 'Stata',
  ihlp: 'Stata',
  mata: 'Stata',
  matah: 'Stata',
  sthlp: 'Stata',
  styl: 'Stylus',
  scd: 'SuperCollider',
  swift: 'Swift',
  sv: 'SystemVerilog',
  svh: 'SystemVerilog',
  vh: 'SystemVerilog',
  toml: 'TOML',
  txl: 'TXL',
  tcl: 'Tcl',
  adp: 'Tcl',
  tm: 'Tcl',
  tcsh: 'Tcsh',
  csh: 'Tcsh',
  tex: 'TeX',
  aux: 'TeX',
  bbx: 'TeX',
  bib: 'TeX',
  cbx: 'TeX',
  dtx: 'TeX',
  ins: 'TeX',
  lbx: 'TeX',
  ltx: 'TeX',
  mkii: 'TeX',
  mkiv: 'TeX',
  mkvi: 'TeX',
  sty: 'TeX',
  toc: 'TeX',
  tea: 'Tea',
  txt: 'Text',
  no: 'Text',
  textile: 'Textile',
  thrift: 'Thrift',
  tu: 'Turing',
  ttl: 'Turtle',
  twig: 'Twig',
  ts: 'typescript',
  tsx: 'typescriptreact',
  upc: 'Unified Parallel C',
  anim: 'Unity3D Asset',
  asset: 'Unity3D Asset',
  mat: 'Unity3D Asset',
  meta: 'Unity3D Asset',
  prefab: 'Unity3D Asset',
  unity: 'Unity3D Asset',
  uno: 'Uno',
  uc: 'UnrealScript',
  ur: 'UrWeb',
  urs: 'UrWeb',
  vcl: 'VCL',
  vhdl: 'VHDL',
  vhd: 'VHDL',
  vhf: 'VHDL',
  vhi: 'VHDL',
  vho: 'VHDL',
  vhs: 'VHDL',
  vht: 'VHDL',
  vhw: 'VHDL',
  vala: 'Vala',
  vapi: 'Vala',
  veo: 'Verilog',
  vim: 'VimL',
  vb: 'Visual Basic',
  bas: 'Visual Basic',
  frm: 'Visual Basic',
  frx: 'Visual Basic',
  vba: 'Visual Basic',
  vbhtml: 'Visual Basic',
  vbs: 'Visual Basic',
  volt: 'Volt',
  vue: 'Vue',
  owl: 'Web Ontology Language',
  webidl: 'WebIDL',
  x10: 'X10',
  xc: 'XC',
  xml: 'XML',
  ant: 'XML',
  axml: 'XML',
  ccxml: 'XML',
  clixml: 'XML',
  cproject: 'XML',
  csl: 'XML',
  csproj: 'XML',
  ct: 'XML',
  dita: 'XML',
  ditamap: 'XML',
  ditaval: 'XML',
  'dll.config': 'XML',
  dotsettings: 'XML',
  filters: 'XML',
  fsproj: 'XML',
  fxml: 'XML',
  glade: 'XML',
  grxml: 'XML',
  iml: 'XML',
  ivy: 'XML',
  jelly: 'XML',
  jsproj: 'XML',
  kml: 'XML',
  launch: 'XML',
  mdpolicy: 'XML',
  mxml: 'XML',
  nproj: 'XML',
  nuspec: 'XML',
  odd: 'XML',
  osm: 'XML',
  plist: 'XML',
  props: 'XML',
  ps1xml: 'XML',
  psc1: 'XML',
  pt: 'XML',
  rdf: 'XML',
  rss: 'XML',
  scxml: 'XML',
  srdf: 'XML',
  storyboard: 'XML',
  stTheme: 'XML',
  'sublime-snippet': 'XML',
  targets: 'XML',
  tmCommand: 'XML',
  tml: 'XML',
  tmLanguage: 'XML',
  tmPreferences: 'XML',
  tmSnippet: 'XML',
  tmTheme: 'XML',
  ui: 'XML',
  urdf: 'XML',
  ux: 'XML',
  vbproj: 'XML',
  vcxproj: 'XML',
  vssettings: 'XML',
  vxml: 'XML',
  wsdl: 'XML',
  wsf: 'XML',
  wxi: 'XML',
  wxl: 'XML',
  wxs: 'XML',
  x3d: 'XML',
  xacro: 'XML',
  xaml: 'XML',
  xib: 'XML',
  xlf: 'XML',
  xliff: 'XML',
  xmi: 'XML',
  'xml.dist': 'XML',
  xproj: 'XML',
  xsd: 'XML',
  xul: 'XML',
  zcml: 'XML',
  'xsp-config': 'XPages',
  'xsp.metadata': 'XPages',
  xpl: 'XProc',
  xproc: 'XProc',
  xquery: 'XQuery',
  xq: 'XQuery',
  xql: 'XQuery',
  xqm: 'XQuery',
  xqy: 'XQuery',
  xs: 'XS',
  xslt: 'XSLT',
  xsl: 'XSLT',
  // eslint-disable-next-line camelcase
  xojo_code: 'Xojo',
  // eslint-disable-next-line camelcase
  xojo_menu: 'Xojo',
  // eslint-disable-next-line camelcase
  xojo_report: 'Xojo',
  // eslint-disable-next-line camelcase
  xojo_script: 'Xojo',
  // eslint-disable-next-line camelcase
  xojo_toolbar: 'Xojo',
  // eslint-disable-next-line camelcase
  xojo_window: 'Xojo',
  xtend: 'Xtend',
  yml: 'YAML',
  reek: 'YAML',
  rviz: 'YAML',
  'sublime-syntax': 'YAML',
  syntax: 'YAML',
  yaml: 'YAML',
  'yaml-tmlanguage': 'YAML',
  yang: 'YANG',
  y: 'Yacc',
  yacc: 'Yacc',
  yy: 'Yacc',
  zep: 'Zephir',
  zimpl: 'Zimpl',
  zmpl: 'Zimpl',
  zpl: 'Zimpl',
  desktop: 'desktop',
  'desktop.in': 'desktop',
  ec: 'eC',
  eh: 'eC',
  edn: 'edn',
  fish: 'fish',
  mu: 'mupad',
  nc: 'nesC',
  ooc: 'ooc',
  rst: 'reStructuredText',
  rest: 'reStructuredText',
  'rest.txt': 'reStructuredText',
  'rst.txt': 'reStructuredText',
  wisp: 'wisp',
  prg: 'xBase',
  prw: 'xBase',
  // manually added for Composer AI
  doc: 'Document',
  docx: 'Document',
  odt: 'Document',
  ppt: 'Presentation',
  pptx: 'Presentation',
  odp: 'Presentation',
  pdf: 'PDF'
};

export const FileDetails = ({
  className,
  fileName,
  fileNameClassName,
  languageTestId
}: PropsWithChildren<FileDetailsProps>) => {
  const language = extensionToLanguage[path.extname(fileName).slice(1)]?.toUpperCase();
  return (
    <Flex className={`pf-chatbot__file-details ${className ? className : ''}`} gap={{ default: 'gapSm' }}>
      <Flex
        className="pf-chatbot__code-icon"
        justifyContent={{ default: 'justifyContentCenter' }}
        alignItems={{ default: 'alignItemsCenter' }}
        alignSelf={{ default: 'alignSelfCenter' }}
      >
        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M0 4C0 1.79086 1.79086 0 4 0H20C22.2091 0 24 1.79086 24 4V20C24 22.2091 22.2091 24 20 24H4C1.79086 24 0 22.2091 0 20V4Z"
            fill="currentColor"
          />
          <g clipPath="url(#clip0_3280_27505)">
            <path
              d="M13.8204 5.63002C13.3954 5.50752 12.9529 5.75502 12.8304 6.18002L9.63035 17.38C9.50785 17.805 9.75535 18.2475 10.1804 18.37C10.6054 18.4925 11.0479 18.245 11.1704 17.82L14.3704 6.62002C14.4929 6.19502 14.2454 5.75252 13.8204 5.63002ZM15.8354 8.63252C15.5229 8.94502 15.5229 9.45252 15.8354 9.76502L18.0679 12L15.8329 14.235C15.5204 14.5475 15.5204 15.055 15.8329 15.3675C16.1454 15.68 16.6529 15.68 16.9654 15.3675L19.7654 12.5675C20.0779 12.255 20.0779 11.7475 19.7654 11.435L16.9654 8.63502C16.6529 8.32252 16.1454 8.32252 15.8329 8.63502L15.8354 8.63252ZM8.16785 8.63252C7.85535 8.32002 7.34785 8.32002 7.03535 8.63252L4.23535 11.4325C3.92285 11.745 3.92285 12.2525 4.23535 12.565L7.03535 15.365C7.34785 15.6775 7.85535 15.6775 8.16785 15.365C8.48035 15.0525 8.48035 14.545 8.16785 14.2325L5.93285 12L8.16785 9.76502C8.48035 9.45252 8.48035 8.94502 8.16785 8.63252Z"
              fill="white"
            />
          </g>
          <defs>
            <clipPath>
              <rect width="16" height="12.8" fill="white" transform="translate(4 5.60001)" />
            </clipPath>
          </defs>
        </svg>
      </Flex>
      <Stack>
        <StackItem>
          <span className="pf-chatbot__code-fileName">
            <Truncate className={fileNameClassName} content={path.parse(fileName).name} />
          </span>
        </StackItem>
        {language && (
          <StackItem data-testid={languageTestId} className="pf-chatbot__code-language">
            {language}
          </StackItem>
        )}
      </Stack>
    </Flex>
  );
};

export default FileDetails;



================================================
FILE: packages/module/src/FileDetails/index.ts
================================================
export { default } from './FileDetails';
export * from './FileDetails';



================================================
FILE: packages/module/src/FileDetails/__snapshots__/FileDetails.test.tsx.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`FileDetails should render file details 1`] = `
<div>
  <div
    class="pf-v6-l-flex pf-m-gap-sm pf-chatbot__file-details "
  >
    <div
      class="pf-v6-l-flex pf-m-align-items-center pf-m-align-self-center pf-m-justify-content-center pf-chatbot__code-icon"
    >
      <svg
        fill="currentColor"
        height="24"
        viewBox="0 0 24 24"
        width="24"
        xmlns="http://www.w3.org/2000/svg"
      >
        <path
          d="M0 4C0 1.79086 1.79086 0 4 0H20C22.2091 0 24 1.79086 24 4V20C24 22.2091 22.2091 24 20 24H4C1.79086 24 0 22.2091 0 20V4Z"
          fill="currentColor"
        />
        <g
          clip-path="url(#clip0_3280_27505)"
        >
          <path
            d="M13.8204 5.63002C13.3954 5.50752 12.9529 5.75502 12.8304 6.18002L9.63035 17.38C9.50785 17.805 9.75535 18.2475 10.1804 18.37C10.6054 18.4925 11.0479 18.245 11.1704 17.82L14.3704 6.62002C14.4929 6.19502 14.2454 5.75252 13.8204 5.63002ZM15.8354 8.63252C15.5229 8.94502 15.5229 9.45252 15.8354 9.76502L18.0679 12L15.8329 14.235C15.5204 14.5475 15.5204 15.055 15.8329 15.3675C16.1454 15.68 16.6529 15.68 16.9654 15.3675L19.7654 12.5675C20.0779 12.255 20.0779 11.7475 19.7654 11.435L16.9654 8.63502C16.6529 8.32252 16.1454 8.32252 15.8329 8.63502L15.8354 8.63252ZM8.16785 8.63252C7.85535 8.32002 7.34785 8.32002 7.03535 8.63252L4.23535 11.4325C3.92285 11.745 3.92285 12.2525 4.23535 12.565L7.03535 15.365C7.34785 15.6775 7.85535 15.6775 8.16785 15.365C8.48035 15.0525 8.48035 14.545 8.16785 14.2325L5.93285 12L8.16785 9.76502C8.48035 9.45252 8.48035 8.94502 8.16785 8.63252Z"
            fill="white"
          />
        </g>
        <defs>
          <clippath>
            <rect
              fill="white"
              height="12.8"
              transform="translate(4 5.60001)"
              width="16"
            />
          </clippath>
        </defs>
      </svg>
    </div>
    <div
      class="pf-v6-l-stack"
    >
      <div
        class="pf-v6-l-stack__item"
      >
        <span
          class="pf-chatbot__code-fileName"
        >
          <div
            style="display: contents;"
          >
            <span
              class="pf-v6-c-truncate"
            >
              <span
                class="pf-v6-c-truncate__start"
              >
                test
              </span>
            </span>
          </div>
        </span>
      </div>
      <div
        class="pf-v6-l-stack__item pf-chatbot__code-language"
      >
        TEXT
      </div>
    </div>
  </div>
</div>
`;



================================================
FILE: packages/module/src/FileDetailsLabel/FileDetailsLabel.scss
================================================
.pf-chatbot__file-label-contents {
  display: flex;
  gap: var(--pf-t--global--spacer--md);
  justify-content: center;
  align-items: center;
}

.pf-chatbot__file-label {
  padding: var(--pf-t--global--spacer--sm) var(--pf-t--global--spacer--md) var(--pf-t--global--spacer--sm)
    var(--pf-t--global--spacer--md) !important;
  gap: var(--pf-t--global--spacer--sm);
  --pf-v6-c-label--m-clickable--hover--BackgroundColor: var(--pf-t--global--background--color--primary--hover);
  --pf-v6-c-label--MaxWidth: 12rem !important;
  .pf-v6-c-truncate {
    max-width: 9ch;
  }

  .pf-v6-c-label__content,
  .pf-v6-c-label__text {
    --pf-v6-c-label__content--MaxWidth: 100%;
    --pf-v6-c-label__text--MaxWidth: 100%;
  }
}

.pf-v6-c-label.pf-chatbot__file-label {
  --pf-v6-c-label--BackgroundColor: var(--pf-t--global--background--color--primary--default);
  --pf-v6-c-label--BorderRadius: var(--pf-t--global--border--radius--small);
  --pf-v6-c-label--Color: var(--pf-t--global--text--color--regular);

  .pf-chatbot__file-label > .pf-v6-c-label__content {
    --pf-v6-c-label--Color: var(--pf-t--global--background--color--primary--default);
  }
}

.pf-v6-theme-dark {
  .pf-v6-c-label.pf-chatbot__file-label {
    --pf-v6-c-label--m-clickable--hover--Color: var(--pf-t--global--text--color--regular);
  }

  .pf-chatbot__file-label > .pf-v6-c-label__actions > .pf-v6-c-button.pf-m-plain > .pf-v6-c-button__icon {
    --pf-v6-c-button__icon--Color: var(--pf-t--global--icon--color--regular);
  }
}

.pf-chatbot__file-label.pf-m-clickable:hover,
.pf-chatbot__file-label.pf-m-clickable:focus-within {
  --pf-v6-c-label--BackgroundColor: var(--pf-t--global--background--color--action--plain--hover);
  --pf-v6-c-label--m-clickable--hover--BackgroundColor: var(--pf-t--global--background--color--action--plain--hover);

  .pf-chatbot__code-icon {
    color: var(--pf-t--global--icon--color--status--custom--hover);
  }
}

.pf-chatbot__file-label-loading {
  .pf-v6-c-truncate {
    max-width: 6ch;
  }
}

.pf-chatbot--embedded,
.pf-chatbot--fullscreen {
  .pf-chatbot__file-label {
    --pf-v6-c-label--MaxWidth: 14rem;
  }
}



================================================
FILE: packages/module/src/FileDetailsLabel/FileDetailsLabel.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import FileDetailsLabel from './FileDetailsLabel';
import userEvent from '@testing-library/user-event';

describe('FileDetailsLabel', () => {
  it('should render file details label', () => {
    const { container } = render(<FileDetailsLabel fileName="test.txt" />);
    expect(container).toMatchSnapshot();
  });
  it('should render file details correctly if an extension we support is passed in', () => {
    render(<FileDetailsLabel fileName="test.txt" />);
    expect(screen.getByText('test')).toBeTruthy();
    expect(screen.getByText('TEXT')).toBeTruthy();
  });
  it('should skip language if we do not support an extension', () => {
    render(<FileDetailsLabel fileName="test.joke" languageTestId="language" />);
    expect(screen.getByText('test')).toBeTruthy();
    expect(screen.queryByTestId('language')).toBeFalsy();
  });
  it('should not show spinner by default', () => {
    render(<FileDetailsLabel fileName="test.txt" spinnerTestId="spinner" />);
    expect(screen.queryByTestId('spinner')).toBeFalsy();
  });
  it('should show spinner if loading', () => {
    render(<FileDetailsLabel fileName="test.txt" isLoading spinnerTestId="spinner" />);
    expect(screen.getByText('test')).toBeTruthy();
    expect(screen.getByText('TEXT')).toBeTruthy();
    expect(screen.queryByTestId('spinner')).toBeTruthy();
  });
  it('should call onClick prop', async () => {
    const spy = jest.fn();
    render(<FileDetailsLabel fileName="test.txt" onClick={spy} />);
    await userEvent.click(screen.getByRole('button'));
    expect(spy).toHaveBeenCalledTimes(1);
  });
  it('should call onClose prop', async () => {
    const spy = jest.fn();
    render(<FileDetailsLabel fileName="test.txt" onClose={spy} />);
    await userEvent.click(screen.getByRole('button', { name: /Close test.txt/i }));
    expect(spy).toHaveBeenCalledTimes(1);
  });
  it('should use closeButtonAriaLabel prop appropriately', () => {
    render(<FileDetailsLabel fileName="test.txt" onClose={jest.fn()} closeButtonAriaLabel="Delete file" />);
    screen.getByRole('button', { name: /Delete file/i });
  });
});



================================================
FILE: packages/module/src/FileDetailsLabel/FileDetailsLabel.tsx
================================================
import React, { PropsWithChildren } from 'react';
import { Button, Label } from '@patternfly/react-core';
import FileDetails from '../FileDetails';
import { Spinner } from '@patternfly/react-core';
import { TimesIcon } from '@patternfly/react-icons';

interface FileDetailsLabelProps {
  /** Name of file, including extension */
  fileName: string;
  /** Unique id of file */
  fileId?: string | number;
  /** Whether to display loading icon */
  isLoading?: boolean;
  /** Callback function for when label is clicked */
  onClick?: (event: React.MouseEvent, fileName: string, fileId?: string | number) => void;
  /** Callback function for when close button is clicked */
  onClose?: (event: React.MouseEvent, fileName: string, fileId?: string | number) => void;
  /** Aria label for close button */
  closeButtonAriaLabel?: string;
  /** Custom test id for the component-generated language */
  languageTestId?: string;
  /** Custom test id for the loading spinner in the component */
  spinnerTestId?: string;
}

export const FileDetailsLabel = ({
  fileName,
  fileId,
  isLoading,
  onClick,
  onClose,
  closeButtonAriaLabel,
  languageTestId,
  spinnerTestId
}: PropsWithChildren<FileDetailsLabelProps>) => {
  const handleClose = (event) => {
    onClose && onClose(event, fileName, fileId);
  };
  return (
    <Label
      className="pf-chatbot__file-label"
      {...(onClose && { onClose: (event) => onClose(event, fileName, fileId) })}
      closeBtn={
        <Button
          type="button"
          variant="plain"
          aria-label={closeButtonAriaLabel ?? `Close ${fileName}`}
          icon={<TimesIcon />}
          onClick={handleClose}
        />
      }
      {...(onClick && { onClick: (event) => onClick(event, fileName, fileId) })}
    >
      <div className="pf-chatbot__file-label-contents">
        <FileDetails
          className={isLoading ? 'pf-chatbot__file-label-loading' : undefined}
          fileName={fileName}
          languageTestId={languageTestId}
        />
        {isLoading && <Spinner data-testid={spinnerTestId} size="sm" />}
      </div>
    </Label>
  );
};

export default FileDetailsLabel;



================================================
FILE: packages/module/src/FileDetailsLabel/index.ts
================================================
export { default } from './FileDetailsLabel';
export * from './FileDetailsLabel';



================================================
FILE: packages/module/src/FileDetailsLabel/__snapshots__/FileDetailsLabel.test.tsx.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`FileDetailsLabel should render file details label 1`] = `
<div>
  <span
    class="pf-v6-c-label pf-m-filled pf-chatbot__file-label"
  >
    <span
      class="pf-v6-c-label__content"
    >
      <span
        class="pf-v6-c-label__text"
      >
        <div
          class="pf-chatbot__file-label-contents"
        >
          <div
            class="pf-v6-l-flex pf-m-gap-sm pf-chatbot__file-details "
          >
            <div
              class="pf-v6-l-flex pf-m-align-items-center pf-m-align-self-center pf-m-justify-content-center pf-chatbot__code-icon"
            >
              <svg
                fill="currentColor"
                height="24"
                viewBox="0 0 24 24"
                width="24"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  d="M0 4C0 1.79086 1.79086 0 4 0H20C22.2091 0 24 1.79086 24 4V20C24 22.2091 22.2091 24 20 24H4C1.79086 24 0 22.2091 0 20V4Z"
                  fill="currentColor"
                />
                <g
                  clip-path="url(#clip0_3280_27505)"
                >
                  <path
                    d="M13.8204 5.63002C13.3954 5.50752 12.9529 5.75502 12.8304 6.18002L9.63035 17.38C9.50785 17.805 9.75535 18.2475 10.1804 18.37C10.6054 18.4925 11.0479 18.245 11.1704 17.82L14.3704 6.62002C14.4929 6.19502 14.2454 5.75252 13.8204 5.63002ZM15.8354 8.63252C15.5229 8.94502 15.5229 9.45252 15.8354 9.76502L18.0679 12L15.8329 14.235C15.5204 14.5475 15.5204 15.055 15.8329 15.3675C16.1454 15.68 16.6529 15.68 16.9654 15.3675L19.7654 12.5675C20.0779 12.255 20.0779 11.7475 19.7654 11.435L16.9654 8.63502C16.6529 8.32252 16.1454 8.32252 15.8329 8.63502L15.8354 8.63252ZM8.16785 8.63252C7.85535 8.32002 7.34785 8.32002 7.03535 8.63252L4.23535 11.4325C3.92285 11.745 3.92285 12.2525 4.23535 12.565L7.03535 15.365C7.34785 15.6775 7.85535 15.6775 8.16785 15.365C8.48035 15.0525 8.48035 14.545 8.16785 14.2325L5.93285 12L8.16785 9.76502C8.48035 9.45252 8.48035 8.94502 8.16785 8.63252Z"
                    fill="white"
                  />
                </g>
                <defs>
                  <clippath>
                    <rect
                      fill="white"
                      height="12.8"
                      transform="translate(4 5.60001)"
                      width="16"
                    />
                  </clippath>
                </defs>
              </svg>
            </div>
            <div
              class="pf-v6-l-stack"
            >
              <div
                class="pf-v6-l-stack__item"
              >
                <span
                  class="pf-chatbot__code-fileName"
                >
                  <div
                    style="display: contents;"
                  >
                    <span
                      class="pf-v6-c-truncate"
                    >
                      <span
                        class="pf-v6-c-truncate__start"
                      >
                        test
                      </span>
                    </span>
                  </div>
                </span>
              </div>
              <div
                class="pf-v6-l-stack__item pf-chatbot__code-language"
              >
                TEXT
              </div>
            </div>
          </div>
        </div>
      </span>
    </span>
  </span>
</div>
`;



================================================
FILE: packages/module/src/FileDropZone/FileDropZone.scss
================================================
.pf-chatbot__dropzone {
  gap: unset; // default PF value causes alignment issues when this is used to wrap other components, notably in the footer
  flex: 1;
}

.pf-chatbot__dropzone--invisible {
  overflow: hidden;
  display: grid;
  grid-template-rows: 1fr auto;

  // allows for zoom conditions; try zooming to 200% to see
  @media screen and (max-height: 518px) {
    overflow-y: auto;
  }
}

.pf-chatbot__dropzone--visible.pf-chatbot__dropzone {
  margin-block-start: var(--pf-t--global--spacer--lg);
  margin-block-end: var(--pf-t--global--spacer--lg);
  margin-inline-start: var(--pf-t--global--spacer--lg);
  margin-inline-end: var(--pf-t--global--spacer--lg);

  .pf-v6-c-multiple-file-upload__main {
    --pf-v6-c-multiple-file-upload__main--BorderWidth: var(--pf-t--global--border--width--regular);
    --pf-v6-c-multiple-file-upload__main--BorderStyle: dashed;
    --pf-v6-c-multiple-file-upload__main--BorderColor: var(--pf-t--global--border--color--default);
    --pf-v6-c-multiple-file-upload__main--BorderRadius: var(--pf-t--global--border--radius--medium);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
}

/** Used in example only */
.pf-chatbot__file-drop-zone-example {
  border: var(--pf-t--global--border--width--divider--default) solid var(--pf-t--global--border--color--default);
  height: 100vh;
  width: 100%;
  padding: var(--pf-t--global--spacer--md);
}

.pf-chatbot--default {
  // allows for zoom conditions; try zooming to 200% to see
  .pf-chatbot__dropzone--visible.pf-chatbot__dropzone {
    @media screen and (max-height: 518px) {
      display: flex;
      height: 100%;
      overflow: hidden;

      .pf-v6-c-multiple-file-upload__main {
        width: 100%;
      }
    }
  }
}



================================================
FILE: packages/module/src/FileDropZone/FileDropZone.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import FileDropZone from './FileDropZone';

describe('FileDropZone', () => {
  it('should render file drop zone', () => {
    const { container } = render(<FileDropZone onFileDrop={jest.fn()} />);
    expect(container).toMatchSnapshot();
  });
  it('should render children', () => {
    render(<FileDropZone onFileDrop={jest.fn()}>Hi</FileDropZone>);
    expect(screen.getByText('Hi')).toBeTruthy();
  });
});



================================================
FILE: packages/module/src/FileDropZone/FileDropZone.tsx
================================================
import { DropEvent, MultipleFileUpload, MultipleFileUploadMain } from '@patternfly/react-core';
import React from 'react';
import { ChatbotDisplayMode } from '../Chatbot';
import { UploadIcon } from '@patternfly/react-icons';

export interface FileDropZoneProps {
  /** Content displayed when the drop zone is not currently in use */
  children?: React.ReactNode;
  /** Custom classname for the outer dropzone component */
  className?: string;
  /** Informational text that shows below the title in the drop zone */
  infoText?: string;
  /** When files are dropped or uploaded this callback will be called with all accepted files */
  onFileDrop: (event: DropEvent, data: File[]) => void;
  /** Display mode for the Chatbot parent; this influences the styles applied */
  displayMode?: ChatbotDisplayMode;
}

const FileDropZone: React.FunctionComponent<FileDropZoneProps> = ({
  children,
  className,
  infoText = 'Maximum file size is 25 MB',
  onFileDrop,
  displayMode = ChatbotDisplayMode.default,
  ...props
}: FileDropZoneProps) => {
  const [showDropZone, setShowDropZone] = React.useState(false);

  const renderDropZone = () => (
    <>
      <MultipleFileUploadMain
        titleIcon={<UploadIcon />}
        titleText="Drag and drop your file here"
        infoText={infoText}
        isUploadButtonHidden
      />
    </>
  );

  return (
    <MultipleFileUpload
      dropzoneProps={{
        onDrop: () => setShowDropZone(false),
        ...props
      }}
      onDragEnter={() => setShowDropZone(true)}
      onDragLeave={() => setShowDropZone(false)}
      onFileDrop={onFileDrop}
      className={`pf-chatbot__dropzone pf-chatbot__dropzone--${displayMode} pf-chatbot__dropzone--${showDropZone ? 'visible' : 'invisible'} ${className ? className : ''}`}
    >
      {showDropZone ? renderDropZone() : children}
    </MultipleFileUpload>
  );
};

export default FileDropZone;



================================================
FILE: packages/module/src/FileDropZone/index.ts
================================================
export { default } from './FileDropZone';

export * from './FileDropZone';



================================================
FILE: packages/module/src/FileDropZone/__snapshots__/FileDropZone.test.tsx.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`FileDropZone should render file drop zone 1`] = `
<div>
  <div
    class="pf-v6-c-multiple-file-upload pf-chatbot__dropzone pf-chatbot__dropzone--default pf-chatbot__dropzone--invisible "
    role="presentation"
    tabindex="0"
  >
    <input
      hidden=""
      multiple=""
      style="border: 0px; clip: rect(0px, 0px, 0px, 0px); clip-path: inset(50%); height: 1px; margin: 0px -1px -1px 0px; overflow: hidden; padding: 0px; position: absolute; width: 1px; white-space: nowrap;"
      tabindex="-1"
      type="file"
    />
  </div>
</div>
`;



================================================
FILE: packages/module/src/LoadingMessage/index.ts
================================================
export { default } from './LoadingMessage';

export * from './LoadingMessage';



================================================
FILE: packages/module/src/LoadingMessage/LoadingMessage.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import LoadingMessage from './LoadingMessage';

describe('LoadingMessage', () => {
  it('should render loading message', () => {
    const { container } = render(<LoadingMessage />);
    expect(container).toMatchSnapshot();
  });
  it('should render loading message correctly', () => {
    render(<LoadingMessage />);
    expect(screen.getAllByText('.')).toBeTruthy();
    expect(screen.getAllByText('.')).toHaveLength(3);
  });
});



================================================
FILE: packages/module/src/LoadingMessage/LoadingMessage.tsx
================================================
import React from 'react';
import { Icon, Split, SplitItem } from '@patternfly/react-core';

import RobotIcon from '@patternfly/react-icons/dist/js/icons/robot-icon';

export interface LoadingMessageProps {
  icon?: React.ComponentType;
}

export const LoadingMessage: React.FunctionComponent<LoadingMessageProps> = ({ icon: IconComponent = RobotIcon }) => (
  <Split>
    <SplitItem>
      <Icon size="lg" className="pf-v6-u-mr-sm pf-v6-u-pt-md">
        <IconComponent />
      </Icon>
    </SplitItem>
    <SplitItem className="pf-u-background-color-200">
      <div className="pf-v6-u-display-flex pf-u-align-items-center">
        <div>.</div>
        <div>.</div>
        <div>.</div>
      </div>
    </SplitItem>
  </Split>
);

export default LoadingMessage;



================================================
FILE: packages/module/src/LoadingMessage/__snapshots__/LoadingMessage.test.tsx.snap
================================================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`LoadingMessage should render loading message 1`] = `
<div>
  <div
    class="pf-v6-l-split"
  >
    <div
      class="pf-v6-l-split__item"
    >
      <span
        class="pf-v6-c-icon pf-m-lg pf-v6-u-mr-sm pf-v6-u-pt-md"
      >
        <span
          class="pf-v6-c-icon__content"
        >
          <svg
            aria-hidden="true"
            class="pf-v6-svg"
            fill="currentColor"
            height="1em"
            role="img"
            viewBox="0 0 640 512"
            width="1em"
          >
            <path
              d="M32,224H64V416H32A31.96166,31.96166,0,0,1,0,384V256A31.96166,31.96166,0,0,1,32,224Zm512-48V448a64.06328,64.06328,0,0,1-64,64H160a64.06328,64.06328,0,0,1-64-64V176a79.974,79.974,0,0,1,80-80H288V32a32,32,0,0,1,64,0V96H464A79.974,79.974,0,0,1,544,176ZM264,256a40,40,0,1,0-40,40A39.997,39.997,0,0,0,264,256Zm-8,128H192v32h64Zm96,0H288v32h64ZM456,256a40,40,0,1,0-40,40A39.997,39.997,0,0,0,456,256Zm-8,128H384v32h64ZM640,256V384a31.96166,31.96166,0,0,1-32,32H576V224h32A31.96166,31.96166,0,0,1,640,256Z"
            />
          </svg>
        </span>
      </span>
    </div>
    <div
      class="pf-v6-l-split__item pf-u-background-color-200"
    >
      <div
        class="pf-v6-u-display-flex pf-u-align-items-center"
      >
        <div>
          .
        </div>
        <div>
          .
        </div>
        <div>
          .
        </div>
      </div>
    </div>
  </div>
</div>
`;



================================================
FILE: packages/module/src/Message/index.ts
================================================
export { default } from './Message';

export * from './Message';



================================================
FILE: packages/module/src/Message/Message.scss
================================================
// ============================================================================
// Chatbot Message
// ============================================================================
.pf-chatbot__message {
  display: flex;
  align-items: flex-start;
  gap: var(--pf-t--global--spacer--lg);
  padding-bottom: var(--pf-t--global--spacer--2xl);

  // Avatar
  // --------------------------------------------------------------------------
  &-avatar.pf-v6-c-avatar {
    --pf-v6-c-avatar--BorderRadius: 0;
    position: sticky;
    top: var(--pf-t--global--spacer--md);
    object-fit: cover;
    pointer-events: none; // prevent dragging - interferes with FileDropZone
  }

  &-avatar.pf-chatbot__message-avatar--round.pf-v6-c-avatar {
    --pf-v6-c-avatar--Width: 3rem;
    --pf-v6-c-avatar--Height: 3rem;
    --pf-v6-c-avatar--BorderRadius: var(--pf-t--global--border--radius--pill);
  }

  // Name
  // --------------------------------------------------------------------------
  .pf-v6-c-truncate {
    --pf-v6-c-truncate--MinWidth: 0ch;
    --pf-v6-c-truncate__start--MinWidth: 0ch;
  }

  // Contents
  // --------------------------------------------------------------------------
  &-contents {
    display: flex;
    flex-direction: column;
    gap: var(--pf-t--global--spacer--sm);
    width: 100%;
  }

  // Meta data
  // --------------------------------------------------------------------------
  &-meta {
    display: flex;
    align-items: center;
    gap: var(--pf-t--global--spacer--sm);

    // Author name
    .pf-chatbot__message-name {
      font-family: var(--pf-t--chatbot--heading--font-family);
      font-weight: 600;
      font-size: var(--pf-t--global--font--size--sm);
    }

    // Badge
    .pf-v6-c-label {
      --pf-v6-c-label--m-outline--BorderColor: var(--pf-t--global--border--color--on-secondary);
      --pf-v6-c-label--FontSize: var(--pf-t--global--font--size--xs);
      font-weight: var(--pf-t--global--font--weight--body--bold);

      .pf-v6-c-label__content {
        --pf-v6-c-label--Color: var(--pf-t--global--border--color--on-secondary);
      }
    }

    // Timestamp
    .pf-v6-c-timestamp {
      flex: 1 0 max-content;
    }
    time {
      font-size: var(--pf-t--global--font--size--xs);
    }
  }

  // Response content
  // --------------------------------------------------------------------------
  &-response {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: var(--pf-t--global--font--size--sm);
    color: var(--pf-t--global--text--color--regular);
  }

  &-and-actions {
    display: grid;
    gap: var(--pf-t--global--spacer--sm);
  }
}

// Attachments
// --------------------------------------------------------------------------
.pf-chatbot__message-attachments-container {
  display: flex;
  gap: var(--pf-t--global--spacer--md);
  flex-wrap: wrap;
}

.pf-chatbot__message-edit-buttons {
  --pf-v6-c-form__group--m-action--MarginBlockStart: 0;
}

@import './MessageLoading';
@import './CodeBlockMessage/CodeBlockMessage';
@import './TextMessage/TextMessage';

// ============================================================================
// Information density styles
// ============================================================================
.pf-chatbot.pf-m-compact {
  .pf-chatbot__message {
    gap: var(--pf-t--global--spacer--md);
    padding-bottom: var(--pf-t--global--spacer--sm);

    .pf-chatbot__message-contents  {
      gap: var(--pf-t--global--spacer--xs);
    }
  }

  .pf-chatbot__message-name {
    font-size: var(--pf-t--global--font--size--xs);
  }

  .pf-chatbot__message-avatar.pf-chatbot__message-avatar--round.pf-v6-c-avatar {
    --pf-v6-c-avatar--Width: 2rem;
    --pf-v6-c-avatar--Height: 2rem;
  }

  .pf-chatbot__message-contents {
    gap: var(--pf-t--global--spacer--xs);
  }
}



================================================
FILE: packages/module/src/Message/Message.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import Message from './Message';
import userEvent from '@testing-library/user-event';
import { monitorSampleAppQuickStart } from './QuickStarts/monitor-sampleapp-quickstart';
import { monitorSampleAppQuickStartWithImage } from './QuickStarts/monitor-sampleapp-quickstart-with-image';
import rehypeExternalLinks from '../__mocks__/rehype-external-links';
import { AlertActionLink } from '@patternfly/react-core';

const ALL_ACTIONS = [
  { label: /Good response/i },
  { label: /Bad response/i },
  { label: /Copy/i },
  { label: /Share/i },
  { label: /Listen/i }
];

const UNORDERED_LIST = `
  Here is an unordered list:

  * Item 1
  * Item 2
  * Item 3
`;

const ORDERED_LIST = `
  Here is an ordered list:

  1. Item 1
  2. Item 2
  3. Item 3
`;

const CODE_MESSAGE = `
Here is some YAML code:

~~~yaml
apiVersion: helm.openshift.io/v1beta1/
kind: HelmChartRepository
metadata:
  name: azure-sample-repo0oooo00ooo
spec:
  connectionConfig:
  url: https://raw.githubusercontent.com/Azure-Samples/helm-charts/master/docs
~~~`;

const CODE = `
apiVersion: helm.openshift.io/v1beta1/
kind: HelmChartRepository
metadata:
  name: azure-sample-repo0oooo00ooo
spec:
  connectionConfig:
  url: https://raw.githubusercontent.com/Azure-Samples/helm-charts/master/docs
`;

const INLINE_CODE = `Here is an inline code - \`() => void\``;

const ORDERED_LIST_WITH_CODE = `
1. Item 1
2. Item 2

\`\`\`yaml
- name: Hello World Playbook
  hosts: localhost
  tasks:
    - name: Print Hello World
      ansible.builtin.debug:
        msg: "Hello, World!"
\`\`\`

3. Item 3
`;

const HEADING = `
# h1 Heading

## h2 Heading

### h3 Heading

#### h4 Heading

##### h5 Heading

###### h6 Heading
`;

const BLOCK_QUOTES = `> Blockquotes can also be nested...
>> ...by using additional greater-than signs (>) right next to each other...
> > > ...or with spaces between each sign.`;
const TABLE = `

 | Column 1 | Column 2 |
 |-|-|
 | Cell 1 | Cell 2 |
 | Cell 3 | Cell 4 |

 `;

const ONE_COLUMN_TABLE = `

 | Column 1 |
 |-|
 | Cell 1 | 
 | Cell 2 |

 `;

const ONE_CELL_TABLE = `

 | Column 1 |
 |-|
 | Cell 1 | 

 `;

const HEADERLESS_TABLE = `

 | |
 |-|
 | Cell 1 | 

 `;

const CHILDLESS_TABLE = `

 | Column 1 |
 |-|
 | | 

 `;

const EMPTY_TABLE = `

 | |
 |-|
 | | 

 `;

const IMAGE = `![Multi-colored wavy lines on a black background](https://cdn.dribbble.com/userupload/10651749/file/original-8a07b8e39d9e8bf002358c66fce1223e.gif)`;

const ERROR = {
  title: 'Could not load chat',
  children: 'Wait a few minutes and check your network settings. If the issue persists: ',
  actionLinks: (
    <React.Fragment>
      <AlertActionLink component="a" href="#">
        Start a new chat
      </AlertActionLink>
      <AlertActionLink component="a" href="#">
        Contact support
      </AlertActionLink>
    </React.Fragment>
  )
};
const checkListItemsRendered = () => {
  const items = ['Item 1', 'Item 2', 'Item 3'];
  expect(screen.getAllByRole('listitem')).toHaveLength(3);
  items.forEach((item) => {
    // list item text gets wrapped in a span by the third-party library so we can't just check the listitem
    expect(screen.getByText(item)).toBeTruthy();
  });
};

describe('Message', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });
  it('should render user messages correctly', () => {
    render(<Message avatar="./img" role="user" name="User" content="Hi" />);
    expect(screen.getByText('User')).toBeTruthy();
    expect(screen.getByText('Hi')).toBeTruthy();
    const date = new Date();
    const formattedDate = date.toLocaleDateString();
    expect(
      screen.getByText((content, element) => {
        const hasText = content.includes(formattedDate);
        const isVisible = element?.tagName.toLowerCase() !== 'script' && element?.tagName.toLowerCase() !== 'style';
        return hasText && isVisible;
      })
    ).toBeInTheDocument();
    expect(screen.queryByText('Loading message')).toBeFalsy();
    expect(screen.getByRole('img')).toHaveAttribute('src', './img');
  });
  it('should render bot messages correctly', () => {
    render(<Message avatar="./img" role="bot" name="Bot" content="Hi" />);
    expect(screen.getByText('Bot')).toBeTruthy();
    expect(screen.getByText('AI')).toBeTruthy();
    expect(screen.getByText('Hi')).toBeTruthy();
    const date = new Date();
    const formattedDate = date.toLocaleDateString();
    expect(
      screen.getByText((content, element) => {
        const hasText = content.includes(formattedDate);
        const isVisible = element?.tagName.toLowerCase() !== 'script' && element?.tagName.toLowerCase() !== 'style';
        return hasText && isVisible;
      })
    ).toBeInTheDocument();
  });
  it('should render avatar correctly', () => {
    render(<Message avatar="./testImg" role="bot" name="Bot" content="Hi" />);
    expect(screen.getByRole('img')).toHaveAttribute('src', './testImg');
  });
  it('should render botWord correctly', () => {
    render(<Message avatar="./img" role="bot" name="Bot" content="Hi" botWord="人工知能" />);
    expect(screen.getByText('Bot')).toBeTruthy();
    expect(screen.getByText('人工知能')).toBeTruthy();
    expect(screen.queryByText('AI')).toBeFalsy();
    expect(screen.getByText('Hi')).toBeTruthy();
  });
  it('should render timestamps', () => {
    render(<Message avatar="./img" role="bot" name="Bot" content="Hi" timestamp="2 hours ago" />);
    expect(screen.getByText('Bot')).toBeTruthy();
    expect(screen.getByText('AI')).toBeTruthy();
    expect(screen.getByText('Hi')).toBeTruthy();
    expect(screen.getByText('2 hours ago')).toBeTruthy();
    const date = new Date();
    const formattedDate = date.toLocaleDateString();
    expect(
      screen.queryByText((content, element) => {
        const hasText = content.includes(formattedDate);
        const isVisible = element?.tagName.toLowerCase() !== 'script' && element?.tagName.toLowerCase() !== 'style';
        return hasText && isVisible;
      })
    ).not.toBeInTheDocument();
  });
  it('should render attachments', () => {
    render(<Message avatar="./img" role="user" content="Hi" attachments={[{ name: 'testAttachment' }]} />);
    expect(screen.getByText('Hi')).toBeTruthy();
    expect(screen.getByText('testAttachment')).toBeTruthy();
  });
  it('should be able to click attachments', async () => {
    const spy = jest.fn();
    render(
      <Message avatar="./img" role="user" content="Hi" attachments={[{ name: 'testAttachment', onClick: spy }]} />
    );
    expect(screen.getByText('Hi')).toBeTruthy();
    expect(screen.getByText('testAttachment')).toBeTruthy();
    await userEvent.click(screen.getByRole('button', { name: /testAttachment/i }));
    expect(spy).toHaveBeenCalledTimes(1);
  });
  it('should be able to close attachments', async () => {
    const spy = jest.fn();
    render(
      <Message avatar="./img" role="user" content="Hi" attachments={[{ name: 'testAttachment', onClose: spy }]} />
    );
    expect(screen.getByText('Hi')).toBeTruthy();
    expect(screen.getByText('testAttachment')).toBeTruthy();
    expect(screen.getByRole('button', { name: /close testAttachment/i })).toBeTruthy();
    await userEvent.click(screen.getByRole('button', { name: /close testAttachment/i }));
    expect(spy).toHaveBeenCalledTimes(1);
  });
  it('should render loading state', () => {
    render(<Message avatar="./img" role="bot" name="Bot" content="Hi" isLoading />);
    expect(screen.getByText('Bot')).toBeTruthy();
    expect(screen.getByText('AI')).toBeTruthy();
    expect(screen.queryByText('Hi')).toBeFalsy();
    const date = new Date();
    const formattedDate = date.toLocaleDateString();
    expect(
      screen.getByText((content, element) => {
        const hasText = content.includes(formattedDate);
        const isVisible = element?.tagName.toLowerCase() !== 'script' && element?.tagName.toLowerCase() !== 'style';
        return hasText && isVisible;
      })
    ).toBeInTheDocument();
    expect(screen.getByText('Loading message')).toBeTruthy();
  });
  it('should be able to show sources', async () => {
    render(
      <Message
        avatar="./img"
        role="bot"
        name="Bot"
        content="Hi"
        sources={{
          sources: [
            {
              title: 'Getting started with Red Hat OpenShift',
              link: '#',
              body: 'Red Hat OpenShift on IBM Cloud is a managed offering to create your own cluster of compute hosts where you can deploy and manage containerized apps on IBM Cloud ...'
            }
          ]
        }}
      />
    );
    expect(screen.getByText('Getting started with Red Hat OpenShift')).toBeTruthy();
  });
  it('should not show sources if loading', () => {
    render(
      <Message
        avatar="./img"
        role="bot"
        name="Bot"
        content="Hi"
        isLoading
        sources={{
          sources: [
            {
              title: 'Getting started with Red Hat OpenShift',
              link: '#',
              body: 'Red Hat OpenShift on IBM Cloud is a managed offering to create your own cluster of compute hosts where you can deploy and manage containerized apps on IBM Cloud ...'
            }
          ]
        }}
      />
    );
    expect(screen.getByText('Loading message')).toBeTruthy();
    expect(screen.queryByText('Getting started with Red Hat OpenShift')).toBeFalsy();
  });
  it('should be able to show quick response', async () => {
    const spy = jest.fn();
    render(
      <Message
        avatar="./img"
        role="bot"
        name="Bot"
        content="Hi"
        quickResponses={[
          {
            id: '1',
            content: 'Yes',
            onClick: spy,
            className: 'test'
          }
        ]}
      />
    );
    const quickResponse = screen.getByRole('button', { name: /Yes/i });
    expect(quickResponse).toBeTruthy();
    await userEvent.click(quickResponse);
    expect(spy).toHaveBeenCalledTimes(1);
  });
  it('should be able to handle isCompact', async () => {
    render(
      <Message
        avatar="./img"
        role="bot"
        name="Bot"
        content="Hi"
        quickResponses={[
          {
            id: '1',
            content: 'Yes',
            onClick: jest.fn(),
            className: 'test'
          }
        ]}
        isCompact
      />
    );
    const parent = screen.getByRole('button', { name: /Yes/i }).parentNode;
    expect(parent).toHaveClass('pf-m-compact');
  });
  it('should be able to show more than 1 quick response', async () => {
    const spy = jest.fn();
    render(
      <Message
        avatar="./img"
        role="bot"
        name="Bot"
        content="Hi"
        quickResponses={[
          {
            id: '1',
            content: 'Yes',
            onClick: spy
          },
          {
            id: '2',
            content: 'No',
            onClick: spy
          }
        ]}
      />
    );
    expect(screen.getByRole('button', { name: /Yes/i })).toBeTruthy();
    expect(screen.getByRole('button', { name: /No/i })).toBeTruthy();
  });
  it('should be able to spread quickResponseContainerProps', async () => {
    const spy = jest.fn();
    render(
      <Message
        avatar="./img"
        role="bot"
        name="Bot"
        content="Hi"
        quickResponses={[
          {
            id: '1',
            content: 'Yes',
            onClick: spy
          },
          {
            id: '2',
            content: 'No',
            onClick: spy
          }
        ]}
        // this is a LabelGroup prop that changes the default number shown
        // to be different than what we use in ChatBot
        quickResponseContainerProps={{ numLabels: 1 }}
      />
    );
    expect(screen.getByRole('button', { name: /Yes/i })).toBeTruthy();
    expect(screen.queryByRole('button', { name: /No/i })).toBeFalsy();
    expect(screen.getByRole('button', { name: /1 more/i }));
  });
  it('should be able to show actions', async () => {
    render(
      <Message
        avatar="./img"
        role="bot"
        name="Bot"
        content="Hi"
        actions={{
          // eslint-disable-next-line no-console
          positive: { onClick: () => console.log('Good response') },
          // eslint-disable-next-line no-console
          negative: { onClick: () => console.log('Bad response') },
          // eslint-disable-next-line no-console
          copy: { onClick: () => console.log('Copy') },
          // eslint-disable-next-line no-console
          share: { onClick: () => console.log('Share') },
          // eslint-disable-next-line no-console
          listen: { onClick: () => console.log('Listen') }
        }}
      />
    );
    ALL_ACTIONS.forEach(({ label }) => {
      expect(screen.getByRole('button', { name: label })).toBeTruthy();
    });
  });
  it('should not show actions if loading', async () => {
    render(
      <Message
        avatar="./img"
        role="bot"
        name="Bot"
        content="Hi"
        isLoading
        actions={{
          // eslint-disable-next-line no-console
          positive: { onClick: () => console.log('Good response') },
          // eslint-disable-next-line no-console
          negative: { onClick: () => console.log('Bad response') },
          // eslint-disable-next-line no-console
          copy: { onClick: () => console.log('Copy') },
          // eslint-disable-next-line no-console
          share: { onClick: () => console.log('Share') },
          // eslint-disable-next-line no-console
          listen: { onClick: () => console.log('Listen') }
        }}
      />
    );
    expect(screen.getByText('Loading message')).toBeTruthy();
    ALL_ACTIONS.forEach(({ label }) => {
      expect(screen.queryByRole('button', { name: label })).toBeFalsy();
    });
  });
  it('should render unordered lists correctly', () => {
    render(<Message avatar="./img" role="user" name="User" content={UNORDERED_LIST} />);
    expect(screen.getByText('Here is an unordered list:')).toBeTruthy();
    checkListItemsRendered();
  });
  it('should render ordered lists correctly', () => {
    render(<Message avatar="./img" role="user" name="User" content={ORDERED_LIST} />);
    expect(screen.getByText('Here is an ordered list:')).toBeTruthy();
    checkListItemsRendered();
  });
  it('should render ordered lists correctly if there is interstitial content', () => {
    render(<Message avatar="./img" role="user" name="User" content={ORDERED_LIST_WITH_CODE} />);
    checkListItemsRendered();
    const list = screen.getAllByRole('list')[1];
    expect(list).toHaveAttribute('start', '3');
  });
  it('should render inline code', () => {
    render(<Message avatar="./img" role="user" name="User" content={INLINE_CODE} />);
    expect(screen.getByText(/() => void/i)).toBeTruthy();
    expect(screen.queryByRole('button', { name: 'Copy code button' })).toBeFalsy();
  });
  it('should render code correctly', () => {
    render(<Message avatar="./img" role="user" name="User" content={CODE_MESSAGE} />);
    expect(screen.getByText('Here is some YAML code:')).toBeTruthy();
    expect(screen.getByRole('button', { name: 'Copy code' })).toBeTruthy();
    expect(screen.getByText(/yaml/)).toBeTruthy();
    expect(screen.getByText(/apiVersion:/i)).toBeTruthy();
    expect(screen.getByText(/helm.openshift.io\/v1beta1/i)).toBeTruthy();
    expect(screen.getByText(/metadata:/i)).toBeTruthy();
    expect(screen.getByText(/name:/i)).toBeTruthy();
    expect(screen.getByText(/azure-sample-repo0oooo00ooo/i)).toBeTruthy();
    expect(screen.getByText(/spec/i)).toBeTruthy();
    expect(screen.getByText(/connectionConfig:/i)).toBeTruthy();
    expect(screen.getByText(/url:/i)).toBeTruthy();
    expect(
      screen.getByText(/https:\/\/raw.githubusercontent.com\/Azure-Samples\/helm-charts\/master\/docs/i)
    ).toBeTruthy();
  });
  it('can click copy code button', async () => {
    // need explicit setup since RTL stubs clipboard if you do this
    const user = userEvent.setup();
    render(<Message avatar="./img" role="user" name="User" content={CODE_MESSAGE} />);
    expect(screen.getByRole('button', { name: 'Copy code' })).toBeTruthy();
    await user.click(screen.getByRole('button', { name: 'Copy code' }));
    const clipboardText = await navigator.clipboard.readText();
    expect(clipboardText.trim()).toEqual(CODE.trim());
  });
  it('should handle codeBlockProps correctly by spreading it onto the CodeMessage', () => {
    render(
      <Message
        avatar="./img"
        role="user"
        name="User"
        content={CODE_MESSAGE}
        codeBlockProps={{ 'aria-label': 'test' }}
      />
    );
    expect(screen.getByRole('button', { name: 'test' })).toBeTruthy();
  });
  it('should handle hasRoundAvatar correctly when it is true', () => {
    render(<Message avatar="./img" role="user" name="User" content="Hi" hasRoundAvatar />);
    expect(screen.getByRole('img')).toBeTruthy();
    expect(screen.getByRole('img')).toHaveClass('pf-chatbot__message-avatar');
    expect(screen.getByRole('img')).toHaveClass('pf-chatbot__message-avatar--round');
  });
  it('should handle hasRoundAvatar correctly when it is false', () => {
    render(<Message avatar="./img" role="user" name="User" content="Hi" hasRoundAvatar={false} />);
    expect(screen.getByRole('img')).toBeTruthy();
    expect(screen.getByRole('img')).toHaveClass('pf-chatbot__message-avatar');
    expect(screen.getByRole('img')).not.toHaveClass('pf-chatbot__message-avatar--round');
  });
  it('should handle avatarProps correctly by spreading it onto the Message Avatar', () => {
    render(<Message avatar="./img" role="user" name="User" content="Hi" avatarProps={{ className: 'test' }} />);
    expect(screen.getByRole('img')).toBeTruthy();
    expect(screen.getByRole('img')).toHaveClass('test');
  });
  it('should handle avatarProps and hasRoundAvatar correctly', () => {
    render(
      <Message
        avatar="./img"
        role="user"
        name="User"
        content="Hi"
        avatarProps={{ className: 'test' }}
        hasRoundAvatar={false}
      />
    );
    expect(screen.getByRole('img')).toBeTruthy();
    expect(screen.getByRole('img')).toHaveClass('test');
    expect(screen.getByRole('img')).toHaveClass('pf-chatbot__message-avatar');
  });
  it('should handle QuickStart tile correctly', () => {
    render(
      <Message
        avatar="./img"
        role="user"
        name="User"
        content="Hi"
        quickStarts={{
          quickStart: monitorSampleAppQuickStart,
          onSelectQuickStart: (id) => alert(id)
        }}
      />
    );
    expect(screen.getByRole('button', { name: 'Monitoring your sample application' })).toBeTruthy();
    expect(screen.getByRole('heading', { name: '1 Prerequisite' })).toBeTruthy();
    expect(screen.getByRole('button', { name: 'Show prerequisites' })).toBeTruthy();
    expect(screen.getByRole('button', { name: 'Start' })).toBeTruthy();
  });
  it('should handle click on QuickStart tile correctly', async () => {
    const spy = jest.fn();
    render(
      <Message
        avatar="./img"
        role="user"
        name="User"
        content="Hi"
        quickStarts={{
          quickStart: monitorSampleAppQuickStart,
          onSelectQuickStart: (id) => spy(id)
        }}
      />
    );
    await userEvent.click(screen.getByRole('button', { name: 'Monitoring your sample application' }));
    expect(spy).toHaveBeenCalledTimes(1);
    expect(spy).toHaveBeenCalledWith(monitorSampleAppQuickStart.metadata.name);
  });
  it('should handle QuickStart tile with image correctly', async () => {
    const spy = jest.fn();
    render(
      <Message
        avatar="./img"
        role="user"
        name="User"
        content="Hi"
        quickStarts={{
          quickStart: monitorSampleAppQuickStartWithImage,
          onSelectQuickStart: (id) => spy(id)
        }}
      />
    );
    expect(screen.getAllByRole('img')[1]).toHaveAttribute('src', 'test.png');
  });
  it('should handle block quote correctly', () => {
    render(<Message avatar="./img" role="user" name="User" content={BLOCK_QUOTES} />);
    expect(screen.getByText(/Blockquotes can also be nested.../)).toBeTruthy();
    expect(screen.getByText('...by using additional greater-than signs (>) right next to each other...')).toBeTruthy();
    expect(screen.getByText(/...or with spaces between each sign./)).toBeTruthy();
  });
  it('should handle heading correctly', () => {
    render(<Message avatar="./img" role="user" name="User" content={HEADING} />);
    expect(screen.getByRole('heading', { name: /h1 Heading/i })).toBeTruthy();
    expect(screen.getByRole('heading', { name: /h2 Heading/i })).toBeTruthy();
    expect(screen.getByRole('heading', { name: /h3 Heading/i })).toBeTruthy();
    expect(screen.getByRole('heading', { name: /h4 Heading/i })).toBeTruthy();
    expect(screen.getByRole('heading', { name: /h5 Heading/i })).toBeTruthy();
    expect(screen.getByRole('heading', { name: /h6 Heading/i })).toBeTruthy();
  });
  it('should render table correctly', () => {
    render(<Message avatar="./img" role="user" name="User" content={TABLE} />);
    expect(screen.getByRole('row', { name: /Column 1 Column 2/i })).toBeTruthy();
    expect(screen.getByRole('row', { name: /Cell 1 Cell 2/i })).toBeTruthy();
    expect(screen.getByRole('row', { name: /Cell 3 Cell 4/i })).toBeTruthy();
    expect(screen.getByRole('columnheader', { name: /Column 1/i })).toBeTruthy();
    expect(screen.getByRole('columnheader', { name: /Column 2/i })).toBeTruthy();
    expect(screen.getByRole('cell', { name: /Cell 1/i })).toBeTruthy();
    expect(screen.getByRole('cell', { name: /Cell 2/i })).toBeTruthy();
    expect(screen.getByRole('cell', { name: /Cell 3/i })).toBeTruthy();
    expect(screen.getByRole('cell', { name: /Cell 4/i })).toBeTruthy();
  });
  it('should render table data labels correctly for mobile breakpoint', () => {
    render(<Message avatar="./img" role="user" name="User" content={TABLE} />);
    expect(screen.getByRole('row', { name: /Cell 1 Cell 2/i })).toHaveAttribute('extraHeaders', 'Column 1,Column 2');
    expect(screen.getByRole('row', { name: /Cell 3 Cell 4/i })).toHaveAttribute('extraHeaders', 'Column 1,Column 2');
    expect(screen.getByRole('cell', { name: /Cell 1/i })).toHaveAttribute('data-label', 'Column 1');
    expect(screen.getByRole('cell', { name: /Cell 2/i })).toHaveAttribute('data-label', 'Column 2');
    expect(screen.getByRole('cell', { name: /Cell 3/i })).toHaveAttribute('data-label', 'Column 1');
    expect(screen.getByRole('cell', { name: /Cell 4/i })).toHaveAttribute('data-label', 'Column 2');
  });
  it('should render table data labels correctly for mobile breakpoint for one column table', () => {
    render(<Message avatar="./img" role="user" name="User" content={ONE_COLUMN_TABLE} />);
    expect(screen.getByRole('row', { name: /Cell 1/i })).toHaveAttribute('extraHeaders', 'Column 1');
    expect(screen.getByRole('row', { name: /Cell 2/i })).toHaveAttribute('extraHeaders', 'Column 1');
    expect(screen.getByRole('cell', { name: /Cell 1/i })).toHaveAttribute('data-label', 'Column 1');
    expect(screen.getByRole('cell', { name: /Cell 2/i })).toHaveAttribute('data-label', 'Column 1');
  });
  it('should render table data labels correctly for mobile breakpoint for one cell table', () => {
    render(<Message avatar="./img" role="user" name="User" content={ONE_CELL_TABLE} />);
    expect(screen.getByRole('row', { name: /Cell 1/i })).toHaveAttribute('extraHeaders', 'Column 1');
    expect(screen.getByRole('cell', { name: /Cell 1/i })).toHaveAttribute('data-label', 'Column 1');
  });
  it('should render table data labels correctly for mobile breakpoint for headerless', () => {
    render(<Message avatar="./img" role="user" name="User" content={HEADERLESS_TABLE} />);
    expect(screen.getByRole('row', { name: /Cell 1/i })).toHaveAttribute('extraHeaders', '');
    expect(screen.getByRole('cell', { name: /Cell 1/i })).not.toHaveAttribute('data-label');
  });
  it('should render table data labels correctly for mobile breakpoint for childless', () => {
    render(<Message avatar="./img" role="user" name="User" content={CHILDLESS_TABLE} />);
    expect(screen.getByRole('cell')).not.toHaveAttribute('extraHeaders', 'Column 1');
  });
  it('should render table data labels correctly for mobile breakpoint for empty', () => {
    render(<Message avatar="./img" role="user" name="User" content={EMPTY_TABLE} />);
    expect(screen.getByRole('cell')).not.toHaveAttribute('extraHeaders', '');
  });
  it('should render custom table aria label correctly', () => {
    render(<Message avatar="./img" role="user" name="User" content={TABLE} tableProps={{ 'aria-label': 'Test' }} />);
    expect(screen.getByRole('grid', { name: /Test/i })).toBeTruthy();
  });
  it('should render beforeMainContent with main content', () => {
    const mainContent = 'Main message content';
    const beforeMainContentText = 'Before main content';
    const beforeMainContent = <div>{beforeMainContentText}</div>;

    render(
      <Message avatar="./img" role="user" name="User" content={mainContent} extraContent={{ beforeMainContent }} />
    );

    expect(screen.getByText(beforeMainContentText)).toBeTruthy();
    expect(screen.getByText(mainContent)).toBeTruthy();
  });
  it('should render afterMainContent with main content', () => {
    const mainContent = 'Main message content';
    const afterMainContentText = 'After main content';
    const afterMainContent = <div>{afterMainContentText}</div>;

    render(
      <Message avatar="./img" role="user" name="User" content={mainContent} extraContent={{ afterMainContent }} />
    );

    expect(screen.getByText(afterMainContentText)).toBeTruthy();
    expect(screen.getByText(mainContent)).toBeTruthy();
  });

  it('should render endContent with main content', () => {
    const mainContent = 'Main message content';
    const endMainContentText = 'End content';
    const endContent = <div>{endMainContentText}</div>;

    render(<Message avatar="./img" role="user" name="User" content={mainContent} extraContent={{ endContent }} />);

    expect(screen.getByText(endMainContentText)).toBeTruthy();
    expect(screen.getByText(mainContent)).toBeTruthy();
  });
  it('should render all parts of extraContent with main content', () => {
    const beforeMainContent = <div>Before main content</div>;
    const afterMainContent = <div>After main content</div>;
    const endContent = <div>End content</div>;

    render(
      <Message
        avatar="./img"
        role="user"
        name="User"
        content="Main message content"
        extraContent={{ beforeMainContent, afterMainContent, endContent }}
      />
    );

    expect(screen.getByText('Before main content')).toBeTruthy();
    expect(screen.getByText('Main message content')).toBeTruthy();
    expect(screen.getByText('After main content')).toBeTruthy();
    expect(screen.getByText('End content')).toBeTruthy();
  });

  it('should not render extraContent when not provided', () => {
    render(<Message avatar="./img" role="user" name="User" content="Main message content" />);

    // Ensure no extraContent is rendered
    expect(screen.getByText('Main message content')).toBeTruthy();
    expect(screen.queryByText('Before main content')).toBeFalsy();
    expect(screen.queryByText('After main content')).toBeFalsy();
    expect(screen.queryByText('end message content')).toBeFalsy();
  });

  it('should handle undefined or null values in extraContent gracefully', () => {
    render(
      <Message
        avatar="./img"
        role="user"
        name="User"
        content="Main message content"
        extraContent={{ beforeMainContent: null, afterMainContent: undefined, endContent: null }}
      />
    );

    // Ensure that no extraContent is rendered if they are null or undefined
    expect(screen.getByText('Main message content')).toBeTruthy();
    expect(screen.queryByText('Before main content')).toBeFalsy();
    expect(screen.queryByText('After main content')).toBeFalsy();
    expect(screen.queryByText('end message content')).toBeFalsy();
  });
  it('should render JSX in extraContent correctly', () => {
    const beforeMainContent = (
      <div data-testid="before-main-content">
        <strong>Bold before content</strong>
      </div>
    );
    const afterMainContent = (
      <div data-testid="after-main-content">
        <strong>Bold after content</strong>
      </div>
    );
    const endContent = (
      <div data-testid="end-main-content">
        <strong>Bold end content</strong>
      </div>
    );
    render(
      <Message
        avatar="./img"
        role="user"
        name="User"
        content="Main message content"
        extraContent={{ beforeMainContent, afterMainContent, endContent }}
      />
    );

    // Check that the JSX is correctly rendered
    expect(screen.getByTestId('before-main-content')).toContainHTML('<strong>Bold before content</strong>');
    expect(screen.getByTestId('after-main-content')).toContainHTML('<strong>Bold after content</strong>');
    expect(screen.getByTestId('end-main-content')).toContainHTML('<strong>Bold end content</strong>');
  });
  it('should handle image correctly', () => {
    render(<Message avatar="./img" role="user" name="User" content={IMAGE} />);
    expect(screen.getByRole('img', { name: /Multi-colored wavy lines on a black background/i })).toBeTruthy();
  });
  it('should handle external links correctly', () => {
    render(<Message avatar="./img" role="user" name="User" content={`[PatternFly](https://www.patternfly.org/)`} />);
    // we are mocking rehype libraries, so we can't test target _blank addition on links directly with RTL
    expect(rehypeExternalLinks).toHaveBeenCalledTimes(1);
  });
  it('should handle external links correctly', () => {
    render(
      <Message
        avatar="./img"
        role="user"
        name="User"
        content={`[PatternFly](https://www.patternfly.org/)`}
        openLinkInNewTab={false}
      />
    );
    // we are mocking rehype libraries, so we can't test target _blank addition on links directly with RTL
    expect(rehypeExternalLinks).not.toHaveBeenCalled();
  });
  it('should handle extra link props correctly', async () => {
    const spy = jest.fn();
    render(
      <Message
        avatar="./img"
        role="user"
        name="User"
        content={`[PatternFly](https://www.patternfly.org/)`}
        linkProps={{ onClick: spy }}
      />
    );
    await userEvent.click(screen.getByRole('link', { name: /PatternFly/i }));
    expect(spy).toHaveBeenCalledTimes(1);
  });
  it('should handle error correctly', () => {
    render(<Message avatar="./img" role="user" name="User" error={ERROR} />);
    expect(screen.getByRole('heading', { name: /Could not load chat/i })).toBeTruthy();
    expect(screen.getByRole('link', { name: /Start a new chat/i })).toBeTruthy();
    expect(screen.getByRole('link', { name: /Contact support/i })).toBeTruthy();
    expect(screen.getByText('Wait a few minutes and check your network settings. If the issue persists:')).toBeTruthy();
  });
  it('should handle error correctly when loading', () => {
    render(<Message avatar="./img" role="user" name="User" error={ERROR} isLoading />);
    expect(screen.queryByRole('heading', { name: /Could not load chat/i })).toBeFalsy();
    expect(screen.getByText('Loading message')).toBeTruthy();
  });
  it('should handle error correctly when these is content', () => {
    render(<Message avatar="./img" role="user" name="User" error={ERROR} content="Test" />);
    expect(screen.getByRole('heading', { name: /Could not load chat/i })).toBeTruthy();
    expect(screen.queryByText('Test')).toBeFalsy();
  });
  it('should handle isEditable when there is message content', () => {
    render(<Message avatar="./img" role="user" name="User" isEditable content="Test" />);
    expect(screen.getByRole('textbox')).toBeTruthy();
    expect(screen.getByRole('textbox')).toHaveValue('Test');
    expect(screen.getByRole('button', { name: /Update/i })).toBeTruthy();
    expect(screen.getByRole('button', { name: /Cancel/i })).toBeTruthy();
  });
  it('should handle isEditable when there is no message content', () => {
    render(<Message avatar="./img" role="user" name="User" isEditable />);
    expect(screen.getByRole('textbox')).toBeTruthy();
    expect(screen.getByRole('textbox')).toHaveValue('');
    expect(screen.getByRole('textbox')).toHaveAttribute('placeholder', 'Edit prompt message...');
    expect(screen.getByRole('button', { name: /Update/i })).toBeTruthy();
    expect(screen.getByRole('button', { name: /Cancel/i })).toBeTruthy();
  });
  it('should be able to change edit placeholder', () => {
    render(<Message avatar="./img" role="user" name="User" isEditable editPlaceholder="I am a placeholder" />);
    expect(screen.getByRole('textbox')).toBeTruthy();
    expect(screen.getByRole('textbox')).toHaveValue('');
    expect(screen.getByRole('textbox')).toHaveAttribute('placeholder', 'I am a placeholder');
  });
  it('should be able to change updateWord', () => {
    render(<Message avatar="./img" role="user" name="User" isEditable updateWord="Submit" />);
    expect(screen.getByRole('button', { name: /Submit/i })).toBeTruthy();
  });
  it('should be able to change cancelWord', () => {
    render(<Message avatar="./img" role="user" name="User" isEditable cancelWord="Don't submit" />);
    expect(screen.getByRole('button', { name: /Don't submit/i })).toBeTruthy();
  });
  it('should be able to add onEditUpdate', async () => {
    const spy = jest.fn();
    render(<Message avatar="./img" role="user" name="User" isEditable onEditUpdate={spy} />);
    await userEvent.click(screen.getByRole('button', { name: /Update/i }));
    expect(spy).toHaveBeenCalledTimes(1);
  });
  it('should be able to add onEditCancel', async () => {
    const spy = jest.fn();
    render(<Message avatar="./img" role="user" name="User" isEditable onEditCancel={spy} />);
    await userEvent.click(screen.getByRole('button', { name: /Cancel/i }));
    expect(spy).toHaveBeenCalledTimes(1);
  });
  it('should be able to add  editFormProps', () => {
    const { container } = render(
      <Message avatar="./img" role="user" name="User" isEditable editFormProps={{ className: 'test' }} />
    );
    const form = container.querySelector('form');
    expect(form).toHaveClass('test');
  });
});



================================================
FILE: packages/module/src/Message/Message.tsx
================================================
// ============================================================================
// Chatbot Main - Message
// ============================================================================

import React, { ReactNode } from 'react';

import Markdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import {
  AlertProps,
  Avatar,
  AvatarProps,
  ButtonProps,
  ContentVariants,
  FormProps,
  Label,
  LabelGroupProps,
  Timestamp,
  Truncate
} from '@patternfly/react-core';
import MessageLoading from './MessageLoading';
import CodeBlockMessage from './CodeBlockMessage/CodeBlockMessage';
import TextMessage from './TextMessage/TextMessage';
import FileDetailsLabel from '../FileDetailsLabel/FileDetailsLabel';
import ResponseActions, { ActionProps } from '../ResponseActions/ResponseActions';
import SourcesCard, { SourcesCardProps } from '../SourcesCard';
import ListItemMessage from './ListMessage/ListItemMessage';
import UnorderedListMessage from './ListMessage/UnorderedListMessage';
import OrderedListMessage from './ListMessage/OrderedListMessage';
import QuickStartTile from './QuickStarts/QuickStartTile';
import { QuickStart, QuickstartAction } from './QuickStarts/types';
import QuickResponse from './QuickResponse/QuickResponse';
import UserFeedback, { UserFeedbackProps } from './UserFeedback/UserFeedback';
import UserFeedbackComplete, { UserFeedbackCompleteProps } from './UserFeedback/UserFeedbackComplete';
import TableMessage from './TableMessage/TableMessage';
import TrMessage from './TableMessage/TrMessage';
import TdMessage from './TableMessage/TdMessage';
import TbodyMessage from './TableMessage/TbodyMessage';
import TheadMessage from './TableMessage/TheadMessage';
import ThMessage from './TableMessage/ThMessage';
import { TableProps } from '@patternfly/react-table';
import ImageMessage from './ImageMessage/ImageMessage';
import rehypeUnwrapImages from 'rehype-unwrap-images';
import rehypeExternalLinks from 'rehype-external-links';
import rehypeSanitize from 'rehype-sanitize';
import { PluggableList } from 'react-markdown/lib';
import LinkMessage from './LinkMessage/LinkMessage';
import ErrorMessage from './ErrorMessage/ErrorMessage';
import MessageInput from './MessageInput';

export interface MessageAttachment {
  /** Name of file attached to the message */
  name: string;
  /** Unique identifier of file attached to the message */
  id?: string | number;
  /** Callback for when attachment label is clicked */
  onClick?: (event: React.MouseEvent, name: string, id?: string | number) => void;
  /** Callback for when attachment label is closed */
  onClose?: (event: React.MouseEvent, name: string, id?: string | number) => void;
  /** Whether file is loading */
  isLoading?: boolean;
  /** Aria label for attachment close button */
  closeButtonAriaLabel?: string;
  /** Custom test id for the language in the attachment component */
  languageTestId?: string;
  /** Custom test id for the loading spinner in the attachment component */
  spinnerTestId?: string;
}

export interface MessageExtraContent {
  /** Content to display before the main content */
  beforeMainContent?: ReactNode;

  /** Content to display after the main content */
  afterMainContent?: ReactNode;

  /** Content to display at the end */
  endContent?: ReactNode;
}

export interface MessageProps extends Omit<React.HTMLProps<HTMLDivElement>, 'role'> {
  /** Unique id for message */
  id?: string;
  /** Role of the user sending the message */
  role: 'user' | 'bot';
  /** Message content */
  content?: string;
  /** Extra Message content */
  extraContent?: MessageExtraContent;
  /** Name of the user */
  name?: string;
  /** Avatar src for the user */
  avatar: string;
  /** Timestamp for the message */
  timestamp?: string;
  /** Set this to true if message is being loaded */
  isLoading?: boolean;
  /** Array of attachments attached to a message */
  attachments?: MessageAttachment[];
  /** Props for message actions, such as feedback (positive or negative), copy button, share, and listen */
  actions?: {
    [key: string]: ActionProps;
  };
  /** Sources for message */
  sources?: SourcesCardProps;
  /** Label for the English word "AI," used to tag messages with role "bot" */
  botWord?: string;
  /** Label for the English "Loading message," displayed to screenreaders when loading a message */
  loadingWord?: string;
  codeBlockProps?: {
    'aria-label'?: string;
    className?: string;
  };
  /** Props for quick responses */
  quickResponses?: QuickResponse[];
  /** Props for quick responses container */
  quickResponseContainerProps?: Omit<LabelGroupProps, 'ref'>;
  /** Props for user feedback card */
  userFeedbackForm?: Omit<UserFeedbackProps, 'ref'>;
  /** Props for user feedback response */
  userFeedbackComplete?: Omit<UserFeedbackCompleteProps, 'ref'>;
  /** Whether avatar is round */
  hasRoundAvatar?: boolean;
  /** Any additional props applied to the avatar, for additional customization  */
  avatarProps?: Omit<AvatarProps, 'alt'>;
  /** Props for QuickStart card */
  quickStarts?: {
    quickStart: QuickStart;
    onSelectQuickStart: (id?: string) => void;
    minuteWord?: string;
    minuteWordPlural?: string;
    prerequisiteWord?: string;
    prerequisiteWordPlural?: string;
    quickStartButtonAriaLabel?: string;
    className?: string;
    onClick?: () => void;
    action?: QuickstartAction;
  };
  /** Turns the container into a live region so that changes to content within the Message, such as appending a feedback card, are reliably announced to assistive technology. */
  isLiveRegion?: boolean;
  /** Ref applied to message  */
  innerRef?: React.Ref<HTMLDivElement>;
  /** Props for table message. It is important to include a detailed aria-label that describes the purpose of the table. */
  tableProps?: Required<Pick<TableProps, 'aria-label'>> & TableProps;
  /** Additional rehype plugins passed from the consumer */
  additionalRehypePlugins?: PluggableList;
  /** Whether to open links in message in new tab. */
  openLinkInNewTab?: boolean;
  /** Optional inline error message that can be displayed in the message */
  error?: AlertProps;
  /** Props for links */
  linkProps?: ButtonProps;
  /** Whether message is in edit mode */
  isEditable?: boolean;
  /** Placeholder for edit input */
  editPlaceholder?: string;
  /** Label for the English word "Update" used in edit mode. */
  updateWord?: string;
  /** Label for the English word "Cancel" used in edit mode. */
  cancelWord?: string;
  /** Callback function for when edit mode update button is clicked */
  onEditUpdate?: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;
  /** Callback functionf or when edit cancel update button is clicked */
  onEditCancel?: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;
  /** Props for edit form */
  editFormProps?: FormProps;
  /** Sets message to compact styling. */
  isCompact?: boolean;
}

export const MessageBase: React.FunctionComponent<MessageProps> = ({
  role,
  content,
  extraContent,
  name,
  avatar,
  timestamp,
  isLoading,
  actions,
  sources,
  botWord = 'AI',
  loadingWord = 'Loading message',
  codeBlockProps,
  quickResponses,
  quickResponseContainerProps = { numLabels: 5 },
  attachments,
  hasRoundAvatar = true,
  avatarProps,
  quickStarts,
  userFeedbackForm,
  userFeedbackComplete,
  isLiveRegion = true,
  innerRef,
  tableProps,
  openLinkInNewTab = true,
  additionalRehypePlugins = [],
  linkProps,
  error,
  isEditable,
  editPlaceholder = 'Edit prompt message...',
  updateWord = 'Update',
  cancelWord = 'Cancel',
  onEditUpdate,
  onEditCancel,
  editFormProps,
  isCompact,
  ...props
}: MessageProps) => {
  const [messageText, setMessageText] = React.useState(content);

  React.useEffect(() => {
    setMessageText(content);
  }, [content]);

  const { beforeMainContent, afterMainContent, endContent } = extraContent || {};
  let rehypePlugins: PluggableList = [rehypeUnwrapImages];
  if (openLinkInNewTab) {
    rehypePlugins = rehypePlugins.concat([[rehypeExternalLinks, { target: '_blank' }, rehypeSanitize]]);
  }
  if (additionalRehypePlugins) {
    rehypePlugins.push(...additionalRehypePlugins);
  }
  let avatarClassName;
  if (avatarProps && 'className' in avatarProps) {
    const { className, ...rest } = avatarProps;
    avatarClassName = className;
    avatarProps = { ...rest };
  }
  // Keep timestamps consistent between Timestamp component and aria-label
  const date = new Date();
  const dateString = timestamp ?? `${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;

  const renderMessage = () => {
    if (isLoading) {
      return <MessageLoading loadingWord={loadingWord} />;
    }
    if (isEditable) {
      return (
        <>
          {beforeMainContent && <>{beforeMainContent}</>}
          <MessageInput
            content={content}
            editPlaceholder={editPlaceholder}
            updateWord={updateWord}
            cancelWord={cancelWord}
            onEditUpdate={(event, text) => {
              onEditUpdate && onEditUpdate(event);
              setMessageText(text);
            }}
            onEditCancel={onEditCancel}
            {...editFormProps}
          />
        </>
      );
    }
    return (
      <>
        {beforeMainContent && <>{beforeMainContent}</>}
        {error ? (
          <ErrorMessage {...error} />
        ) : (
          <Markdown
            components={{
              p: (props) => <TextMessage component={ContentVariants.p} {...props} />,
              code: ({ children, ...props }) => (
                <CodeBlockMessage {...props} {...codeBlockProps}>
                  {children}
                </CodeBlockMessage>
              ),
              h1: (props) => <TextMessage component={ContentVariants.h1} {...props} />,
              h2: (props) => <TextMessage component={ContentVariants.h2} {...props} />,
              h3: (props) => <TextMessage component={ContentVariants.h3} {...props} />,
              h4: (props) => <TextMessage component={ContentVariants.h4} {...props} />,
              h5: (props) => <TextMessage component={ContentVariants.h5} {...props} />,
              h6: (props) => <TextMessage component={ContentVariants.h6} {...props} />,
              blockquote: (props) => <TextMessage component={ContentVariants.blockquote} {...props} />,
              ul: (props) => <UnorderedListMessage {...props} />,
              ol: (props) => <OrderedListMessage {...props} />,
              li: (props) => <ListItemMessage {...props} />,
              table: (props) => <TableMessage {...props} {...tableProps} />,
              tbody: (props) => <TbodyMessage {...props} />,
              thead: (props) => <TheadMessage {...props} />,
              tr: (props) => <TrMessage {...props} />,
              td: (props) => {
                // Conflicts with Td type
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const { width, ...rest } = props;
                return <TdMessage {...rest} />;
              },
              th: (props) => <ThMessage {...props} />,
              img: (props) => <ImageMessage {...props} />,
              a: (props) => (
                <LinkMessage href={props.href} rel={props.rel} target={props.target} {...linkProps}>
                  {props.children}
                </LinkMessage>
              )
            }}
            remarkPlugins={[remarkGfm]}
            rehypePlugins={rehypePlugins}
          >
            {messageText}
          </Markdown>
        )}
      </>
    );
  };

  return (
    <section
      aria-label={`Message from ${role} - ${dateString}`}
      className={`pf-chatbot__message pf-chatbot__message--${role}`}
      aria-live={isLiveRegion ? 'polite' : undefined}
      aria-atomic={isLiveRegion ? false : undefined}
      ref={innerRef}
      {...props}
    >
      {/* We are using an empty alt tag intentionally in order to reduce noise on screen readers */}
      <Avatar
        className={`pf-chatbot__message-avatar ${hasRoundAvatar ? 'pf-chatbot__message-avatar--round' : ''} ${avatarClassName ? avatarClassName : ''}`}
        src={avatar}
        alt=""
        {...avatarProps}
      />
      <div className="pf-chatbot__message-contents">
        <div className="pf-chatbot__message-meta">
          {name && (
            <span className="pf-chatbot__message-name">
              <Truncate content={name} />
            </span>
          )}
          {role === 'bot' && (
            <Label variant="outline" isCompact>
              {botWord}
            </Label>
          )}
          <Timestamp date={date}>{timestamp}</Timestamp>
        </div>
        <div className="pf-chatbot__message-response">
          <div className="pf-chatbot__message-and-actions">
            {renderMessage()}
            {afterMainContent && <>{afterMainContent}</>}
            {!isLoading && sources && <SourcesCard {...sources} isCompact={isCompact} />}
            {quickStarts && quickStarts.quickStart && (
              <QuickStartTile
                quickStart={quickStarts.quickStart}
                onSelectQuickStart={quickStarts.onSelectQuickStart}
                minuteWord={quickStarts.minuteWord}
                minuteWordPlural={quickStarts.minuteWordPlural}
                prerequisiteWord={quickStarts.prerequisiteWord}
                prerequisiteWordPlural={quickStarts.prerequisiteWordPlural}
                quickStartButtonAriaLabel={quickStarts.quickStartButtonAriaLabel}
                isCompact={isCompact}
              />
            )}
            {!isLoading && actions && <ResponseActions actions={actions} />}
            {userFeedbackForm && <UserFeedback {...userFeedbackForm} timestamp={dateString} isCompact={isCompact} />}
            {userFeedbackComplete && (
              <UserFeedbackComplete {...userFeedbackComplete} timestamp={dateString} isCompact={isCompact} />
            )}
            {!isLoading && quickResponses && (
              <QuickResponse
                quickResponses={quickResponses}
                quickResponseContainerProps={quickResponseContainerProps}
                isCompact={isCompact}
              />
            )}
          </div>
          {attachments && (
            <div className="pf-chatbot__message-attachments-container">
              {attachments.map((attachment) => (
                <div key={attachment.id ?? attachment.name} className="pf-chatbot__message-attachment">
                  <FileDetailsLabel
                    fileName={attachment.name}
                    fileId={attachment.id}
                    onClose={attachment.onClose}
                    onClick={attachment.onClick}
                    isLoading={attachment.isLoading}
                    closeButtonAriaLabel={attachment.closeButtonAriaLabel}
                    languageTestId={attachment.languageTestId}
                    spinnerTestId={attachment.spinnerTestId}
                  />
                </div>
              ))}
            </div>
          )}
          {!isLoading && endContent && <>{endContent}</>}
        </div>
      </div>
    </section>
  );
};

const Message = React.forwardRef((props: MessageProps, ref: React.Ref<HTMLDivElement>) => (
  <MessageBase innerRef={ref} {...props} />
));

export default Message;



================================================
FILE: packages/module/src/Message/MessageInput.tsx
================================================
// ============================================================================
// Chatbot Main - Message Input
// ============================================================================

import React from 'react';
import { ActionGroup, Button, Form, FormProps, TextArea } from '@patternfly/react-core';

export interface MessageInputProps extends FormProps {
  /** Placeholder for edit input */
  editPlaceholder?: string;
  /** Label for the English word "Update" used in edit mode. */
  updateWord?: string;
  /** Label for the English word "Cancel" used in edit mode. */
  cancelWord?: string;
  /** Callback function for when edit mode update button is clicked */
  onEditUpdate?: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>, value: string) => void;
  /** Callback functionf or when edit cancel update button is clicked */
  onEditCancel?: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;
  /** Message text */
  content?: string;
}

const MessageInput: React.FunctionComponent<MessageInputProps> = ({
  editPlaceholder = 'Edit prompt message...',
  updateWord = 'Update',
  cancelWord = 'Cancel',
  onEditUpdate,
  onEditCancel,
  content,
  ...props
}: MessageInputProps) => {
  const [messageText, setMessageText] = React.useState(content ?? '');

  const onChange = (event: React.FormEvent<HTMLTextAreaElement>, value: string) => {
    setMessageText(value);
  };

  return (
    <Form {...props}>
      <TextArea
        placeholder={editPlaceholder}
        value={messageText}
        onChange={onChange}
        aria-label={editPlaceholder}
        autoResize
      />
      <ActionGroup className="pf-chatbot__message-edit-buttons">
        <Button variant="primary" onClick={(event) => onEditUpdate && onEditUpdate(event, messageText)}>
          {updateWord}
        </Button>
        <Button variant="secondary" onClick={onEditCancel}>
          {cancelWord}
        </Button>
      </ActionGroup>
    </Form>
  );
};

export default MessageInput;



================================================
FILE: packages/module/src/Message/MessageLoading.scss
================================================
// ============================================================================
// Chatbot Main - Message - Loading
// ============================================================================
.pf-chatbot__message-loading {
  width: 36px;
  padding: var(--pf-t--global--spacer--sm);
  background-color: var(--pf-t--global--background--color--tertiary--default);
  border-radius: var(--pf-t--global--border--radius--small);

  &-dots {
    position: relative;
    display: flex;
    width: 4px;
    height: 4px;
    margin-left: var(--pf-t--global--spacer--sm);
    border-radius: var(--pf-t--global--border--radius--pill);
    animation: dot-flashing var(--pf-t--global--motion--duration--2xl) infinite linear alternate;
    animation-delay: calc(var(--pf-t--global--motion--duration--2xl) * 0.33333333333);
  }
  &-dots::before,
  &-dots::after {
    content: '';
    display: flex;
    position: absolute;
    inset-block-start: 0;
  }
  &-dots::before {
    inset-inline-start: calc(var(--pf-t--global--spacer--sm) * -1);
    width: 4px;
    height: 4px;
    border-radius: var(--pf-t--global--border--radius--pill);
    animation: dot-flashing var(--pf-t--global--motion--duration--2xl) infinite alternate;
    animation-delay: var(--pf-t--global--motion--delay--none);
  }
  &-dots::after {
    inset-inline-start: var(--pf-t--global--spacer--sm);
    width: 4px;
    height: 4px;
    border-radius: var(--pf-t--global--border--radius--pill);
    animation: dot-flashing var(--pf-t--global--motion--duration--2xl) infinite alternate;
    animation-delay: calc(var(--pf-t--global--motion--duration--2xl) * 0.66666666666);
  }

  @keyframes dot-flashing {
    0% {
      background-color: var(--pf-t--global--background--color--inverse--default);
    }
    50%,
    100% {
      background-color: rgba(41, 41, 41, 0.25);
    }
  }
}



================================================
FILE: packages/module/src/Message/MessageLoading.tsx
================================================
// ============================================================================
// Chatbot Main - Message - Processing
// ============================================================================

import React from 'react';

const MessageLoading = ({ loadingWord }) => (
  <div className="pf-chatbot__message-loading">
    <span className="pf-chatbot__message-loading-dots">
      <span className="pf-v6-screen-reader">{loadingWord}</span>
    </span>
  </div>
);

export default MessageLoading;



================================================
FILE: packages/module/src/Message/CodeBlockMessage/CodeBlockMessage.scss
================================================
// ============================================================================
// Chatbot Main - Message - Content - Code Block
// ============================================================================
.pf-chatbot__message-code-block {
  width: 100%;
  background-color: var(--pf-t--color--gray--80); // same in light + dark theme
  color: var(--pf-t--color--white); // same in light + dark theme
  border-radius: var(--pf-t--global--border--radius--small);

  // Code block
  .pf-v6-c-code-block {
    --pf-t--global--border--color--default: var(--pf-t--global--border--color--default);
    background-color: inherit;
  }

  // Code block header
  .pf-v6-c-code-block__header {
    --pf-v6-c-code-block__header--PaddingBlockStart: var(--pf-t--global--spacer--sm);
    --pf-v6-c-code-block__header--PaddingBlockEnd: var(--pf-t--global--spacer--sm);
    --pf-v6-c-code-block__header--PaddingInlineStart: var(--pf-t--global--spacer--md);
    --pf-v6-c-code-block__header--PaddingInlineEnd: var(--pf-t--global--spacer--md);
    color: var(--pf-t--color--white); // same in light + dark theme

    .pf-v6-c-code-block__actions {
      width: 100%;
    }

    .pf-chatbot__message-code-block-language {
      text-transform: uppercase;
      font-family: var(--pf-t--global--font--family--body);
    }

    .pf-v6-c-code-block__actions-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      font-size: var(--pf-t--global--font--size--sm);
      font-weight: var(--pf-t--global--font--weight--body--bold);
    }

    .pf-chatbot__button--copy.pf-v6-c-button {
      color: var(--pf-t--color--white); // same in light + dark theme

      &:hover,
      &:focus {
        color: var(--pf-t--color--white); // same in light + dark theme
      }
    }
  }

  // Code block content
  .pf-v6-c-code-block__content {
    --pf-v6-c-code-block__content--PaddingBlockStart: var(--pf-t--global--spacer--md);
    --pf-v6-c-code-block__content--PaddingBlockEnd: var(--pf-t--global--spacer--md);
    --pf-v6-c-code-block__content--PaddingInlineStart: var(--pf-t--global--spacer--md);
    --pf-v6-c-code-block__content--PaddingInlineEnd: var(--pf-t--global--spacer--md);
    font-size: var(--pf-t--global--font--size--sm);

    pre,
    pre:hover {
      overflow: hidden;
      white-space: pre-wrap;
      word-break: break-all;
    }
    pre code {
      display: block;
      overflow: hidden;
      font-size: var(--pf-t--global--font--size--sm);
    }

    .pf-v6-c-code-block__code > div {
      padding: 0 !important;
      overflow: hidden !important;
    }
  }
}

.pf-chatbot__message-inline-code {
  background-color: var(--pf-t--global--background--color--tertiary--default);
  font-size: var(--pf-t--global--font--size--body--default);
}



================================================
FILE: packages/module/src/Message/CodeBlockMessage/CodeBlockMessage.tsx
================================================
// ============================================================================
// Chatbot Main - Message - Content - Code Block
// ============================================================================
import React from 'react';
import SyntaxHighlighter from 'react-syntax-highlighter';
import { obsidian } from 'react-syntax-highlighter/dist/esm/styles/hljs';
// Import PatternFly components
import { CodeBlock, CodeBlockAction, CodeBlockCode, Button, Tooltip } from '@patternfly/react-core';

import { CheckIcon } from '@patternfly/react-icons/dist/esm/icons/check-icon';
import { CopyIcon } from '@patternfly/react-icons/dist/esm/icons/copy-icon';
import { ExtraProps } from 'react-markdown';

const CodeBlockMessage = ({
  children,
  className,
  'aria-label': ariaLabel,
  ...props
}: JSX.IntrinsicElements['code'] & ExtraProps) => {
  const [copied, setCopied] = React.useState(false);

  const buttonRef = React.useRef();
  const tooltipID = React.useId();

  const language = /language-(\w+)/.exec(className || '')?.[1];

  // Handle clicking copy button
  const handleCopy = React.useCallback((event, text) => {
    navigator.clipboard.writeText(text.toString());
    setCopied(true);
  }, []);

  // Reset copied state
  React.useEffect(() => {
    if (copied) {
      const timer = setTimeout(() => {
        setCopied(false);
      }, 3000);

      return () => clearTimeout(timer);
    }
  });

  if (!String(children).includes('\n')) {
    return (
      <code {...props} className="pf-chatbot__message-inline-code">
        {children}
      </code>
    );
  }

  // Setup code block header
  const actions = (
    <>
      <CodeBlockAction>
        {language && <div className="pf-chatbot__message-code-block-language">{language}</div>}
        <Button
          ref={buttonRef}
          aria-label={ariaLabel ?? 'Copy code'}
          variant="plain"
          className="pf-chatbot__button--copy"
          onClick={(event) => handleCopy(event, children)}
        >
          {copied ? <CheckIcon /> : <CopyIcon />}
        </Button>
        <Tooltip id={tooltipID} content="Copy" position="top" triggerRef={buttonRef} />
      </CodeBlockAction>
    </>
  );

  return (
    <div className="pf-chatbot__message-code-block">
      <CodeBlock actions={actions}>
        <CodeBlockCode>
          {language ? (
            <SyntaxHighlighter {...props} language={language} style={obsidian} PreTag="div" CodeTag="div" wrapLongLines>
              {String(children).replace(/\n$/, '')}
            </SyntaxHighlighter>
          ) : (
            <>{children}</>
          )}
        </CodeBlockCode>
      </CodeBlock>
    </div>
  );
};

export default CodeBlockMessage;



================================================
FILE: packages/module/src/Message/ErrorMessage/ErrorMessage.tsx
================================================
// ============================================================================
// Chatbot Main - Message - Content - Error
// ============================================================================

import React from 'react';
import { Alert, AlertProps } from '@patternfly/react-core';

const ErrorMessage = ({ title, actionLinks, children, ...props }: AlertProps) => (
  <Alert isInline variant="danger" title={title} actionLinks={actionLinks} {...props}>
    {children}
  </Alert>
);

export default ErrorMessage;



================================================
FILE: packages/module/src/Message/ImageMessage/ImageMessage.scss
================================================
.pf-chatbot__message-image {
  border-radius: var(--pf-t--global--border--radius--small);
  max-width: 37.5rem; // 600px
  max-height: 25rem; // 400px
  min-height: 6.25rem; // 100px
  // with rehypePlugins={[rehypeUnwrapImages]}, image is not wrapped in p if it is by itself
  // however, if in a paragraph tag as part of other content, it should be a block element
  display: block;
}



================================================
FILE: packages/module/src/Message/ImageMessage/ImageMessage.tsx
================================================
// ============================================================================
// Chatbot Main - Message - Content - Image
// ============================================================================

import React from 'react';
import { ExtraProps } from 'react-markdown';

const ImageMessage = ({ children, ...props }: JSX.IntrinsicElements['img'] & ExtraProps) => (
  <img className="pf-chatbot__message-image" {...props}>
    {children}
  </img>
);

export default ImageMessage;



================================================
FILE: packages/module/src/Message/LinkMessage/LinkMessage.tsx
================================================
// ============================================================================
// Chatbot Main - Message - Content - Link
// ============================================================================

import React from 'react';
import { Button, ButtonProps } from '@patternfly/react-core';
import { ExternalLinkSquareAltIcon } from '@patternfly/react-icons';

const LinkMessage = ({ children, target, href, ...props }: ButtonProps) => {
  if (target === '_blank') {
    return (
      <Button
        component="a"
        variant="link"
        href={href}
        icon={<ExternalLinkSquareAltIcon />}
        iconPosition="end"
        isInline
        target={target}
        {...props}
      >
        {children}
      </Button>
    );
  }

  return (
    <Button isInline component="a" href={href} variant="link" {...props}>
      {children}
    </Button>
  );
};

export default LinkMessage;



================================================
FILE: packages/module/src/Message/ListMessage/ListItemMessage.tsx
================================================
// ============================================================================
// Chatbot Main - Message - Content - List
// ============================================================================

import React from 'react';
import { ExtraProps } from 'react-markdown';
import { ListItem } from '@patternfly/react-core';

const ListItemMessage = ({ children }: JSX.IntrinsicElements['li'] & ExtraProps) => <ListItem>{children}</ListItem>;

export default ListItemMessage;



================================================
FILE: packages/module/src/Message/ListMessage/ListMessage.scss
================================================
// ============================================================================
// Chatbot Main - Message - Content - Text
// ============================================================================

.pf-chatbot__message-ordered-list,
.pf-chatbot__message-unordered-list {
  width: fit-content;
  padding: var(--pf-t--global--spacer--sm) 0 var(--pf-t--global--spacer--sm) 0;
  border-radius: var(--pf-t--global--border--radius--small);

  .pf-v6-c-list,
  ul,
  li {
    font-size: var(--pf-t--global--font--size--md);
  }
}

.pf-chatbot__message--user {
  .pf-chatbot__message-ordered-list,
  .pf-chatbot__message-unordered-list {
    background-color: var(--pf-t--global--color--brand--default);
    color: var(--pf-t--global--text--color--on-brand--default);
    padding: var(--pf-t--global--spacer--sm);
  }
}



================================================
FILE: packages/module/src/Message/ListMessage/OrderedListMessage.tsx
================================================
// ============================================================================
// Chatbot Main - Message - Content - List
// ============================================================================

import React from 'react';
import { ExtraProps } from 'react-markdown';
import { List, ListComponent, OrderType } from '@patternfly/react-core';

const OrderedListMessage = ({ children, start }: JSX.IntrinsicElements['ol'] & ExtraProps) => (
  <div className="pf-chatbot__message-ordered-list">
    <List component={ListComponent.ol} type={OrderType.number} start={start}>
      {children}
    </List>
  </div>
);

export default OrderedListMessage;



================================================
FILE: packages/module/src/Message/ListMessage/UnorderedListMessage.tsx
================================================
// ============================================================================
// Chatbot Main - Message - Content - List
// ============================================================================

import React from 'react';
import { ExtraProps } from 'react-markdown';
import { List } from '@patternfly/react-core';

const UnorderedListMessage = ({ children }: JSX.IntrinsicElements['ul'] & ExtraProps) => (
  <div className="pf-chatbot__message-unordered-list">
    <List>{children}</List>
  </div>
);

export default UnorderedListMessage;



================================================
FILE: packages/module/src/Message/QuickResponse/QuickResponse.scss
================================================
.pf-chatbot__message-quick-response {
  .pf-v6-c-label {
    --pf-v6-c-label--FontSize: var(--pf-t--global--font--size--md);

    @media screen and (min-width: 401px) and (max-width: 600px) {
      --pf-v6-c-label__text--MaxWidth: 20ch;
    }

    @media screen and (max-width: 400px) {
      --pf-v6-c-label__text--MaxWidth: 15ch;
    }
  }

  .pf-chatbot__message-quick-response--selected {
    .pf-v6-c-label__content:is(:hover, :focus) {
      --pf-v6-c-label--m-clickable--hover--BorderWidth: 0;
      --pf-v6-c-label--BackgroundColor: var(--pf-v6-c-label--m-blue--BackgroundColor);
    }
  }

  .pf-chatbot__message-quick-response--selected:hover,
  .pf-chatbot__message-quick-response--selected:focus {
    --pf-v6-c-label--m-clickable--hover--BorderWidth: 0;
    --pf-v6-c-label--BackgroundColor: var(--pf-v6-c-label--m-blue--BackgroundColor);
  }

  // active state right before selection
  .pf-v6-c-label.pf-m-blue.pf-m-clickable .pf-v6-c-label__content:is(:active) {
    --pf-v6-c-label--BackgroundColor: var(--pf-v6-c-label--m-blue--BackgroundColor);
    --pf-v6-c-label--m-clickable--hover--BackgroundColor: var(--pf-v6-c-label--m-blue--BackgroundColor);
    --pf-v6-c-label--m-clickable--hover--BorderWidth: 0;
  }
}



================================================
FILE: packages/module/src/Message/QuickResponse/QuickResponse.tsx
================================================
import React from 'react';
import { Label, LabelGroup, LabelGroupProps, LabelProps } from '@patternfly/react-core';
import { CheckIcon } from '@patternfly/react-icons';

export interface QuickResponse extends Omit<LabelProps, 'children'> {
  content: string;
  id: string;
  onClick?: () => void;
}

export interface QuickResponseProps {
  /** Props for quick responses */
  quickResponses: QuickResponse[];
  /** Props for quick responses container */
  quickResponseContainerProps?: Omit<LabelGroupProps, 'ref'>;
  /** Callback when a response is clicked; used in feedback cards */
  onSelect?: (id: string) => void;
  /** Sets the quick responses to compact styling */
  isCompact?: boolean;
}

export const QuickResponse: React.FunctionComponent<QuickResponseProps> = ({
  quickResponses,
  quickResponseContainerProps = { numLabels: 5 },
  onSelect,
  isCompact
}: QuickResponseProps) => {
  const [selectedQuickResponse, setSelectedQuickResponse] = React.useState<string>();

  const handleQuickResponseClick = (id: string, onClick?: () => void) => {
    setSelectedQuickResponse(id);
    onClick && onClick();
    onSelect && onSelect(id);
  };
  return (
    <LabelGroup
      className={`pf-chatbot__message-quick-response ${quickResponseContainerProps?.className ? quickResponseContainerProps?.className : ''}`}
      {...quickResponseContainerProps}
    >
      {quickResponses.map(({ id, onClick, content, className, ...props }: QuickResponse) => (
        <Label
          variant={id === selectedQuickResponse ? undefined : 'outline'}
          icon={id === selectedQuickResponse ? <CheckIcon /> : undefined}
          color="blue"
          key={id}
          onClick={() => handleQuickResponseClick(id, onClick)}
          className={`${id === selectedQuickResponse ? 'pf-chatbot__message-quick-response--selected' : ''} ${className ? className : ''}`}
          isCompact={isCompact}
          {...props}
        >
          {content}
        </Label>
      ))}
    </LabelGroup>
  );
};

export default QuickResponse;



================================================
FILE: packages/module/src/Message/QuickStarts/FallbackImg.tsx
================================================
import * as React from 'react';

interface FallbackImgProps {
  /** Image source */
  src: string;
  /** Alt text for image */
  alt?: string;
  /** ClassName applied to image */
  className?: string;
  /** Fallback */
  fallback?: React.ReactNode;
}

const FallbackImg: React.FC<FallbackImgProps> = ({ src, alt, className, fallback }) => {
  const [isSrcValid, setIsSrcValid] = React.useState<boolean>(true);

  if (src && isSrcValid) {
    return <img className={className} src={src} alt={alt} onError={() => setIsSrcValid(false)} />;
  }

  return <>{fallback}</>;
};

export default FallbackImg;



================================================
FILE: packages/module/src/Message/QuickStarts/monitor-sampleapp-quickstart-with-image.ts
================================================
export const monitorSampleAppQuickStartWithImage = {
  apiVersion: 'console.openshift.io/v1',
  kind: 'QuickStarts',
  metadata: {
    name: 'monitor-sampleapp'
  },
  spec: {
    icon: 'test.png', // this is only difference
    version: 4.7,
    displayName: 'Monitoring your sample application',
    durationMinutes: 10,
    description: `Now that you’ve created a sample application and added health checks, let’s monitor your application.`,
    prerequisites: [`You completed the "Getting started with a sample" quick start.`],
    introduction: `### This quick start shows you how to monitor your sample application.
You should have previously created the **sample-app** application and **nodejs-sample** deployment via the **Get started with a sample** quick start. If you haven't, you may be able to follow these tasks with any existing deployment.`,
    tasks: [
      {
        title: `Viewing the monitoring details of your sample application`,
        description: `### To view the details of your sample application:
1. Go to the project your sample application was created in.
2. In the **</> Developer** perspective, go to **Topology** view.
3. Click on the **nodejs-sample** deployment to view its details.
4. Click on the **Monitoring** tab in the side panel.
You can see context sensitive metrics and alerts in the **Monitoring** tab.`,
        review: {
          instructions: `#### To verify you can view the monitoring information:
1. Do you see a **Metrics** accordion in the side panel?
2. Do you see a **View monitoring dashboard** link in the **Metrics** accordion?
3. Do you see three charts in the **Metrics** accordion: **CPU Usage**, **Memory Usage** and **Receive Bandwidth**?`,
          failedTaskHelp: `This task isn’t verified yet. Try the task again.`
        },
        summary: {
          success: `You have learned how you can monitor your sample app!`,
          failed: `Try the steps again.`
        }
      },
      {
        title: `Viewing your project monitoring dashboard`,
        description: `### To view the project monitoring dashboard in the context of **nodejs-sample**:
1. Click on the **View monitoring dashboard** link in the side panel.
2. You can change the **Time Range** and **Refresh Interval** of the dashboard.
3. You can change the context of the dashboard as well by clicking on the drop-down list. Select a specific workload or **All Workloads** to view the dashboard in the context of the entire project.`,
        review: {
          instructions: `#### To verify that you are able to view the monitoring dashboard:
Do you see metrics charts in the dashboard?`,
          failedTaskHelp: `This task isn’t verified yet. Try the task again.`
        },
        summary: {
          success: `You have learned how to view the dashboard in the context of your sample app!`,
          failed: `Try the steps again.`
        }
      },
      {
        title: `Viewing custom metrics`,
        description: `### To view custom metrics:
1. Click on the **Metrics** tab of the **Monitoring** page.
2. Click the **Select Query** drop-down list to see the available queries.
3. Click on **Filesystem Usage** from the list to run the query.`,
        review: {
          instructions: `#### Verify you can see the chart associated with the query:
Do you see a chart displayed with filesystem usage for your project?  Note: select **Custom Query** from the dropdown to create and run a custom query utilizing PromQL.
`,
          failedTaskHelp: `This task isn’t verified yet. Try the task again.`
        },
        summary: {
          success: `You have learned how to run a query!`,
          failed: `Try the steps again.`
        }
      }
    ],
    conclusion: `You have learned how to access workload monitoring and metrics!`,

    nextQuickStart: [``]
  }
};



================================================
FILE: packages/module/src/Message/QuickStarts/monitor-sampleapp-quickstart.ts
================================================
export const monitorSampleAppQuickStart = {
  apiVersion: 'console.openshift.io/v1',
  kind: 'QuickStarts',
  metadata: {
    name: 'monitor-sampleapp'
  },
  spec: {
    version: 4.7,
    displayName: 'Monitoring your sample application',
    durationMinutes: 10,
    icon: '',
    description: `Now that you’ve created a sample application and added health checks, let’s monitor your application.`,
    prerequisites: [`You completed the "Getting started with a sample" quick start.`],
    introduction: `### This quick start shows you how to monitor your sample application.
You should have previously created the **sample-app** application and **nodejs-sample** deployment via the **Get started with a sample** quick start. If you haven't, you may be able to follow these tasks with any existing deployment.`,
    tasks: [
      {
        title: `Viewing the monitoring details of your sample application`,
        description: `### To view the details of your sample application:
1. Go to the project your sample application was created in.
2. In the **</> Developer** perspective, go to **Topology** view.
3. Click on the **nodejs-sample** deployment to view its details.
4. Click on the **Monitoring** tab in the side panel.
You can see context sensitive metrics and alerts in the **Monitoring** tab.`,
        review: {
          instructions: `#### To verify you can view the monitoring information:
1. Do you see a **Metrics** accordion in the side panel?
2. Do you see a **View monitoring dashboard** link in the **Metrics** accordion?
3. Do you see three charts in the **Metrics** accordion: **CPU Usage**, **Memory Usage** and **Receive Bandwidth**?`,
          failedTaskHelp: `This task isn’t verified yet. Try the task again.`
        },
        summary: {
          success: `You have learned how you can monitor your sample app!`,
          failed: `Try the steps again.`
        }
      },
      {
        title: `Viewing your project monitoring dashboard`,
        description: `### To view the project monitoring dashboard in the context of **nodejs-sample**:
1. Click on the **View monitoring dashboard** link in the side panel.
2. You can change the **Time Range** and **Refresh Interval** of the dashboard.
3. You can change the context of the dashboard as well by clicking on the drop-down list. Select a specific workload or **All Workloads** to view the dashboard in the context of the entire project.`,
        review: {
          instructions: `#### To verify that you are able to view the monitoring dashboard:
Do you see metrics charts in the dashboard?`,
          failedTaskHelp: `This task isn’t verified yet. Try the task again.`
        },
        summary: {
          success: `You have learned how to view the dashboard in the context of your sample app!`,
          failed: `Try the steps again.`
        }
      },
      {
        title: `Viewing custom metrics`,
        description: `### To view custom metrics:
1. Click on the **Metrics** tab of the **Monitoring** page.
2. Click the **Select Query** drop-down list to see the available queries.
3. Click on **Filesystem Usage** from the list to run the query.`,
        review: {
          instructions: `#### Verify you can see the chart associated with the query:
Do you see a chart displayed with filesystem usage for your project?  Note: select **Custom Query** from the dropdown to create and run a custom query utilizing PromQL.
`,
          failedTaskHelp: `This task isn’t verified yet. Try the task again.`
        },
        summary: {
          success: `You have learned how to run a query!`,
          failed: `Try the steps again.`
        }
      }
    ],
    conclusion: `You have learned how to access workload monitoring and metrics!`,

    nextQuickStart: [``]
  }
};



================================================
FILE: packages/module/src/Message/QuickStarts/QuickStartTile.scss
================================================
.pf-chatbot__quickstarts-tile {
  max-width: 650px;
  width: 100%;

  @media screen and (max-width: 700px) {
    max-width: 100%;
    min-width: initial;
  }
  // some icons provided to catalog tiles might have no defined height/width. Without this style, in those cases
  // the icons would have a height and width of 0.
  .pf-v6-c-card__header-main {
    .pf-v6-c-icon__content {
      display: contents;
    }
  }
}

.pf-v6-theme-dark {
  .pf-chatbot__quickstarts-tile {
    .pfext-catalog-item-icon__img {
      filter: brightness(1.5) invert(1) hue-rotate(180deg) saturate(4);
    }
  }
}



================================================
FILE: packages/module/src/Message/QuickStarts/QuickStartTile.tsx
================================================
import * as React from 'react';
import RocketIcon from '@patternfly/react-icons/dist/js/icons/rocket-icon';
import OutlinedBookmarkIcon from '@patternfly/react-icons/dist/js/icons/outlined-bookmark-icon';
import {
  Card,
  CardBody,
  CardHeader,
  CardFooter,
  CardTitle,
  Icon,
  Button,
  Flex,
  Stack,
  Label,
  pluralize
} from '@patternfly/react-core';
import OutlinedClockIcon from '@patternfly/react-icons/dist/js/icons/outlined-clock-icon';
import QuickStartTileHeader from './QuickStartTileHeader';
import QuickStartTileDescription from './QuickStartTileDescription';
import { QuickStart, QuickstartAction } from './types';
import FallbackImg from './FallbackImg';

export const camelize = (str: string) =>
  str.replace(/(?:^\w|[A-Z]|\b\w|\s+)/g, function (match, index) {
    if (+match === 0) {
      return '';
    } // or if (/\s+/.test(match)) for white spaces
    return index === 0 ? match.toLowerCase() : match.toUpperCase();
  });

export interface QuickStartTileProps {
  /** ClassName applied to the card */
  className?: string;
  /** The quickstart object triggered by this tile */
  quickStart: QuickStart;
  /** Event handler attached to the tile */
  onClick?: () => void;
  /** Action config for button rendered next to title */
  action?: QuickstartAction;
  /** Callback that returns active quick start value when clicked */
  onSelectQuickStart: (id?: string) => void;
  /** Label for the English word "minute". */
  minuteWord?: string;
  /** Label for the English word "minutes". */
  minuteWordPlural?: string;
  /** Label for the English word "Prerequisite" */
  prerequisiteWord?: string;
  /** Label for the English word "Prerequisites" */
  prerequisiteWordPlural?: string;
  /** Aria-label for the quick start description button */
  quickStartButtonAriaLabel?: string;
  /** Sets the tile to compact styling */
  isCompact?: boolean;
}

const QuickStartTile: React.FC<QuickStartTileProps> = ({
  className,
  quickStart,
  onClick,
  onSelectQuickStart,
  minuteWord = 'minute',
  minuteWordPlural = 'minutes',
  prerequisiteWord,
  prerequisiteWordPlural,
  quickStartButtonAriaLabel,
  action,
  isCompact
}) => {
  const {
    metadata: { name: id },
    spec: { icon, displayName, description, durationMinutes, prerequisites, link, type }
  } = quickStart;

  let quickStartIcon: React.ReactNode;
  if (typeof icon === 'object') {
    quickStartIcon = <Icon size="2xl">{icon}</Icon>;
  } else {
    quickStartIcon = (
      <Icon size="2xl">
        <FallbackImg src={icon as string} alt="" className="pfext-catalog-item-icon__img" fallback={<RocketIcon />} />
      </Icon>
    );
  }

  const onSelect = () => {
    if (!link) {
      onSelectQuickStart(id);
    } else {
      window.open(link.href, '_blank', 'noopener,noreferrer');
    }
    onClick && onClick();
  };

  const ActionIcon = action?.icon || OutlinedBookmarkIcon;
  const additionalAction = action ? (
    <Button
      aria-label={action['aria-label']}
      icon={<ActionIcon />}
      variant="plain"
      onClick={action.onClick}
      {...action.buttonProps}
    />
  ) : undefined;

  return (
    <Card
      className={`pf-chatbot__quickstarts-tile ${className ? className : ''}`}
      id={`${id}-chatbot-qs-tile`}
      style={{ height: '100%' }}
      data-testid={`chatbot-qs-card-${camelize(displayName)}`}
      isCompact={isCompact}
    >
      <CardHeader
        {...(action && {
          actions: { actions: additionalAction }
        })}
      >
        {quickStartIcon}
      </CardHeader>
      <CardTitle>
        <QuickStartTileHeader name={displayName} onSelect={onSelect} quickStartId={id} />
      </CardTitle>
      <CardBody>
        <Stack hasGutter>
          <Flex spaceItems={{ default: 'spaceItemsSm' }}>
            {type && <Label color={type.color}>{type.text}</Label>}
            {durationMinutes && (
              <Label variant="outline" data-test="duration" icon={<OutlinedClockIcon />}>
                {pluralize(durationMinutes, minuteWord, minuteWordPlural)}
              </Label>
            )}
          </Flex>
          <QuickStartTileDescription
            description={description}
            prerequisites={prerequisites}
            prerequisiteWord={prerequisiteWord}
            prerequisiteWordPlural={prerequisiteWordPlural}
            quickStartButtonAriaLabel={quickStartButtonAriaLabel}
          />
        </Stack>
      </CardBody>
      <CardFooter>
        <Button variant="link" isInline onClick={onSelect}>
          <span className="pf-v6-c-button__text">Start</span>
        </Button>
      </CardFooter>
    </Card>
  );
};

export default QuickStartTile;



================================================
FILE: packages/module/src/Message/QuickStarts/QuickStartTileDescription.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import userEvent from '@testing-library/user-event';
import { monitorSampleAppQuickStart } from './monitor-sampleapp-quickstart';
import QuickStartTileDescription, { pluralizeWord } from './QuickStartTileDescription';

describe('pluralizeWord function', () => {
  it('should render no plural correctly', () => {
    expect(pluralizeWord(2, 'pizza')).toBe('pizzas');
  });
});

describe('QuickStart tile description', () => {
  it('should render no prereqs correctly', () => {
    render(<QuickStartTileDescription description={monitorSampleAppQuickStart.spec.description} />);
    expect(screen.queryByRole('heading')).toBeFalsy();
  });
  it('should render singular prereq correctly', () => {
    render(
      <QuickStartTileDescription
        description={monitorSampleAppQuickStart.spec.description}
        prerequisites={[`You completed the "Getting started with a sample" quick start.`]}
      />
    );
    expect(screen.getByRole('heading', { name: /1 Prerequisite/i })).toBeTruthy();
    expect(screen.getByRole('button', { name: /Show prerequisite/i })).toBeTruthy();
  });
  it('should render plural prereq correctly', () => {
    render(
      <QuickStartTileDescription
        description={monitorSampleAppQuickStart.spec.description}
        prerequisites={[
          `You completed the "Getting started with a sample" quick start.`,
          `You completed the app quick start`
        ]}
      />
    );
    expect(screen.getByRole('heading', { name: /2 Prerequisites/i })).toBeTruthy();
    expect(screen.getByRole('button', { name: /Show prerequisites/i })).toBeTruthy();
  });
  it('should be able to click prereqs link', async () => {
    render(
      <QuickStartTileDescription
        description={monitorSampleAppQuickStart.spec.description}
        prerequisites={[`You completed the "Getting started with a sample" quick start.`]}
      />
    );
    const button = screen.getByRole('button', { name: /Show prerequisites/i });
    expect(screen.queryByRole('dialog', { name: /Prerequisite/i })).toBeFalsy();
    await userEvent.click(button);

    expect(screen.getByRole('dialog', { name: /Prerequisite/i })).toBeTruthy();
    expect(screen.getByRole('button', { name: /Close/i })).toBeTruthy();
    expect(screen.getByText(/You completed the "Getting started with a sample" quick start./i)).toBeTruthy();
  });
});



================================================
FILE: packages/module/src/Message/QuickStarts/QuickStartTileDescription.tsx
================================================
import * as React from 'react';
import { Button, Flex, pluralize, Popover } from '@patternfly/react-core';
import InfoCircleIcon from '@patternfly/react-icons/dist/js/icons/info-circle-icon';

interface QuickStartTileDescriptionProps {
  /** QuickStart description */
  description: string;
  /** QuickStart prerequisites */
  prerequisites?: string[];
  /** Label for the English word "Prerequisite" */
  prerequisiteWord?: string;
  /** Label for the English word "Prerequisites" */
  prerequisiteWordPlural?: string;
  /** Aria-label for the quick start button */
  quickStartButtonAriaLabel?: string;
}

/** This function is a helper for pluralizing strings stolen from React.
 *
 * @param {number} i The quantity of the string you want to pluralize
 * @param {string} singular The singular version of the string
 * @param {string} plural The change to the string that should occur if the quantity is not equal to 1.
 *                 Defaults to adding an 's'.
 */
export function pluralizeWord(i: number, singular: string, plural?: string) {
  if (!plural) {
    plural = `${singular}s`;
  }
  return `${i === 1 ? singular : plural}`;
}

const QuickStartTileDescription: React.FC<QuickStartTileDescriptionProps> = ({
  description,
  prerequisites,
  prerequisiteWord = 'Prerequisite',
  prerequisiteWordPlural = 'Prerequisites',
  quickStartButtonAriaLabel = 'Show prerequisites'
}) => {
  const prereqs = prerequisites?.filter((p) => p);
  const buttonRef = React.useRef<HTMLButtonElement>(null);
  const pluralizedPrereq = pluralizeWord(prereqs?.length || 0, prerequisiteWord, prerequisiteWordPlural);
  return (
    <>
      {description}
      {prereqs && prereqs.length > 0 && (
        <Flex spaceItems={{ default: 'spaceItemsSm' }}>
          <h5>{pluralize(prereqs.length, prerequisiteWord, prerequisiteWordPlural)}</h5>
          <Button
            variant="link"
            isInline
            data-testid="qs-card-prereqs"
            ref={buttonRef}
            onClick={(e) => {
              e.preventDefault();
              e.stopPropagation();
            }}
            aria-label={quickStartButtonAriaLabel}
          >
            <InfoCircleIcon />
          </Button>
          <Popover
            aria-label={pluralizedPrereq}
            headerContent={pluralizedPrereq}
            triggerRef={buttonRef}
            bodyContent={
              <div>
                <ul aria-label={pluralizedPrereq}>
                  {prereqs.map((prerequisite, index) => (
                    // eslint-disable-next-line react/no-array-index-key
                    <li key={index}>{prerequisite}</li>
                  ))}
                </ul>
              </div>
            }
          />
        </Flex>
      )}
    </>
  );
};
export default QuickStartTileDescription;



================================================
FILE: packages/module/src/Message/QuickStarts/QuickStartTileHeader.tsx
================================================
import * as React from 'react';
import { Button, Flex } from '@patternfly/react-core';

interface QuickStartTileHeaderProps {
  /** Name for the header */
  name: string;
  /** Id for the QuickStart */
  quickStartId?: string;
  /** Callback for when the name of the QuickStart is clicked */
  onSelect: (e: React.FormEvent<HTMLInputElement> | React.MouseEvent<Element, MouseEvent>) => void;
}

const QuickStartTileHeader: React.FC<QuickStartTileHeaderProps> = ({ name, quickStartId, onSelect }) => (
  <Flex flexWrap={{ default: 'nowrap' }}>
    <Button data-test="title" id={quickStartId} variant="link" isInline onClick={onSelect}>
      {name}
    </Button>
  </Flex>
);

export default QuickStartTileHeader;



================================================
FILE: packages/module/src/Message/QuickStarts/types.ts
================================================
import { ButtonProps } from '@patternfly/react-core';

// These types are all from the QuickStart extension.
// We want to ensure parity, so be careful when adjusting these.
export interface AccessReviewResourceAttributes {
  group?: string;
  resource?: string;
  subresource?: string;
  verb?: K8sVerb;
  name?: string;
  namespace?: string;
}

export type K8sVerb = 'create' | 'get' | 'list' | 'update' | 'patch' | 'delete' | 'deletecollection' | 'watch';

export interface QuickStart {
  apiVersion?: string;
  kind?: string;
  metadata: ObjectMetadata;
  spec: QuickStartSpec;
}

export interface ObjectMetadata {
  name: string;
  annotations?: { [key: string]: string };
  clusterName?: string;
  creationTimestamp?: string;
  deletionGracePeriodSeconds?: number;
  deletionTimestamp?: string;
  finalizers?: string[];
  generateName?: string;
  generation?: number;
  labels?: { [key: string]: string };
  managedFields?: any[];
  namespace?: string;
  ownerReferences?: OwnerReference[];
  resourceVersion?: string;
  uid?: string;
  // language can be: en
  language?: string;
  // country can be: US
  country?: string;
  // locale is a combination of language and country, for example: en_US
  locale?: string;
  // anything else to custom define
  [key: string]: any;
}

export interface OwnerReference {
  name: string;
  kind: string;
  uid: string;
  apiVersion: string;
  controller?: boolean;
  blockOwnerDeletion?: boolean;
}

export interface QuickStartTask {
  title?: string;
  description?: string;
  review?: QuickStartTaskReview;
  summary?: QuickStartTaskSummary;
  proc?: string;
}

export interface QuickStartTaskReview {
  instructions?: string;
  failedTaskHelp?: string;
}

export interface QuickStartTaskSummary {
  success?: string;
  failed?: string;
}

export interface QuickstartAction {
  /** Screen reader aria label. */
  'aria-label': string;
  /** Icon to be rendered as a plain button, by default Bookmark outlined will be used. */
  icon?: React.ComponentType<unknown>;
  /** Callback with synthetic event parameter. */
  onClick?: (e: React.SyntheticEvent) => void;
  /** Additional button props to be rendered as extra props. */
  buttonProps?: ButtonProps;
}

export interface QuickStart {
  apiVersion?: string;
  kind?: string;
  metadata: ObjectMetadata;
  spec: QuickStartSpec;
}

export interface QuickStartSpec {
  version?: number;
  displayName: string;
  durationMinutes?: number;
  icon: React.ReactNode;
  description: string;
  prerequisites?: string[];
  introduction?: string;
  tasks?: QuickStartTask[];
  conclusion?: string;
  nextQuickStart?: string[];
  accessReviewResources?: AccessReviewResourceAttributes[];
  link?: QuickStartExternal;
  type?: QuickStartType;
}

export interface QuickStartTask {
  title?: string;
  description?: string;
  review?: QuickStartTaskReview;
  summary?: QuickStartTaskSummary;
  proc?: string;
}

export interface QuickStartTaskReview {
  instructions?: string;
  failedTaskHelp?: string;
}

export interface QuickStartTaskSummary {
  success?: string;
  failed?: string;
}

export type AllQuickStartStates = Record<string, QuickStartState>;

export type QuickStartState = Record<string, string | number | QuickStartStatus>;

export enum QuickStartStatus {
  COMPLETE = 'Complete',
  IN_PROGRESS = 'In Progress',
  NOT_STARTED = 'Not started'
}

export enum QuickStartTaskStatus {
  INIT = 'Initial',
  VISITED = 'Visited',
  REVIEW = 'Review',
  SUCCESS = 'Success',
  FAILED = 'Failed'
}

export interface QuickStartExternal {
  href: string;
  text?: string;
}

export interface QuickStartType {
  text: string;
  color?: 'green' | 'purple' | 'grey' | 'blue' | 'orange' | 'red' | 'teal' | 'orangered' | 'yellow';
}



================================================
FILE: packages/module/src/Message/TableMessage/TableMessage.scss
================================================
.pf-chatbot__message-table {
  border-radius: var(--pf-t--global--border--radius--small);
  --pf-v6-c-table--BackgroundColor: var(--pf-t--global--background--color--tertiary--default) !important;
  --pf-v6-c-table--BorderColor: var(--pf-t--global--border--color--default) !important;
  padding: 0 var(--pf-t--global--spacer--lg) 0 var(--pf-t--global--spacer--lg);

  &.pf-m-grid.pf-v6-c-table tbody:where(.pf-v6-c-table__tbody):first-of-type {
    border-block-start: 0;
  }

  tbody {
    border-radius: var(--pf-t--global--border--radius--small);
  }

  tr {
    --pf-v6-c-table__tr--responsive--PaddingInlineEnd: 0;
    --pf-v6-c-table__tr--responsive--PaddingInlineStart: 0;
  }

  .pf-v6-c-table__tr:last-of-type {
    border-block-end: 0;
  }
}



================================================
FILE: packages/module/src/Message/TableMessage/TableMessage.tsx
================================================
// ============================================================================
// Chatbot Main - Message - Content - Table
// ============================================================================

import React from 'react';
import { ExtraProps } from 'react-markdown';
import { Table, TableProps } from '@patternfly/react-table';

interface Properties {
  line: number;
  column: number;
  offset: number;
}
export interface TableNode {
  children?: TableNode[];
  value?: string;
  position: { start: Properties; end: Properties };
  tagName: string;
  type: string;
}

const TableMessage = ({ children, ...props }: TableProps & ExtraProps) => {
  const { className, ...rest } = props;

  // This allows us to parse the nested data we get back from the 3rd party Markdown parser
  // Open to feedback here if there is a better way to do this
  // This looks for ths and spits them all out so we can filter them later, looking for text values
  const findHeaders = (array?: TableNode[]) => {
    const headers: TableNode[] = [];
    if (!array) {
      return headers;
    }
    const traverse = (items: TableNode[]) => {
      for (const item of items) {
        if (item.tagName === 'th') {
          headers.push(item);
        }
        if (item.children) {
          traverse(item.children);
        }
      }
    };

    traverse(array);
    return headers;
  };

  const headers = findHeaders(rest.node?.children as TableNode[] | undefined);
  const headerTextValues = headers.map((header) => header?.children?.filter((c) => c?.type === 'text')[0]?.value);

  // We are sending these header text values down to child tds by passing them through children, since mobile view for tables expects a dataLabel prop
  // The data structure does not otherwise know this information at that level
  // This is somewhat opinionated and may break if 3rd party library changes
  // See Tr and Tbody for other usage
  const modifyChildren = (children) =>
    React.Children.map(children, (child) => {
      if (child && headerTextValues?.length > 0) {
        return React.cloneElement(child, { extraHeaders: headerTextValues });
      }
      return child;
    });

  if (!props['aria-label']) {
    // eslint-disable-next-line no-console
    console.warn(
      'For accessibility reasons an aria-label should be specified for the Table via the <Message /> tableProps prop'
    );
  }

  return (
    // gridBreakPoint is so we show mobile-styled-PF table
    <Table
      aria-label={props['aria-label']}
      gridBreakPoint="grid"
      className={`pf-chatbot__message-table ${className ? className : ''}`}
      {...rest}
    >
      {modifyChildren(children)}
    </Table>
  );
};

export default TableMessage;



================================================
FILE: packages/module/src/Message/TableMessage/TbodyMessage.tsx
================================================
// ============================================================================
// Chatbot Main - Message - Content - Table
// ============================================================================

import React from 'react';
import { ExtraProps } from 'react-markdown';
import { Tbody, TbodyProps } from '@patternfly/react-table';

const TbodyProps = ({ children, ...props }: TbodyProps & ExtraProps & { extraHeaders?: string[] }) => {
  // passthrough so we can place dataLabel on tds
  const modifyChildren = (children) => {
    if (children && props.extraHeaders) {
      return React.Children.map(children, (child) => React.cloneElement(child, { extraHeaders: props.extraHeaders }));
    }
    return children;
  };

  return <Tbody {...props}>{modifyChildren(children)}</Tbody>;
};
export default TbodyProps;



================================================
FILE: packages/module/src/Message/TableMessage/TdMessage.tsx
================================================
// ============================================================================
// Chatbot Main - Message - Content - Table
// ============================================================================

import React from 'react';
import { ExtraProps } from 'react-markdown';
import { Td, TdProps } from '@patternfly/react-table';

const TdMessage = ({ children, ...props }: TdProps & ExtraProps) => <Td {...props}>{children}</Td>;

export default TdMessage;



================================================
FILE: packages/module/src/Message/TableMessage/TheadMessage.tsx
================================================
// ============================================================================
// Chatbot Main - Message - Content - Table
// ============================================================================

import React from 'react';
import { ExtraProps } from 'react-markdown';
import { Thead, TheadProps } from '@patternfly/react-table';

const TheadMessage = ({ children, ...props }: TheadProps & ExtraProps) => <Thead {...props}>{children}</Thead>;

export default TheadMessage;



================================================
FILE: packages/module/src/Message/TableMessage/ThMessage.tsx
================================================
// ============================================================================
// Chatbot Main - Message - Content - Table
// ============================================================================

import React from 'react';
import { ExtraProps } from 'react-markdown';
import { Th, ThProps } from '@patternfly/react-table';

const ThMessage = ({ children, ...props }: ThProps & ExtraProps) => <Th {...props}>{children}</Th>;

export default ThMessage;



================================================
FILE: packages/module/src/Message/TableMessage/TrMessage.tsx
================================================
// ============================================================================
// Chatbot Main - Message - Content - Table
// ============================================================================

import React from 'react';
import { ExtraProps } from 'react-markdown';
import { Tr, TrProps } from '@patternfly/react-table';

const TrMessage = ({ children, ...props }: TrProps & ExtraProps & { extraHeaders?: string[] }) => {
  let tdIndex = 0;

  // passthrough so we can place dataLabel on tds
  // places column name on correct child
  const modifyChildren = (children) =>
    React.Children.map(children, (child) => {
      if (child.type.name === 'td' && props.extraHeaders) {
        const clonedChild = React.cloneElement(child, { dataLabel: props.extraHeaders[tdIndex] });
        tdIndex = tdIndex + 1;
        return clonedChild;
      }
      return child;
    });

  return <Tr {...props}>{modifyChildren(children)}</Tr>;
};

export default TrMessage;



================================================
FILE: packages/module/src/Message/TextMessage/TextMessage.scss
================================================
// ============================================================================
// Chatbot Main - Message - Content - Text
// ============================================================================

.pf-chatbot__message-and-actions {
  blockquote {
    .pf-chatbot__message-text {
      display: inline-block;
    }
  }
}

// make it full width when there's a table, so the table can grow as needed
.pf-chatbot__message-and-actions:has(.pf-chatbot__message-table) {
  width: 100%;
}

// Need to inline shorter text
.pf-chatbot__message-text {
  width: fit-content;
  padding: var(--pf-t--global--spacer--sm) 0 var(--pf-t--global--spacer--sm) 0;
  border-radius: var(--pf-t--global--border--radius--small);

  .pf-v6-c-button.pf-m-link {
    font-size: var(--pf-t--global--font--size--md);
  }

  .pf-v6-c-content,
  .pf-v6-c-content--small,
  .pf-v6-c-content--blockquote,
  p,
  a {
    --pf-v6-c-content--FontSize: var(--pf-t--global--font--size--md);
  }

  code {
    background-color: var(--pf-t--global--background--color--tertiary--default);
    font-size: var(--pf-t--global--font--size--body--default);
  }
}

.pf-chatbot__message--user {
  .pf-chatbot__message-text {
    background-color: var(--pf-t--global--color--brand--default);
    color: var(--pf-t--global--text--color--on-brand--default);
    --pf-v6-c-content--Color: var(--pf-t--global--text--color--on-brand--default);
    padding: var(--pf-t--global--spacer--sm);
    .pf-v6-c-button__icon {
      --pf-v6-c-button__icon--Color: var(--pf-t--global--text--color--on-brand--default);
    }

    .pf-v6-c-content,
    .pf-v6-c-content--small,
    .pf-v6-c-content--blockquote,
    p,
    a {
      color: var(--pf-t--global--text--color--on-brand--default);
    }
  }
}

// ============================================================================
// Information density styles
// ============================================================================
.pf-chatbot.pf-m-compact {
  // Need to inline shorter text
  .pf-chatbot__message-text {
    .pf-v6-c-button.pf-m-link {
      font-size: var(--pf-t--global--font--size--sm);
    }

    .pf-v6-c-content,
    .pf-v6-c-content--small,
    .pf-v6-c-content--blockquote,
    p,
    a {
      --pf-v6-c-content--FontSize: var(--pf-t--global--font--size--sm);
    }

    .pf-v6-c-content--blockquote {
      --pf-v6-c-content--blockquote--PaddingBlockStart: 0;
      --pf-v6-c-content--blockquote--PaddingBlockEnd: 0;
    }
  }
}



================================================
FILE: packages/module/src/Message/TextMessage/TextMessage.tsx
================================================
// ============================================================================
// Chatbot Main - Message - Content - Text
// ============================================================================

import React from 'react';
import { ExtraProps } from 'react-markdown';
import { Content, ContentProps } from '@patternfly/react-core';

const TextMessage = ({ component, children, ...props }: ContentProps & ExtraProps) => (
  <span className="pf-chatbot__message-text">
    <Content component={component} {...props}>
      {children}
    </Content>
  </span>
);

export default TextMessage;



================================================
FILE: packages/module/src/Message/UserFeedback/CloseButton.tsx
================================================
// ============================================================================
// Chatbot Main - Messages - Close Button
// ============================================================================
import React from 'react';

// Import PatternFly components
import { Button, ButtonProps } from '@patternfly/react-core';
import { CloseIcon } from '@patternfly/react-icons';

export interface CloseButtonProps extends ButtonProps {
  /** Callback function for when close button is clicked */
  onClose?: () => void;
  /** Aria-label for button */
  ariaLabel?: string;
}

const CloseButton: React.FunctionComponent<CloseButtonProps> = ({ onClose, ariaLabel }: CloseButtonProps) => (
  <Button variant="plain" onClick={onClose} icon={<CloseIcon />} aria-label={ariaLabel} />
);

export default CloseButton;



================================================
FILE: packages/module/src/Message/UserFeedback/UserFeedback.scss
================================================
// shared
.pf-chatbot__feedback-card {
  box-shadow: var(--pf-t--global--box-shadow--sm);
  --pf-v6-c-card--BorderWidth: 0;
  max-width: 27.5rem; // fixme address mobile vs desktop
}

// complete card
.pf-chatbot__feedback-complete-body {
  display: flex;
  flex-direction: column;
  gap: var(--pf-t--global--spacer--lg);
  align-items: center;
  text-align: center;
}
.pf-chatbot__feedback-complete-text {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  gap: var(--pf-t--global--spacer--sm);
  --pf-v6-c-card--first-child--PaddingBlockStart: 0;
  --pf-v6-c-card__title--not--last-child--PaddingBlockEnd: 0;
}
.pf-chatbot__feedback-complete-image {
  display: flex;
  align-items: center;
  justify-content: center;
}
.pf-chatbot__feedback-complete-title {
  font-family: var(--pf-t--global--font--family--heading);
  font-size: var(--pf-t--global--font--size--lg);
  font-weight: var(--pf-t--global--font--weight--body--bold);
  line-height: var(--pf-t--global--font--line-height--heading);
}

// feedback card
.pf-chatbot__feedback-card-title {
  font-family: var(--pf-t--global--font--family--heading);
  font-size: var(--pf-t--global--font--size--md);
  font-weight: var(--pf-t--global--font--weight--body--bold);
  line-height: var(--pf-t--global--font--line-height--heading);
}

.pf-chatbot__feedback-card-form {
  --pf-v6-c-form__group--m-action--MarginBlockStart: 0 !important;
}

.pf-chatbot__feedback-card-optional {
  font-weight: initial;
}

// Compact styles
.pf-v6-c-card.pf-m-compact.pf-chatbot__feedback-card {
  .pf-chatbot__feedback-card-form.pf-m-compact {
    --pf-v6-c-form--GridGap: var(--pf-t--global--spacer--md);
  }
}

.pf-v6-c-card.pf-m-compact.pf-chatbot__feedback-card.pf-chatbot__feedback-card-complete {
  div.pf-chatbot__feedback-complete-body {
    gap: var(--pf-t--global--spacer--sm);
  }

  .pf-chatbot__feedback-complete-image {
    width: 40px;
  }

  .pf-chatbot__feedback-card-complete-empty-header {
    .pf-v6-c-card__header:first-child {
      --pf-v6-c-card--first-child--PaddingBlockStart: var(--pf-t--global--spacer--sm);
    }
  }
}



================================================
FILE: packages/module/src/Message/UserFeedback/UserFeedback.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import userEvent from '@testing-library/user-event';
import UserFeedback from './UserFeedback';

const MOCK_RESPONSES = [
  { id: '1', content: 'Helpful information', onClick: () => alert('Clicked helpful information') },
  { id: '2', content: 'Easy to understand', onClick: () => alert('Clicked easy to understand') },
  { id: '3', content: 'Resolved my issue', onClick: () => alert('Clicked resolved my issue') }
];

describe('UserFeedback', () => {
  it('should render correctly', () => {
    render(<UserFeedback onClose={jest.fn} onSubmit={jest.fn} quickResponses={MOCK_RESPONSES} timestamp="12/12/12" />);
    expect(screen.getByRole('heading', { name: /Why did you choose this rating?/i })).toBeTruthy();
    expect(screen.getByRole('list', { name: 'Quick feedback for message received at 12/12/12' })).toBeTruthy();
    expect(screen.getByRole('button', { name: /Helpful information/i })).toBeTruthy();
    expect(screen.getByRole('button', { name: /Easy to understand/i })).toBeTruthy();
    expect(screen.getByRole('button', { name: /Resolved my issue/i })).toBeTruthy();
    expect(screen.getByRole('button', { name: /Submit/i })).toBeTruthy();
    expect(screen.getByRole('button', { name: 'Close feedback for message received at 12/12/12' })).toBeTruthy();
    expect(screen.queryByRole('textbox', { name: /Provide optional additional feedback/i })).toBeFalsy();
  });
  it('should render different title correctly', () => {
    render(
      <UserFeedback
        timestamp="12/12/12"
        onClose={jest.fn}
        onSubmit={jest.fn}
        quickResponses={MOCK_RESPONSES}
        title="Thanks! Why?"
      />
    );
    expect(screen.getByText('Thanks! Why?')).toBeTruthy();
  });
  it('should render different submit button text correctly', () => {
    render(
      <UserFeedback
        timestamp="12/12/12"
        onClose={jest.fn}
        onSubmit={jest.fn}
        quickResponses={MOCK_RESPONSES}
        submitWord="Give feedback"
      />
    );
    expect(screen.getByRole('button', { name: /Give feedback/i })).toBeTruthy();
  });
  it('should render text area correctly', () => {
    render(
      <UserFeedback
        timestamp="12/12/12"
        onClose={jest.fn}
        onSubmit={jest.fn}
        quickResponses={MOCK_RESPONSES}
        hasTextArea
      />
    );
    expect(screen.getByRole('textbox', { name: /Provide optional additional feedback/i })).toBeTruthy();
  });
  it('should call onTextAreaChange correctly', async () => {
    const spy = jest.fn();
    render(
      <UserFeedback
        timestamp="12/12/12"
        onClose={jest.fn}
        onSubmit={jest.fn}
        quickResponses={MOCK_RESPONSES}
        hasTextArea
        onTextAreaChange={spy}
      />
    );
    const textbox = screen.getByRole('textbox', { name: /Provide optional additional feedback/i });
    await userEvent.type(textbox, 'test');
    expect(spy).toHaveBeenCalledTimes(4);
  });
  it('should render different placeholder correctly', () => {
    render(
      <UserFeedback
        timestamp="12/12/12"
        onClose={jest.fn}
        onSubmit={jest.fn}
        quickResponses={MOCK_RESPONSES}
        hasTextArea
        textAreaPlaceholder="Provide any other information"
      />
    );
    expect(screen.getByRole('textbox', { name: /Provide optional additional feedback/i })).toHaveAttribute(
      'placeholder',
      'Provide any other information'
    );
  });
  it('should render different text area label correctly', () => {
    render(
      <UserFeedback
        timestamp="12/12/12"
        onClose={jest.fn}
        onSubmit={jest.fn}
        quickResponses={MOCK_RESPONSES}
        hasTextArea
        textAreaAriaLabel="Provide more details"
      />
    );
    expect(screen.getByRole('textbox', { name: /Provide more details/i })).toBeTruthy();
  });
  it('should handle onClose correctly when close button is clicked', async () => {
    const spy = jest.fn();
    render(<UserFeedback onSubmit={jest.fn} quickResponses={MOCK_RESPONSES} onClose={spy} timestamp="12/12/12" />);
    const closeButton = screen.getByRole('button', { name: 'Close feedback for message received at 12/12/12' });
    expect(closeButton).toBeTruthy();
    await userEvent.click(closeButton);
    expect(spy).toHaveBeenCalledTimes(1);
  });
  it('should be able to change close button aria label', () => {
    const spy = jest.fn();
    render(
      <UserFeedback
        timestamp="12/12/12"
        onSubmit={jest.fn}
        quickResponses={MOCK_RESPONSES}
        onClose={spy}
        closeButtonAriaLabel="Ima button"
      />
    );
    expect(screen.getByRole('button', { name: /Ima button/i })).toBeTruthy();
  });
  it('should handle className', async () => {
    render(
      <UserFeedback
        timestamp="12/12/12"
        onClose={jest.fn}
        onSubmit={jest.fn}
        quickResponses={MOCK_RESPONSES}
        className="test"
        data-testid="card"
      />
    );
    expect(screen.getByTestId('card')).toHaveClass('test');
  });
  it('should apply id', async () => {
    render(
      <UserFeedback
        timestamp="12/12/12"
        onClose={jest.fn}
        onSubmit={jest.fn}
        quickResponses={MOCK_RESPONSES}
        id="test"
        data-testid="card"
      />
    );
    expect(screen.getByTestId('card').parentElement).toHaveAttribute('id', 'test');
  });
  it('should handle submit correctly when nothing is selected', async () => {
    const spy = jest.fn();
    render(<UserFeedback timestamp="12/12/12" onClose={jest.fn} onSubmit={spy} quickResponses={MOCK_RESPONSES} />);
    await userEvent.click(screen.getByRole('button', { name: /Submit/i }));
    expect(spy).toHaveBeenCalledTimes(1);
    expect(spy).toHaveBeenCalledWith(undefined, '');
  });
  it('should handle submit correctly when item is selected', async () => {
    const spy = jest.fn();
    render(<UserFeedback timestamp="12/12/12" onClose={jest.fn} onSubmit={spy} quickResponses={MOCK_RESPONSES} />);
    await userEvent.click(screen.getByRole('button', { name: /Easy to understand/i }));
    await userEvent.click(screen.getByRole('button', { name: /Submit/i }));
    expect(spy).toHaveBeenCalledTimes(1);
    expect(spy).toHaveBeenCalledWith('2', '');
  });
  it('should handle submit correctly when there is just text input', async () => {
    const spy = jest.fn();
    render(
      <UserFeedback timestamp="12/12/12" onClose={jest.fn} onSubmit={spy} quickResponses={MOCK_RESPONSES} hasTextArea />
    );
    await userEvent.type(
      screen.getByRole('textbox', { name: /Provide optional additional feedback/i }),
      'What a great experience!'
    );
    await userEvent.click(screen.getByRole('button', { name: /Submit/i }));
    expect(spy).toHaveBeenCalledTimes(1);
    expect(spy).toHaveBeenCalledWith(undefined, 'What a great experience!');
  });
  it('should handle submit correctly when item is selected and there is text input', async () => {
    const spy = jest.fn();
    render(
      <UserFeedback timestamp="12/12/12" onClose={jest.fn} onSubmit={spy} quickResponses={MOCK_RESPONSES} hasTextArea />
    );
    await userEvent.click(screen.getByRole('button', { name: /Easy to understand/i }));
    await userEvent.type(
      screen.getByRole('textbox', { name: /Provide optional additional feedback/i }),
      'What a great experience!'
    );
    await userEvent.click(screen.getByRole('button', { name: /Submit/i }));
    expect(spy).toHaveBeenCalledTimes(1);
    expect(spy).toHaveBeenCalledWith('2', 'What a great experience!');
  });
  it('should default title heading level to h1', () => {
    render(<UserFeedback timestamp="12/12/12" onClose={jest.fn} onSubmit={jest.fn} quickResponses={MOCK_RESPONSES} />);
    expect(screen.getByRole('heading', { level: 1, name: /Why did you choose this rating?/i })).toBeTruthy();
  });
  it('should be able to change title heading level', () => {
    render(
      <UserFeedback
        timestamp="12/12/12"
        onClose={jest.fn}
        onSubmit={jest.fn}
        quickResponses={MOCK_RESPONSES}
        headingLevel="h6"
      />
    );
    expect(screen.getByRole('heading', { level: 6, name: /Why did you choose this rating?/i })).toBeTruthy();
  });
  it('should focus on load by default', () => {
    render(
      <UserFeedback
        timestamp="12/12/12"
        onClose={jest.fn}
        onSubmit={jest.fn}
        quickResponses={MOCK_RESPONSES}
        data-testid="card"
      />
    );
    expect(screen.getByTestId('card').parentElement).toHaveFocus();
  });
  it('should not focus on load if focusOnLoad = false', () => {
    render(
      <UserFeedback
        timestamp="12/12/12"
        onClose={jest.fn}
        onSubmit={jest.fn}
        quickResponses={MOCK_RESPONSES}
        data-testid="card"
        focusOnLoad={false}
      />
    );
    expect(screen.getByTestId('card').parentElement).not.toHaveFocus();
  });
  it('should handle isCompact', () => {
    render(
      <UserFeedback
        timestamp="12/12/12"
        onClose={jest.fn}
        onSubmit={jest.fn}
        quickResponses={MOCK_RESPONSES}
        data-testid="card"
        isCompact
      />
    );
    expect(screen.getByTestId('card')).toHaveClass('pf-m-compact');
  });
});



================================================
FILE: packages/module/src/Message/UserFeedback/UserFeedback.tsx
================================================
// ============================================================================
// Chatbot Main - Messages - Feedback Card
// ============================================================================
import React from 'react';

// Import PatternFly components
import {
  ActionGroup,
  Button,
  Card,
  CardBody,
  CardHeader,
  CardProps,
  Form,
  LabelGroupProps,
  OUIAProps,
  TextArea
} from '@patternfly/react-core';
import QuickResponse from '../QuickResponse/QuickResponse';
import CloseButton from './CloseButton';

export interface UserFeedbackProps extends Omit<CardProps, 'onSubmit'>, OUIAProps {
  /** Additional classes for the pagination navigation container. */
  className?: string;
  /** Quick responses a user can select */
  quickResponses?: QuickResponse[];
  /** Props for quick responses container */
  quickResponseContainerProps?: Omit<LabelGroupProps, 'ref'>;
  /** Whether form includes text area */
  hasTextArea?: boolean;
  /** Placeholder of text area */
  textAreaPlaceholder?: string;
  /** Aria label for text area */
  textAreaAriaLabel?: string;
  /** Callback function for when text area changes */
  onTextAreaChange?: (event: React.ChangeEvent<HTMLTextAreaElement>, value: string) => void;
  /** Callback function for when form is submitted */
  onSubmit: (selectedResponse?: string, additionalFeedback?: string) => void;
  /** Callback function for when close button is clicked */
  onClose: () => void;
  /** Aria label for close button */
  closeButtonAriaLabel?: string;
  /** Label for the English word "Submit." */
  submitWord?: string;
  /** @deprecated Cancel button has been deprecated. Use the close button instead. Label for the English word "Cancel." */
  cancelWord?: string;
  /** Uniquely identifies the card. */
  id?: string;
  /** The heading level to use, default is h1 */
  headingLevel?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';
  /** Whether to focus card on load */
  focusOnLoad?: boolean;
  /** Timestamp passed in by Message for more context in aria announcements */
  timestamp?: string;
}

const UserFeedback: React.FunctionComponent<UserFeedbackProps> = ({
  className,
  timestamp,
  title = 'Why did you choose this rating?',
  hasTextArea,
  textAreaAriaLabel = `Provide optional additional feedback for message received at ${timestamp}`,
  textAreaPlaceholder = 'Provide optional additional feedback',
  onTextAreaChange,
  submitWord = 'Submit',
  quickResponses,
  quickResponseContainerProps = { 'aria-label': `Quick feedback for message received at ${timestamp}` },
  onSubmit,
  onClose,
  closeButtonAriaLabel = `Close feedback for message received at ${timestamp}`,
  id,
  headingLevel: HeadingLevel = 'h1',
  focusOnLoad = true,
  isCompact,
  ...props
}: UserFeedbackProps) => {
  const [selectedResponse, setSelectedResponse] = React.useState<string>();
  const [value, setValue] = React.useState('');
  const divRef = React.useRef<HTMLDivElement>(null);

  React.useEffect(() => {
    if (focusOnLoad) {
      divRef.current?.focus();
    }
  }, []);

  return (
    /* card does not have ref forwarding; hence wrapper div */
    <div ref={divRef} id={id} tabIndex={0} aria-label={title}>
      <Card isCompact={isCompact} className={`pf-chatbot__feedback-card ${className ? className : ''}`} {...props}>
        <CardHeader
          actions={{
            actions: <CloseButton onClose={onClose} ariaLabel={closeButtonAriaLabel} />
          }}
        >
          <HeadingLevel className="pf-chatbot__feedback-card-title">{title}</HeadingLevel>
        </CardHeader>
        <CardBody>
          <Form className={`pf-chatbot__feedback-card-form ${isCompact ? 'pf-m-compact' : ''}`}>
            {quickResponses && (
              <QuickResponse
                quickResponses={quickResponses}
                quickResponseContainerProps={quickResponseContainerProps}
                onSelect={(id) => setSelectedResponse(id)}
                isCompact={isCompact}
              />
            )}
            {hasTextArea && (
              <TextArea
                value={value}
                onChange={(_event, value) => {
                  setValue(value);
                  onTextAreaChange && onTextAreaChange(_event, value);
                }}
                placeholder={textAreaPlaceholder}
                aria-label={textAreaAriaLabel}
                resizeOrientation="vertical"
              />
            )}
            <ActionGroup>
              <Button onClick={() => onSubmit(selectedResponse, value)}>{submitWord}</Button>
            </ActionGroup>
          </Form>
        </CardBody>
      </Card>
    </div>
  );
};

export default UserFeedback;



================================================
FILE: packages/module/src/Message/UserFeedback/UserFeedbackComplete.test.tsx
================================================
import React from 'react';
import { act, render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import userEvent from '@testing-library/user-event';
import UserFeedbackComplete from './UserFeedbackComplete';

describe('UserFeedbackComplete', () => {
  it('should render correctly', () => {
    render(<UserFeedbackComplete timestamp="12/12/12" />);
    expect(screen.getByText('Feedback submitted')).toBeTruthy();
    screen.getByText(/We've received your response. Thank you for sharing your feedback!/i);
    expect(screen.queryByRole('button', { name: /Close/i })).toBeFalsy();
  });
  it('should render different title correctly', () => {
    render(<UserFeedbackComplete timestamp="12/12/12" title="Thanks!" />);
    expect(screen.getByText('Thanks!')).toBeTruthy();
    screen.getByText(/We've received your response. Thank you for sharing your feedback!/i);
  });
  it('should render different string body correctly', () => {
    render(<UserFeedbackComplete timestamp="12/12/12" body="Thanks!" />);
    expect(screen.getByText('Feedback submitted')).toBeTruthy();
    expect(screen.getByText('Thanks!')).toBeTruthy();
  });
  it('should render different node body correctly', () => {
    render(<UserFeedbackComplete timestamp="12/12/12" body={<div>Thanks!</div>} />);
    expect(screen.getByText('Feedback submitted')).toBeTruthy();
    expect(screen.getByText('Thanks!')).toBeTruthy();
  });
  it('should handle onClose correctly', async () => {
    const spy = jest.fn();
    render(<UserFeedbackComplete timestamp="12/12/12" onClose={spy} />);
    const closeButton = screen.getByRole('button', { name: 'Close feedback for message received at 12/12/12' });
    expect(closeButton).toBeTruthy();
    await userEvent.click(closeButton);
    expect(spy).toHaveBeenCalledTimes(1);
  });
  it('should be able to change close button aria label', () => {
    const spy = jest.fn();
    render(<UserFeedbackComplete timestamp="12/12/12" onClose={spy} closeButtonAriaLabel="Ima button" />);
    expect(screen.getByRole('button', { name: /Ima button/i })).toBeTruthy();
  });
  it('should handle className', async () => {
    render(<UserFeedbackComplete timestamp="12/12/12" className="test" data-testid="card" />);
    expect(screen.getByTestId('card')).toHaveClass('test');
  });
  it('should apply id', async () => {
    render(<UserFeedbackComplete timestamp="12/12/12" id="test" data-testid="card" />);
    expect(screen.getByTestId('card').parentElement).toHaveAttribute('id', 'test');
  });
  it('renders with no timeout by default', () => {
    jest.useFakeTimers();
    render(<UserFeedbackComplete timestamp="12/12/12" />);
    act(() => {
      jest.advanceTimersByTime(8000);
    });
    expect(screen.getByText('Feedback submitted')).toBeVisible();
    jest.useRealTimers();
  });
  it('should handle timeout correctly after 8000ms when timeout = true', async () => {
    jest.useFakeTimers();
    render(<UserFeedbackComplete timestamp="12/12/12" timeout />);
    act(() => {
      jest.advanceTimersByTime(7999);
    });
    expect(screen.getByText('Feedback submitted')).toBeVisible();
    act(() => {
      jest.advanceTimersByTime(1);
    });
    expect(screen.queryByText('Feedback submitted')).not.toBeInTheDocument();
    jest.useRealTimers();
  });
  it('should handle timeout correctly when timeout = numeric value', async () => {
    jest.useFakeTimers();
    render(<UserFeedbackComplete timestamp="12/12/12" timeout={300} />);
    act(() => {
      jest.advanceTimersByTime(299);
    });
    expect(screen.getByText('Feedback submitted')).toBeVisible();
    act(() => {
      jest.advanceTimersByTime(1);
    });
    expect(screen.queryByText('Feedback submitted')).not.toBeInTheDocument();
    jest.useRealTimers();
  });
  it('does not get removed on timeout if the user is focused on the card', async () => {
    const user = userEvent.setup({
      advanceTimers: (delay) => jest.advanceTimersByTime(delay)
    });
    jest.useFakeTimers();
    render(<UserFeedbackComplete timestamp="12/12/12" timeout data-testid="card" />);
    expect(screen.getByText('Feedback submitted')).toBeTruthy();
    await user.click(screen.getByTestId('card'));
    act(() => {
      jest.advanceTimersByTime(8000);
    });
    expect(screen.getByText('Feedback submitted')).toBeTruthy();
    jest.useRealTimers();
  });
  it('does not remove the card on timeout if the user is hovered over it', async () => {
    const user = userEvent.setup({
      advanceTimers: (delay) => jest.advanceTimersByTime(delay)
    });
    jest.useFakeTimers();
    render(<UserFeedbackComplete timestamp="12/12/12" timeout data-testid="card" />);
    const card = screen.getByTestId('card');
    await user.hover(card);
    act(() => {
      jest.advanceTimersByTime(8000);
    });
    expect(card).toBeVisible();
    jest.useRealTimers();
  });
  it('removes the card after the user removes focus from the card and 3000ms have passed', async () => {
    const user = userEvent.setup({
      advanceTimers: (delay) => jest.advanceTimersByTime(delay)
    });
    jest.useFakeTimers();
    render(
      <div>
        <input />
        <UserFeedbackComplete timestamp="12/12/12" timeout data-testid="card" />
      </div>
    );
    const card = screen.getByTestId('card');
    await user.click(card);
    act(() => {
      jest.advanceTimersByTime(8000);
    });
    await user.click(screen.getByRole('textbox'));
    act(() => {
      jest.advanceTimersByTime(3000);
    });
    expect(screen.queryByText('Feedback submitted')).not.toBeInTheDocument();
    jest.useRealTimers();
  });

  it('removes the card after the user removes hover from the card and 3000ms have passed', async () => {
    const user = userEvent.setup({
      advanceTimers: (delay) => jest.advanceTimersByTime(delay)
    });
    jest.useFakeTimers();
    render(
      <div>
        <input />
        <UserFeedbackComplete timestamp="12/12/12" timeout data-testid="card" />
      </div>
    );
    const card = screen.getByTestId('card');
    await user.hover(card);
    act(() => {
      jest.advanceTimersByTime(8000);
    });
    await user.hover(screen.getByRole('textbox'));
    act(() => {
      jest.advanceTimersByTime(3000);
    });
    expect(screen.queryByText('Feedback submitted')).not.toBeInTheDocument();
    jest.useRealTimers();
  });

  it('removes the card after the user removes hover from the card and timeoutAnimation time has passed', async () => {
    const user = userEvent.setup({
      advanceTimers: (delay) => jest.advanceTimersByTime(delay)
    });
    jest.useFakeTimers();
    render(
      <div>
        <input />
        <UserFeedbackComplete timestamp="12/12/12" timeout data-testid="card" timeoutAnimation={1000} />
      </div>
    );
    const card = screen.getByTestId('card');
    await user.hover(card);
    act(() => {
      jest.advanceTimersByTime(8000);
    });
    await user.hover(screen.getByRole('textbox'));
    act(() => {
      jest.advanceTimersByTime(1000);
    });
    expect(screen.queryByText('Feedback submitted')).not.toBeInTheDocument();
    jest.useRealTimers();
  });
  it('does not call the onTimeout callback before the timeout period has expired', () => {
    const spy = jest.fn();
    jest.useFakeTimers();
    render(<UserFeedbackComplete timestamp="12/12/12" timeout data-testid="card" onTimeout={spy} />);
    act(() => {
      jest.advanceTimersByTime(7999);
    });
    expect(spy).not.toHaveBeenCalled();
    jest.useRealTimers();
  });
  it('calls the onTimeout callback after the timeout period has expired', () => {
    jest.useFakeTimers();
    const spy = jest.fn();
    render(<UserFeedbackComplete timestamp="12/12/12" timeout data-testid="card" onTimeout={spy} />);
    act(() => {
      jest.advanceTimersByTime(8000);
    });
    expect(spy).toHaveBeenCalledTimes(1);
    jest.useRealTimers();
  });

  it('renders without aria-live and aria-atomic attributes by default', () => {
    render(<UserFeedbackComplete timestamp="12/12/12" timeout data-testid="card" />);
    const card = screen.getByTestId('card').parentElement;
    expect(card).not.toHaveAttribute('aria-live');
    expect(card).not.toHaveAttribute('aria-atomic');
  });

  it('has an aria-live value of polite and aria-atomic value of false when isLiveRegion = true', () => {
    render(<UserFeedbackComplete timestamp="12/12/12" timeout data-testid="card" isLiveRegion />);
    const card = screen.getByTestId('card').parentElement;
    expect(card).toHaveAttribute('aria-live', 'polite');
    expect(card).toHaveAttribute('aria-atomic', 'false');
  });
  it('calls onMouseEnter appropriately', async () => {
    const spy = jest.fn();
    const user = userEvent.setup();
    render(
      <div>
        <input />
        <UserFeedbackComplete timestamp="12/12/12" data-testid="card" onMouseEnter={spy} />
      </div>
    );
    const card = screen.getByTestId('card');
    expect(spy).toHaveBeenCalledTimes(0);
    await user.hover(card);
    expect(spy).toHaveBeenCalledTimes(1);
  });
  it('calls onMouseLeave appropriately', async () => {
    const spy = jest.fn();
    const user = userEvent.setup();
    render(
      <div>
        <input />
        <UserFeedbackComplete timestamp="12/12/12" data-testid="card" onMouseLeave={spy} />
      </div>
    );
    const card = screen.getByTestId('card');
    expect(spy).toHaveBeenCalledTimes(0);
    await user.hover(card);
    await user.hover(screen.getByRole('textbox'));
    expect(spy).toHaveBeenCalledTimes(1);
  });
  it('should focus on load by default', () => {
    render(<UserFeedbackComplete timestamp="12/12/12" data-testid="card" />);
    expect(screen.getByTestId('card').parentElement).toHaveFocus();
  });
  it('should not focus on load if focusOnLoad = false', () => {
    render(<UserFeedbackComplete timestamp="12/12/12" data-testid="card" focusOnLoad={false} />);
    expect(screen.getByTestId('card').parentElement).not.toHaveFocus();
  });
  it('should handle isCompact', () => {
    render(<UserFeedbackComplete timestamp="12/12/12" data-testid="card" isCompact />);
    expect(screen.getByTestId('card')).toHaveClass('pf-m-compact');
  });
});



================================================
FILE: packages/module/src/Message/UserFeedback/UserFeedbackComplete.tsx
================================================
// ============================================================================
// Chatbot Main - Messages - Feedback Complete Card
// ============================================================================
import React from 'react';

// Import PatternFly components
import { Card, CardBody, CardHeader, CardProps, CardTitle, OUIAProps, useOUIAProps } from '@patternfly/react-core';
import CloseButton from './CloseButton';

export interface UserFeedbackCompleteProps extends Omit<CardProps, 'ref'>, OUIAProps {
  /** Additional classes for the pagination navigation container. */
  className?: string;
  /** Substitute for the English phrase "Thank you". */
  title?: string;
  /** Substitute for the English phrase "You have successfully sent your feedback! Thank you for responding." */
  body?: string | React.ReactNode;
  /** Callback function for when close button is clicked */
  onClose?: () => void;
  /** Aria label for close button */
  closeButtonAriaLabel?: string;
  /** Function to be executed on timeout. Relevant when the timeout prop is set. */
  onTimeout?: () => void;
  /** If set to true, the timeout is 8000 milliseconds. If a number is provided, card will
   * be dismissed after that amount of time in milliseconds.
   */
  timeout?: number | boolean;
  /** If the user hovers over the card and `timeout` expires, this is how long to wait
   * before finally dismissing the alert.
   */
  timeoutAnimation?: number;
  /** Callback for when mouse hovers over card */
  onMouseEnter?: (e: React.MouseEvent<HTMLDivElement>) => void;
  /** Callback for when mouse stops hovering over card */
  onMouseLeave?: (e: React.MouseEvent<HTMLDivElement>) => void;
  /** Value to overwrite the randomly generated data-ouia-component-id.*/
  ouiaId?: number | string;
  /** Set the value of data-ouia-safe. Only set to true when the component is in a static state, i.e. no animations are occurring. At all other times, this value must be false. */
  ouiaSafe?: boolean;
  /** Flag to indicate if the card is in a live region. */
  isLiveRegion?: boolean;
  /** Uniquely identifies the completion card. */
  id?: string;
  /** Whether to focus card on load */
  focusOnLoad?: boolean;
  /** Timestamp passed in by Message for more context in aria announcements */
  timestamp?: string;
}

const UserFeedbackComplete: React.FunctionComponent<UserFeedbackCompleteProps> = ({
  className,
  title = 'Feedback submitted',
  body = "We've received your response. Thank you for sharing your feedback!",
  timestamp,
  timeout = false,
  timeoutAnimation = 3000,
  onTimeout,
  onClose,
  closeButtonAriaLabel = `Close feedback for message received at ${timestamp}`,
  onMouseEnter,
  onMouseLeave,
  ouiaId,
  ouiaSafe,
  isLiveRegion,
  id,
  focusOnLoad = true,
  isCompact,
  ...props
}: UserFeedbackCompleteProps) => {
  const [timedOut, setTimedOut] = React.useState(false);
  const [timedOutAnimation, setTimedOutAnimation] = React.useState(true);
  const [isMouseOver, setIsMouseOver] = React.useState<boolean | undefined>();
  const [containsFocus, setContainsFocus] = React.useState<boolean | undefined>();
  const dismissed = timedOut && timedOutAnimation && !isMouseOver && !containsFocus;
  const divRef = React.useRef<HTMLDivElement>(null);
  const ouiaProps = useOUIAProps('User Feedback Complete', ouiaId, ouiaSafe);

  React.useEffect(() => {
    if (focusOnLoad) {
      divRef.current?.focus();
    }
  }, []);

  React.useEffect(() => {
    const calculatedTimeout = timeout === true ? 8000 : Number(timeout);
    if (calculatedTimeout > 0) {
      const timer = setTimeout(() => setTimedOut(true), calculatedTimeout);
      return () => clearTimeout(timer);
    }
  }, [timeout]);

  React.useEffect(() => {
    const onDocumentFocus = () => {
      if (divRef.current) {
        if (divRef.current.contains(document.activeElement)) {
          setContainsFocus(true);
          setTimedOutAnimation(false);
        } else if (containsFocus) {
          setContainsFocus(false);
        }
      }
    };
    document.addEventListener('focus', onDocumentFocus, true);
    return () => document.removeEventListener('focus', onDocumentFocus, true);
  }, [containsFocus]);

  React.useEffect(() => {
    if (containsFocus === false || isMouseOver === false) {
      const timer = setTimeout(() => setTimedOutAnimation(true), timeoutAnimation);
      return () => clearTimeout(timer);
    }
  }, [containsFocus, isMouseOver, timeoutAnimation]);

  React.useEffect(() => {
    dismissed && onTimeout && onTimeout();
  }, [dismissed, onTimeout]);

  if (dismissed) {
    return null;
  }

  const myOnMouseEnter = (ev: React.MouseEvent<HTMLDivElement>) => {
    setIsMouseOver(true);
    setTimedOutAnimation(false);
    onMouseEnter && onMouseEnter(ev);
  };

  const myOnMouseLeave = (ev: React.MouseEvent<HTMLDivElement>) => {
    setIsMouseOver(false);
    onMouseLeave && onMouseLeave(ev);
  };

  return (
    /* card does not have ref forwarding; hence wrapper div */
    <div
      ref={divRef}
      onMouseEnter={myOnMouseEnter}
      onMouseLeave={myOnMouseLeave}
      {...(isLiveRegion && {
        'aria-live': 'polite',
        'aria-atomic': 'false'
      })}
      id={id}
      tabIndex={0}
      aria-label={title}
      {...ouiaProps}
    >
      <Card
        isCompact={isCompact}
        className={`pf-chatbot__feedback-card pf-chatbot__feedback-card-complete${className ? ` ${className}` : ''}`}
        {...props}
      >
        <CardHeader
          className={
            onClose ? 'pf-chatbot__feedback-card-complete-header' : 'pf-chatbot__feedback-card-complete-empty-header'
          }
          actions={
            /* eslint-disable indent */
            onClose
              ? {
                  actions: <CloseButton onClose={onClose} ariaLabel={closeButtonAriaLabel} />
                }
              : undefined
            /* eslint-enable indent */
          }
        ></CardHeader>
        <div className="pf-chatbot__feedback-complete-body">
          <div className="pf-chatbot__feedback-complete-image">
            <svg width="60" height="64" viewBox="0 0 60 64" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path
                d="M53.0555 21.5975H6.94323C3.57013 21.5975 0.835693 24.3319 0.835693 27.705V57.8925C0.835693 61.2656 3.57013 64 6.94323 64H53.0555C56.4286 64 59.1631 61.2656 59.1631 57.8925V27.705C59.1631 24.3319 56.4286 21.5975 53.0555 21.5975Z"
                fill="#F8AE54"
              />
              <path
                d="M55.8973 19.8247C52.5894 15.7926 29.9992 0 29.9992 0C29.9992 0 7.40996 15.7926 4.10102 19.8247C0.79312 23.8568 0.835476 25.7184 0.835476 27.8899H59.1629C59.1629 25.7184 59.2052 23.8578 55.8973 19.8257V19.8247Z"
                fill="#FFCC17"
              />
              <g>
                <path d="M53.0567 8.48981H6.94336V61.8388H53.0567V8.48981Z" fill="#F2F2F2" />
              </g>
              <path d="M51.6589 7.49908H8.34204V60.8481H51.6589V7.49908Z" fill="white" />
              <path
                d="M0.835693 29.1296V57.8925C0.835693 59.2375 1.27165 60.4803 2.00823 61.4896L23.0303 43.5462L0.835693 29.1296Z"
                fill="#FFCC17"
              />
              <path
                d="M36.9695 43.5472L57.9905 61.4907C58.7271 60.4813 59.1631 59.2386 59.1631 57.8935V29.1306L36.9685 43.5472H36.9695Z"
                fill="#FFF4CC"
              />
              <path
                d="M0.835693 57.8925V57.8067L22.4146 42.7992L29.9994 37.5244L37.5842 42.7992L59.1641 57.8067V57.8925C59.1641 61.2665 56.4296 64 53.0566 64H6.94323C3.57024 64 0.835693 61.2665 0.835693 57.8925Z"
                fill="#FFE072"
              />
              <g>
                <path d="M22.1563 42.978L0.835693 57.8067V56.6993L22.1563 42.978Z" fill="#FEF07C" />
              </g>
              <g>
                <path d="M37.8425 42.978L59.1631 57.8067V56.6993L37.8425 42.978Z" fill="#FEF07C" />
              </g>
              <path
                d="M37.8037 32.2373C42.1136 27.9273 42.1136 20.9395 37.8037 16.6295C33.4937 12.3196 26.5059 12.3196 22.196 16.6295C17.886 20.9395 17.886 27.9273 22.196 32.2373C26.5059 36.5472 33.4937 36.5472 37.8037 32.2373Z"
                fill="#0066CC"
              />
              <path
                d="M27.7803 30.1276C27.6098 30.1276 27.4497 30.0614 27.3298 29.9406L22.9465 25.5562C22.8267 25.4364 22.7595 25.2762 22.7595 25.1068C22.7595 24.9374 22.8256 24.7762 22.9465 24.6554L24.2379 23.364C24.3577 23.2442 24.5178 23.177 24.6883 23.177C24.8587 23.177 25.0168 23.2431 25.1377 23.363L27.7803 26.0056L34.861 18.9259C34.9808 18.8061 35.1409 18.7389 35.3103 18.7389C35.4798 18.7389 35.6389 18.8051 35.7597 18.9239L37.0531 20.2173C37.173 20.3361 37.2401 20.4962 37.2401 20.6677C37.2401 20.8392 37.174 20.9983 37.0531 21.1181L28.2317 29.9406C28.1119 30.0604 27.9518 30.1265 27.7823 30.1265L27.7803 30.1276Z"
                fill="white"
              />
            </svg>
          </div>
          <div className="pf-chatbot__feedback-complete-text">
            <CardTitle className="pf-chatbot__feedback-complete-title">{title}</CardTitle>
            <CardBody className={`pf-chatbot__feedback-complete-card-body`}>{body}</CardBody>
          </div>
        </div>
      </Card>
    </div>
  );
};

export default UserFeedbackComplete;



================================================
FILE: packages/module/src/MessageBar/AttachButton.scss
================================================
// ============================================================================
// Chatbot Footer - Message Bar - Attach
// ============================================================================
.pf-v6-c-button.pf-chatbot__button--attach {
  border-radius: var(--pf-t--global--border--radius--pill);
  padding: var(--pf-t--global--spacer--md);
  width: 3rem;
  height: 3rem;

  .pf-v6-c-button__icon {
    color: var(--pf-t--global--icon--color--subtle);
  }

  // Interactive states
  &:hover {
    .pf-v6-c-button__icon {
      color: var(--pf-t--global--icon--color--regular);
    }
  }

  &:active,
  &:focus {
    background-color: var(--pf-t--global--color--brand--clicked);

    .pf-v6-c-button__icon {
      color: var(--pf-t--global--icon--color--inverse);
    }

    &:hover,
    &:focus {
      .pf-v6-c-button__icon {
        color: var(--pf-t--global--icon--color--inverse);
      }
    }
  }
}

// ============================================================================
// Information density styles
// ============================================================================
.pf-v6-c-button.pf-chatbot__button--attach.pf-m-compact {
  width: 1.5rem;
  height: 1.5rem;
  padding: var(--pf-t--global--spacer--sm);
  align-items: center;
}



================================================
FILE: packages/module/src/MessageBar/AttachButton.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import userEvent from '@testing-library/user-event';
import { AttachButton } from './AttachButton';

describe('Attach button', () => {
  it('should render button correctly', () => {
    render(<AttachButton />);
    expect(screen.getByRole('button', { name: 'Attach' })).toBeTruthy();
  });
  it('should handle isDisabled prop', () => {
    render(<AttachButton isDisabled />);
    expect(screen.getByRole('button', { name: 'Attach' })).toBeDisabled();
  });
  it('should handle spread props, including aria-label', () => {
    render(<AttachButton aria-label="test" />);
    expect(screen.getByRole('button', { name: 'test' }));
  });
  it('should handle onClick', async () => {
    const spy = jest.fn();
    render(<AttachButton onClick={spy} />);
    await userEvent.click(screen.getByRole('button', { name: 'Attach' }));
    expect(screen.getByRole('tooltip', { name: 'Attach' })).toBeTruthy();
    expect(spy).toHaveBeenCalledTimes(1);
  });
  it('should handle className prop', () => {
    render(<AttachButton className="test" />);
    expect(screen.getByRole('button', { name: 'Attach' })).toHaveClass('test');
  });
  it('should handle custom tooltip correctly', async () => {
    render(<AttachButton onClick={jest.fn} tooltipContent="Test" />);
    await userEvent.click(screen.getByRole('button', { name: 'Attach' }));
    expect(screen.getByRole('tooltip', { name: 'Test' })).toBeTruthy();
  });
  it('should handle tooltipProps prop', async () => {
    render(<AttachButton tooltipProps={{ id: 'test' }} />);
    await userEvent.click(screen.getByRole('button', { name: 'Attach' }));
    expect(screen.getByRole('tooltip', { name: 'Attach' })).toHaveAttribute('id', 'test');
  });
  // Based on this because I had no idea how to do this and was looking around: https://stackoverflow.com/a/75562651
  // See also https://developer.mozilla.org/en-US/docs/Web/API/File/File for what that file variable is doing
  it('should handle onAttachAccepted prop', async () => {
    const spy = jest.fn();
    render(<AttachButton onAttachAccepted={spy} inputTestId="input" />);
    await userEvent.click(screen.getByRole('button', { name: 'Attach' }));
    const file = new File(['test'], 'test.json');
    const input = screen.getByTestId('input') as HTMLInputElement;
    await userEvent.upload(input, file);
    expect(input.files).toHaveLength(1);
    expect(spy).toHaveBeenCalledTimes(1);
  });
  it('should handle isCompact', () => {
    render(<AttachButton isCompact data-testid="button" />);
    expect(screen.getByTestId('button')).toHaveClass('pf-m-compact');
  });
});



================================================
FILE: packages/module/src/MessageBar/AttachButton.tsx
================================================
// ============================================================================
// Chatbot Footer - Message Bar - Attach
// ============================================================================
import React from 'react';

// Import PatternFly components
import { Button, ButtonProps, DropEvent, Icon, Tooltip, TooltipProps } from '@patternfly/react-core';
import { useDropzone } from 'react-dropzone';
import { PaperclipIcon } from '@patternfly/react-icons/dist/esm/icons/paperclip-icon';

export interface AttachButtonProps extends ButtonProps {
  /** Callback for when button is clicked */
  onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void;
  /** Callback function for AttachButton when an attachment is made */
  onAttachAccepted?: (data: File[], event: DropEvent) => void;
  /** Class name for AttachButton */
  className?: string;
  /** Props to control if the AttachButton should be disabled */
  isDisabled?: boolean;
  /** Props to control the PF Tooltip component */
  tooltipProps?: Omit<TooltipProps, 'content'>;
  /** Ref applied to AttachButton and used in tooltip */
  innerRef?: React.Ref<any>;
  /** English text "Attach" used in the tooltip */
  tooltipContent?: string;
  /** Test id applied to input */
  inputTestId?: string;
  isCompact?: boolean;
}

const AttachButtonBase: React.FunctionComponent<AttachButtonProps> = ({
  onAttachAccepted,
  onClick,
  isDisabled,
  className,
  tooltipProps,
  innerRef,
  tooltipContent = 'Attach',
  inputTestId,
  isCompact,
  ...props
}: AttachButtonProps) => {
  const { open, getInputProps } = useDropzone({
    multiple: true,
    onDropAccepted: onAttachAccepted
  });

  return (
    <>
      {/* this is required for react-dropzone to work in Safari and Firefox */}
      <input data-testid={inputTestId} {...getInputProps()} hidden />
      <Tooltip
        id="pf-chatbot__tooltip--attach"
        content={tooltipContent}
        position="top"
        entryDelay={tooltipProps?.entryDelay || 0}
        exitDelay={tooltipProps?.exitDelay || 0}
        distance={tooltipProps?.distance || 8}
        animationDuration={tooltipProps?.animationDuration || 0}
        // prevents VO announcements of both aria label and tooltip
        aria="none"
        {...tooltipProps}
      >
        <Button
          variant="plain"
          ref={innerRef}
          className={`pf-chatbot__button--attach ${isCompact ? 'pf-m-compact' : ''} ${className ?? ''}`}
          aria-label={props['aria-label'] || 'Attach'}
          isDisabled={isDisabled}
          onClick={onClick ?? open}
          icon={
            <Icon iconSize={isCompact ? 'lg' : 'xl'} isInline>
              <PaperclipIcon />
            </Icon>
          }
          size={isCompact ? 'sm' : undefined}
          {...props}
        />
      </Tooltip>
    </>
  );
};

export const AttachButton = React.forwardRef((props: AttachButtonProps, ref: React.Ref<any>) => (
  <AttachButtonBase innerRef={ref} {...props} />
));



================================================
FILE: packages/module/src/MessageBar/index.ts
================================================
export { default } from './MessageBar';

export * from './MessageBar';
export * from './AttachButton';
export * from './MicrophoneButton';
export * from './SendButton';



================================================
FILE: packages/module/src/MessageBar/MessageBar.scss
================================================
// Import related component scss files.
@import './AttachButton';
@import './MicrophoneButton';
@import './SendButton';
@import './StopButton';

// ============================================================================
// Chatbot Footer - Message Bar
// ============================================================================

.pf-chatbot__message-bar {
  --pf-chatbot__message-bar-child--PaddingBlockStart: var(--pf-t--global--spacer--xs);
  --pf-chatbot__message-bar-child--PaddingBlockEnd: var(--pf-t--global--spacer--xs);

  padding-inline-start: 0.5rem;
  padding-inline-end: 0.5rem;

  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: flex-end;
  background-color: var(--pf-t--global--background--color--primary--default);
  border-radius: calc(var(--pf-t--global--border--radius--medium) * 2);
  transition: box-shadow var(--pf-t--global--motion--timing-function--accelerate)
    var(--pf-t--global--motion--duration--sm);

  overflow: hidden;

  &:hover {
    box-shadow: inset 0 0 0 1px var(--pf-t--global--border--color--default);
  }

  &:focus-within {
    box-shadow: inset 0 0 0 2px var(--pf-t--global--color--brand--default);
  }

  &-actions {
    display: flex;
    justify-content: end;
    padding-block-start: var(--pf-t--global--spacer--xs);
    padding-block-end: var(--pf-t--global--spacer--xs);
    gap: var(--pf-t--global--spacer--gap--action-to-action--plain);
  }

  &-input {
    flex: 1 1 auto;
    padding-block-start: var(--pf-t--global--spacer--sm);
    padding-block-end: var(--pf-t--global--spacer--sm);
  }
}

.pf-chatbot__message-textarea {
  --pf-v6-c-form-control--before--BorderStyle: none !important;
  --pf-v6-c-form-control--after--BorderStyle: none !important;
  resize: none !important;
  background-color: transparent !important;
  font-size: var(--pf-t--global--font--size--md) !important;
  line-height: 1.5rem !important;
  max-height: 12rem;
  overflow-y: auto !important;
  outline: none;
  overflow-wrap: break-word !important;
  word-wrap: break-word;
  height: 100%;
  width: 100%;
  display: block !important;

  .pf-v6-c-form-control__textarea:focus-visible {
    outline: none;
  }
  textarea {
    outline-offset: 0px !important;
    --pf-v6-c-form-control--PaddingBlockStart: 0;
    --pf-v6-c-form-control--PaddingBlockEnd: 0;
    --pf-v6-c-form-control--BorderRadius: 0;
    font-family: var(--pf-t--global--font--family--body);
  }
  textarea:focus-visible {
    outline: none;
  }
}

.pf-chatbot__message-textarea.pf-v6-c-form-control.pf-m-textarea:has(textarea) {
  --pf-v6-c-form-control--PaddingBlockStart: 0;
  --pf-v6-c-form-control--PaddingBlockEnd: 0;
  --pf-v6-c-form-control--PaddingInlineStart: 1rem;
  --pf-v6-c-form-control--PaddingInlineEnd: 1rem;
  --pf-v6-c-form-control__utilities--PaddingInlineEnd: 0;
}

.pf-chatbot__message-textarea.pf-v6-c-form-control.pf-m-textarea {
  --pf-v6-c-form-control--textarea--PaddingBlockStart--offset: 0;
  --pf-v6-c-form-control--textarea--PaddingBlockEnd--offset: 0;
  --pf-v6-c-form-control--textarea--PaddingInlineStart--offset: 0;
  --pf-v6-c-form-control--textarea--PaddingInlineEnd--offset: 0;
}

@media screen and (max-width: 359px) {
  .pf-chatbot__message-textarea {
    margin-top: var(--pf-t--global--spacer--md) !important;
    margin-bottom: var(--pf-t--global--spacer--md) !important;
  }
}

.pf-chatbot--embedded {
  @media screen and (max-width: 415px) {
    .pf-chatbot__message-textarea {
      margin-top: var(--pf-t--global--spacer--md) !important;
      margin-bottom: var(--pf-t--global--spacer--md) !important;
    }
  }
}

// ============================================================================
// Information density styles
// ============================================================================
.pf-chatbot__message-bar-input.pf-m-compact {
  padding-block-start: 0;
  padding-block-end: 0;

  .pf-chatbot__message-textarea {
    font-size: var(--pf-t--global--font--size--sm) !important;
  }

  .pf-chatbot__message-bar-actions {
    padding-block-start: var(--pf-t--global--spacer--md);
    padding-block-end: var(--pf-t--global--spacer--md);
  }
}



================================================
FILE: packages/module/src/MessageBar/MessageBar.test.tsx
================================================
import '@testing-library/jest-dom';
import React from 'react';
import { DropdownGroup, DropdownItem, DropdownList } from '@patternfly/react-core';
import { BellIcon, CalendarAltIcon, ClipboardIcon, CodeIcon } from '@patternfly/react-icons';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import SourceDetailsMenuItem from '../SourceDetailsMenuItem';
import { MessageBar } from './MessageBar';

const ATTACH_MENU_ITEMS = [
  <DropdownList key="list-1">
    <DropdownItem className="pf-chatbot-source-details-dropdown-item" value="auth-operator Pod" id="0">
      <SourceDetailsMenuItem
        icon={
          <svg width="24" height="25" viewBox="0 0 24 25" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path
              d="M0 12.5C0 5.87258 5.37258 0.5 12 0.5C18.6274 0.5 24 5.87258 24 12.5C24 19.1274 18.6274 24.5 12 24.5C5.37258 24.5 0 19.1274 0 12.5Z"
              fill="currentColor"
            />
            <g clipPath="url(#clip0_3280_27488)">
              <path
                d="M8.25 8.75C8.25 7.92266 8.92266 7.25 9.75 7.25H12C14.0719 7.25 15.75 8.92812 15.75 11C15.75 13.0719 14.0719 14.75 12 14.75H9.75V17C9.75 17.4148 9.41484 17.75 9 17.75C8.58516 17.75 8.25 17.4148 8.25 17V14V8.75ZM9.75 13.25H12C13.2422 13.25 14.25 12.2422 14.25 11C14.25 9.75781 13.2422 8.75 12 8.75H9.75V13.25Z"
                fill="white"
              />
            </g>
            <defs>
              <clipPath id="clip0_3280_27488">
                <rect width="7.5" height="12" fill="white" transform="translate(8.25 6.5)" />
              </clipPath>
            </defs>
          </svg>
        }
        name="auth-operator"
        type="Pod"
      />
    </DropdownItem>
  </DropdownList>,
  <DropdownGroup key="group2">
    <DropdownList>
      <DropdownItem value="Alerts" id="1" icon={<BellIcon />}>
        Alerts
      </DropdownItem>
      <DropdownItem value="Events" id="2" icon={<CalendarAltIcon />}>
        Events
      </DropdownItem>
      <DropdownItem value="Logs" id="3" icon={<ClipboardIcon />}>
        Logs
      </DropdownItem>
      <DropdownItem value="YAML - Status" id="4" icon={<CodeIcon />}>
        YAML - Status
      </DropdownItem>
      <DropdownItem value="YAML - All contents" id="5" icon={<CodeIcon />}>
        YAML - All contents
      </DropdownItem>
    </DropdownList>
  </DropdownGroup>
];

const originalSpeechRecognition = window.SpeechRecognition;

const mockSpeechRecognition = () => {
  const MockSpeechRecognition = jest.fn().mockImplementation(() => ({
    start: jest.fn(),
    stop: jest.fn()
  }));
  (MockSpeechRecognition as any).prototype = {};
  window.SpeechRecognition = MockSpeechRecognition as any;
};

describe('Message bar', () => {
  afterAll(() => {
    window.SpeechRecognition = originalSpeechRecognition;
  });
  it('should render correctly', () => {
    render(<MessageBar onSendMessage={jest.fn} />);
    expect(screen.getByRole('button', { name: 'Attach' })).toBeTruthy();
    expect(screen.queryByRole('button', { name: 'Send' })).toBeFalsy();
    expect(screen.queryByRole('button', { name: 'Use microphone' })).toBeFalsy();
    expect(screen.getByRole('textbox', { name: /Send a message.../i })).toBeTruthy();
  });
  it('can send via enter key', async () => {
    const spy = jest.fn();
    render(<MessageBar onSendMessage={spy} />);
    const input = screen.getByRole('textbox', { name: /Send a message.../i });
    await userEvent.type(input, 'Hello world');
    expect(input).toHaveTextContent('Hello world');
    await userEvent.type(input, '[Enter]');
    expect(spy).toHaveBeenCalledTimes(1);
  });
  it('calls onChange callback appropriately', async () => {
    const spy = jest.fn();
    render(<MessageBar onSendMessage={jest.fn} onChange={spy} />);
    const input = screen.getByRole('textbox', { name: /Send a message.../i });
    await userEvent.type(input, 'A');
    expect(input).toHaveTextContent('A');
    expect(spy).toHaveBeenCalledTimes(1);
    expect(spy).toHaveBeenCalledWith(expect.any(Object), 'A');
  });
  it('can use specified placeholder text', async () => {
    render(<MessageBar onSendMessage={jest.fn} placeholder="test placeholder" />);
    const input = screen.getByRole('textbox', { name: /test placeholder/i });
    await userEvent.type(input, 'Hello world');
    expect(input).toHaveTextContent('Hello world');
  });

  // Send button
  // --------------------------------------------------------------------------
  it('shows send button when text is input', async () => {
    render(<MessageBar onSendMessage={jest.fn} />);
    const input = screen.getByRole('textbox', { name: /Send a message.../i });
    await userEvent.type(input, 'Hello world');
    expect(input).toHaveTextContent('Hello world');
    expect(screen.getByRole('button', { name: 'Send' })).toBeTruthy();
  });
  it('can disable send button shown when text is input', async () => {
    render(<MessageBar onSendMessage={jest.fn} isSendButtonDisabled />);
    const input = screen.getByRole('textbox', { name: /Send a message.../i });
    await userEvent.type(input, 'Hello world');
    expect(input).toHaveTextContent('Hello world');
    expect(screen.getByRole('button', { name: 'Send' })).toBeTruthy();
    expect(screen.getByRole('button', { name: 'Send' })).toBeDisabled();
  });
  it('can click send button', async () => {
    const spy = jest.fn();
    render(<MessageBar onSendMessage={spy} />);
    const input = screen.getByRole('textbox', { name: /Send a message.../i });
    await userEvent.type(input, 'Hello world');
    expect(input).toHaveTextContent('Hello world');
    const sendButton = screen.getByRole('button', { name: 'Send' });
    expect(sendButton).toBeTruthy();
    await userEvent.click(sendButton);
    expect(spy).toHaveBeenCalledTimes(1);
  });
  it('can always show send button', () => {
    render(<MessageBar onSendMessage={jest.fn} alwayShowSendButton />);
    expect(screen.getByRole('button', { name: 'Send' })).toBeTruthy();
    expect(screen.getByRole('button', { name: 'Send' })).toBeEnabled();
  });
  it('can disable send button if always showing', () => {
    render(<MessageBar onSendMessage={jest.fn} alwayShowSendButton isSendButtonDisabled />);
    expect(screen.getByRole('button', { name: 'Send' })).toBeTruthy();
    expect(screen.getByRole('button', { name: 'Send' })).toBeDisabled();
  });
  it('can handle buttonProps tooltipContent  appropriately for send', async () => {
    render(
      <MessageBar onSendMessage={jest.fn} alwayShowSendButton buttonProps={{ send: { tooltipContent: 'Test' } }} />
    );
    await userEvent.click(screen.getByRole('button', { name: 'Send' }));
    expect(screen.getByRole('tooltip', { name: 'Test' })).toBeTruthy();
  });
  it('can handle buttonProps tooltipProps  appropriately for send', () => {
    render(
      <MessageBar
        onSendMessage={jest.fn}
        alwayShowSendButton
        buttonProps={{ send: { tooltipProps: { isVisible: true } } }}
      />
    );
    // isVisible, so no need for click
    expect(screen.getByRole('tooltip', { name: 'Send' })).toBeTruthy();
  });
  it('can handle buttonProps props appropriately for send', async () => {
    render(
      <MessageBar
        onSendMessage={jest.fn}
        alwayShowSendButton
        buttonProps={{ send: { props: { 'aria-label': 'Test' } } }}
      />
    );
    await userEvent.click(screen.getByRole('button', { name: 'Test' }));
  });

  // Attach button
  // --------------------------------------------------------------------------
  it('can show attach menu', async () => {
    render(
      <MessageBar
        onSendMessage={jest.fn}
        attachMenuProps={{
          isAttachMenuOpen: true,
          setIsAttachMenuOpen: jest.fn(),
          onAttachMenuToggleClick: jest.fn(),
          onAttachMenuInputChange: jest.fn(),
          attachMenuItems: ATTACH_MENU_ITEMS
        }}
      />
    );
    expect(screen.getByRole('textbox', { name: /Filter menu items/i })).toBeTruthy();
    expect(screen.getByRole('menuitem', { name: /auth-operator/i })).toBeTruthy();
    expect(screen.getByRole('menuitem', { name: /Alerts/i })).toBeTruthy();
    expect(screen.getByRole('menuitem', { name: /Events/i })).toBeTruthy();
    expect(screen.getByRole('menuitem', { name: /Logs/i })).toBeTruthy();
    expect(screen.getByRole('menuitem', { name: /YAML - Status/i })).toBeTruthy();
    expect(screen.getByRole('menuitem', { name: /YAML - All contents/i })).toBeTruthy();
  });
  it('can toggle attach menu', async () => {
    const attachToggleClickSpy = jest.fn();
    render(
      <MessageBar
        onSendMessage={jest.fn}
        attachMenuProps={{
          isAttachMenuOpen: false,
          setIsAttachMenuOpen: jest.fn(),
          onAttachMenuToggleClick: attachToggleClickSpy,
          onAttachMenuInputChange: jest.fn(),
          attachMenuItems: ATTACH_MENU_ITEMS
        }}
      />
    );
    expect(screen.queryByRole('textbox', { name: /Filter menu items/i })).toBeFalsy();
    expect(screen.queryByRole('menuitem', { name: /auth-operator/i })).toBeFalsy();
    expect(screen.queryByRole('menuitem', { name: /Alerts/i })).toBeFalsy();
    expect(screen.queryByRole('menuitem', { name: /Events/i })).toBeFalsy();
    expect(screen.queryByRole('menuitem', { name: /Logs/i })).toBeFalsy();
    expect(screen.queryByRole('menuitem', { name: /YAML - Status/i })).toBeFalsy();
    expect(screen.queryByRole('menuitem', { name: /YAML - All contents/i })).toBeFalsy();
    const attachButton = screen.getByRole('button', { name: 'Attach' });
    await userEvent.click(attachButton);
    expect(attachToggleClickSpy).toHaveBeenCalledTimes(1);
  });
  it('can hide attach button', () => {
    render(<MessageBar onSendMessage={jest.fn} hasAttachButton={false} />);
    expect(screen.queryByRole('button', { name: 'Attach' })).toBeFalsy();
  });
  // Based on this because I had no idea how to do this and was looking around: https://stackoverflow.com/a/75562651
  // See also https://developer.mozilla.org/en-US/docs/Web/API/File/File for what that file variable is doing
  it('can handle handleAttach', async () => {
    const spy = jest.fn();
    render(
      <MessageBar
        onSendMessage={jest.fn}
        hasAttachButton
        handleAttach={spy}
        buttonProps={{ attach: { inputTestId: 'input' } }}
      />
    );
    expect(screen.getByRole('button', { name: 'Attach' })).toBeTruthy();
    await userEvent.click(screen.getByRole('button', { name: 'Attach' }));
    const file = new File(['test'], 'test.json');
    const input = screen.getByTestId('input') as HTMLInputElement;
    await userEvent.upload(input, file);
    expect(input.files).toHaveLength(1);
    expect(spy).toHaveBeenCalledTimes(1);
  });
  it('can handle buttonProps tooltipContent appropriately for attach', async () => {
    render(<MessageBar onSendMessage={jest.fn} hasAttachButton buttonProps={{ attach: { tooltipContent: 'Test' } }} />);
    await userEvent.click(screen.getByRole('button', { name: 'Attach' }));
    expect(screen.getByRole('tooltip', { name: 'Test' })).toBeTruthy();
  });
  it('can handle buttonProps tooltipProps  appropriately for attach', () => {
    render(
      <MessageBar
        onSendMessage={jest.fn}
        alwayShowSendButton
        buttonProps={{ attach: { tooltipProps: { isVisible: true } } }}
      />
    );
    // isVisible, so no need for click
    expect(screen.getByRole('tooltip', { name: 'Attach' })).toBeTruthy();
  });
  it('can handle buttonProps props appropriately for attach', async () => {
    render(
      <MessageBar
        onSendMessage={jest.fn}
        hasAttachButton
        buttonProps={{ attach: { props: { 'aria-label': 'Test' } } }}
      />
    );
    await userEvent.click(screen.getByRole('button', { name: 'Test' }));
  });

  // Stop button
  // --------------------------------------------------------------------------
  it('can show stop button', () => {
    render(<MessageBar onSendMessage={jest.fn} hasStopButton handleStopButton={jest.fn} />);
    expect(screen.getByRole('button', { name: 'Stop' })).toBeTruthy();
  });
  it('can call handleStopButton', async () => {
    const spy = jest.fn();
    render(<MessageBar onSendMessage={jest.fn} hasStopButton handleStopButton={spy} />);
    await userEvent.click(screen.getByRole('button', { name: 'Stop' }));
    expect(spy).toHaveBeenCalledTimes(1);
  });
  it('can handle buttonProps tooltipContent appropriately for stop', async () => {
    render(
      <MessageBar
        onSendMessage={jest.fn}
        hasStopButton
        handleStopButton={jest.fn}
        buttonProps={{ stop: { tooltipContent: 'Test' } }}
      />
    );
    await userEvent.click(screen.getByRole('button', { name: 'Stop' }));
    expect(screen.getByRole('tooltip', { name: 'Test' })).toBeTruthy();
  });
  it('can handle buttonProps tooltipProps  appropriately for stop', () => {
    render(
      <MessageBar
        onSendMessage={jest.fn}
        hasStopButton
        handleStopButton={jest.fn}
        buttonProps={{ stop: { tooltipProps: { isVisible: true } } }}
      />
    );
    // isVisible, so no need for click
    expect(screen.getByRole('tooltip', { name: 'Stop' })).toBeTruthy();
  });
  it('can handle buttonProps props appropriately for stop', async () => {
    render(
      <MessageBar
        onSendMessage={jest.fn}
        hasStopButton
        handleStopButton={jest.fn}
        buttonProps={{ stop: { props: { 'aria-label': 'Test' } } }}
      />
    );
    await userEvent.click(screen.getByRole('button', { name: 'Test' }));
  });

  // Microphone button
  // --------------------------------------------------------------------------
  it('can hide microphone button when window.SpeechRecognition is not there', () => {
    render(<MessageBar onSendMessage={jest.fn} hasMicrophoneButton />);
    expect(screen.queryByRole('button', { name: 'Use microphone' })).toBeFalsy();
  });
  it('can show microphone button', () => {
    mockSpeechRecognition();
    render(<MessageBar onSendMessage={jest.fn} hasMicrophoneButton />);
    expect(screen.getByRole('button', { name: 'Use microphone' })).toBeTruthy();
  });
  it('can handle buttonProps appropriately for microphone', async () => {
    mockSpeechRecognition();
    render(
      <MessageBar
        onSendMessage={jest.fn}
        hasMicrophoneButton
        buttonProps={{
          microphone: { tooltipContent: { active: 'Currently listening', inactive: 'Not currently listening' } }
        }}
      />
    );
    await userEvent.click(screen.getByRole('button', { name: 'Use microphone' }));
    expect(screen.getByRole('tooltip', { name: 'Currently listening' })).toBeTruthy();
    await userEvent.click(screen.getByRole('button', { name: 'Stop listening' }));
    expect(screen.getByRole('tooltip', { name: 'Not currently listening' })).toBeTruthy();
  });
  it('can customize the listening placeholder', async () => {
    mockSpeechRecognition();
    render(<MessageBar onSendMessage={jest.fn} hasMicrophoneButton listeningText="I am listening" />);
    await userEvent.click(screen.getByRole('button', { name: 'Use microphone' }));
    const input = screen.getByRole('textbox', { name: /I am listening/i });
    expect(input).toBeTruthy();
  });
  it('can handle buttonProps tooltipProps  appropriately for microphone', () => {
    render(
      <MessageBar
        onSendMessage={jest.fn}
        hasMicrophoneButton
        buttonProps={{ microphone: { tooltipProps: { isVisible: true } } }}
      />
    );
    // isVisible, so no need for click
    expect(screen.getByRole('tooltip', { name: 'Use microphone' })).toBeTruthy();
  });
  it('can handle buttonProps props appropriately for microphone', async () => {
    mockSpeechRecognition();
    render(
      <MessageBar
        onSendMessage={jest.fn}
        hasMicrophoneButton
        buttonProps={{ microphone: { props: { 'aria-label': 'Test' } } }}
      />
    );
    await userEvent.click(screen.getByRole('button', { name: 'Test' }));
  });
  it('can be controlled', () => {
    render(<MessageBar onSendMessage={jest.fn} value="test" />);
    expect(screen.getByRole('button', { name: 'Attach' })).toBeTruthy();
    expect(screen.getByRole('button', { name: 'Send' })).toBeTruthy();
    expect(screen.queryByRole('button', { name: 'Use microphone' })).toBeFalsy();
    expect(screen.getByRole('textbox', { name: /Send a message.../i })).toBeTruthy();
    expect(screen.getByRole('textbox', { name: /Send a message.../i })).toHaveValue('test');
  });
});



================================================
FILE: packages/module/src/MessageBar/MessageBar.tsx
================================================
import React from 'react';
import { ButtonProps, DropEvent, TextArea, TextAreaProps, TooltipProps } from '@patternfly/react-core';

// Import Chatbot components
import SendButton from './SendButton';
import MicrophoneButton from './MicrophoneButton';
import { AttachButton } from './AttachButton';
import AttachMenu from '../AttachMenu';
import StopButton from './StopButton';
import { ChatbotDisplayMode } from '../Chatbot';

export interface MessageBarWithAttachMenuProps {
  /** Flag to enable whether attach menu is open */
  isAttachMenuOpen: boolean;
  /** Callback to close attach menu */
  setIsAttachMenuOpen: (isOpen: boolean) => void;
  /** Items in menu */
  attachMenuItems: React.ReactNode;
  /** A callback for when the attachment menu toggle is clicked */
  onAttachMenuToggleClick: () => void;
  /** A callback for when the input value in the menu changes. */
  onAttachMenuInputChange: (value: string) => void;
  /** Function callback called when user selects item in menu. */
  onAttachMenuSelect?: (event?: React.MouseEvent<Element, MouseEvent>, value?: string | number) => void;
  /** Placeholder for search input */
  attachMenuInputPlaceholder?: string;
  /** Keys that trigger onOpenChange, defaults to tab and escape. It is highly recommended to include Escape in the array, while Tab may be omitted if the menu contains non-menu items that are focusable. */
  onAttachMenuOnOpenChangeKeys?: string[];
  /** Callback to change the open state of the menu. Triggered by clicking outside of the menu. */
  onAttachMenuOpenChange?: (isOpen: boolean) => void;
}

export interface MessageBarProps extends TextAreaProps {
  /** Callback to get the value of input message by user */
  onSendMessage: (message: string | number) => void;
  /** Class Name for the MessageBar component */
  className?: string;
  /** Flag to always to show the send button. By default send button is shown when there is a message in the input field */
  alwayShowSendButton?: boolean;
  /** Placeholder for message input */
  placeholder?: string;
  /** Flag to disable/enable the Attach button  */
  hasAttachButton?: boolean;
  /** Flag to enable the Microphone button  */
  hasMicrophoneButton?: boolean;
  /** Placeholder text when listening */
  listeningText?: string;
  /** Flag to enable the Stop button, used for streaming content */
  hasStopButton?: boolean;
  /** Callback function for when stop button is clicked */
  handleStopButton?: (event: React.MouseEvent<HTMLButtonElement>) => void;
  /** Callback function for when attach button is used to upload a file */
  handleAttach?: (data: File[], event: DropEvent) => void;
  /** Props to enable a menu that opens when the Attach button is clicked, instead of the attachment window */
  attachMenuProps?: MessageBarWithAttachMenuProps;
  /** Flag to provide manual control over whether send button is disabled */
  isSendButtonDisabled?: boolean;
  /** Prop to allow passage of additional props to buttons */
  buttonProps?: {
    attach?: {
      tooltipContent?: string;
      props?: ButtonProps;
      inputTestId?: string;
      tooltipProps?: Omit<TooltipProps, 'content'>;
    };
    stop?: { tooltipContent?: string; props?: ButtonProps; tooltipProps?: Omit<TooltipProps, 'content'> };
    send?: { tooltipContent?: string; props?: ButtonProps; tooltipProps?: Omit<TooltipProps, 'content'> };
    microphone?: {
      tooltipContent?: { active?: string; inactive?: string };
      language?: string;
      props?: ButtonProps;
      tooltipProps?: Omit<TooltipProps, 'content'>;
    };
  };
  /** A callback for when the text area value changes. */
  onChange?: (event: React.ChangeEvent<HTMLTextAreaElement>, value: string | number) => void;
  /** Display mode of chatbot, if you want to message bar to resize when the display mode changes */
  displayMode?: ChatbotDisplayMode;
  isCompact?: boolean;
}

export const MessageBar: React.FunctionComponent<MessageBarProps> = ({
  onSendMessage,
  className,
  alwayShowSendButton,
  placeholder = 'Send a message...',
  hasAttachButton = true,
  hasMicrophoneButton,
  listeningText = 'Listening',
  handleAttach,
  attachMenuProps,
  isSendButtonDisabled,
  handleStopButton,
  hasStopButton,
  buttonProps,
  onChange,
  displayMode,
  value,
  isCompact = false,
  ...props
}: MessageBarProps) => {
  // Text Input
  // --------------------------------------------------------------------------
  const [message, setMessage] = React.useState<string | number>(value ?? '');
  const [isListeningMessage, setIsListeningMessage] = React.useState<boolean>(false);
  const [hasSentMessage, setHasSentMessage] = React.useState(false);
  const textareaRef = React.useRef<HTMLTextAreaElement>(null);
  const attachButtonRef = React.useRef<HTMLButtonElement>(null);

  const topMargin = '1rem';

  const setInitialLineHeight = (field: HTMLTextAreaElement) => {
    field.style.setProperty('line-height', '1rem');
    const parent = field.parentElement;
    if (parent) {
      parent.style.setProperty('margin-top', topMargin);
      parent.style.setProperty('margin-bottom', `0rem`);
      parent.style.setProperty('height', 'inherit');

      const grandparent = parent.parentElement;
      if (grandparent) {
        grandparent.style.setProperty('flex-basis', 'auto');
      }
    }
  };

  const setAutoHeight = (field: HTMLTextAreaElement) => {
    const parent = field.parentElement;
    if (parent) {
      parent.style.setProperty('height', 'inherit');
      const computed = window.getComputedStyle(field);
      // Calculate the height
      const height =
        parseInt(computed.getPropertyValue('border-top-width')) +
        parseInt(computed.getPropertyValue('padding-top')) +
        field.scrollHeight +
        parseInt(computed.getPropertyValue('padding-bottom')) +
        parseInt(computed.getPropertyValue('border-bottom-width'));
      parent.style.setProperty('height', `${height}px`);

      if (height > 32 || window.innerWidth <= 507) {
        parent.style.setProperty('margin-bottom', topMargin);
        parent.style.setProperty('margin-top', topMargin);
      }
    }
  };

  const textIsLongerThan2Lines = (field: HTMLTextAreaElement) => {
    const lineHeight = parseFloat(window.getComputedStyle(field).lineHeight);
    const lines = field.scrollHeight / lineHeight;
    return lines > 2;
  };

  const setAutoWidth = React.useCallback((field: HTMLTextAreaElement) => {
    const parent = field.parentElement;
    if (parent) {
      const grandparent = parent.parentElement;
      if (textIsLongerThan2Lines(field) && grandparent) {
        grandparent.style.setProperty('flex-basis', `100%`);
      }
    }
  }, []);

  const handleNewLine = (field: HTMLTextAreaElement) => {
    const parent = field.parentElement;
    if (parent) {
      parent.style.setProperty('margin-bottom', topMargin);
      parent.style.setProperty('margin-top', topMargin);
    }
  };

  React.useEffect(() => {
    const field = textareaRef.current;
    if (field) {
      if (field.value === '') {
        if (window.innerWidth > 507) {
          setInitialLineHeight(field);
        }
      } else {
        setAutoHeight(field);
        setAutoWidth(field);
      }
    }
    const resetHeight = () => {
      if (field) {
        if (field.value === '') {
          if (window.innerWidth > 507) {
            setInitialLineHeight(field);
          }
        } else {
          setAutoHeight(field);
          setAutoWidth(field);
        }
      }
    };
    window.addEventListener('resize', resetHeight);

    return () => {
      window.removeEventListener('resize', resetHeight);
    };
  }, [setAutoWidth]);

  React.useEffect(() => {
    const field = textareaRef.current;
    if (field) {
      if (field.value === '') {
        setInitialLineHeight(textareaRef.current);
      } else {
        setAutoHeight(textareaRef.current);
        setAutoWidth(field);
      }
    }
  }, [displayMode, message, setAutoWidth]);

  React.useEffect(() => {
    const field = textareaRef.current;
    if (field) {
      setInitialLineHeight(field);
      setHasSentMessage(false);
    }
  }, [hasSentMessage]);

  const handleChange = React.useCallback(
    (event) => {
      onChange && onChange(event, event.target.value);
      if (textareaRef.current) {
        if (event.target.value === '') {
          setInitialLineHeight(textareaRef.current);
        } else {
          setAutoHeight(textareaRef.current);
        }
      }
      setMessage(event.target.value);
    },
    [onChange]
  );

  // Handle sending message
  const handleSend = React.useCallback(
    (newMessage: string | number) => {
      onSendMessage(newMessage);
      setHasSentMessage(true);
      setMessage('');
    },
    [onSendMessage]
  );

  const handleKeyDown = React.useCallback(
    (event: React.KeyboardEvent) => {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        if (!isSendButtonDisabled && !hasStopButton) {
          handleSend(message);
        }
      }
      if (event.key === 'Enter' && event.shiftKey) {
        if (textareaRef.current) {
          handleNewLine(textareaRef.current);
        }
      }
    },
    [isSendButtonDisabled, hasStopButton, handleSend, message]
  );

  const handleAttachMenuToggle = () => {
    attachMenuProps?.setIsAttachMenuOpen && attachMenuProps?.setIsAttachMenuOpen(!attachMenuProps?.isAttachMenuOpen);
    attachMenuProps?.onAttachMenuToggleClick();
  };

  const handleSpeechRecognition = (message) => {
    setMessage(message);
    onChange && onChange({} as React.ChangeEvent<HTMLTextAreaElement>, message);
  };

  const renderButtons = () => {
    if (hasStopButton && handleStopButton) {
      return (
        <StopButton
          onClick={handleStopButton}
          tooltipContent={buttonProps?.stop?.tooltipContent}
          isCompact={isCompact}
          tooltipProps={buttonProps?.stop?.tooltipProps}
          {...buttonProps?.stop?.props}
        />
      );
    }
    return (
      <>
        {attachMenuProps && (
          <AttachButton
            ref={attachButtonRef}
            onClick={handleAttachMenuToggle}
            isDisabled={isListeningMessage}
            tooltipContent={buttonProps?.attach?.tooltipContent}
            isCompact={isCompact}
            tooltipProps={buttonProps?.attach?.tooltipProps}
            {...buttonProps?.attach?.props}
          />
        )}
        {!attachMenuProps && hasAttachButton && (
          <AttachButton
            onAttachAccepted={handleAttach}
            isDisabled={isListeningMessage}
            tooltipContent={buttonProps?.attach?.tooltipContent}
            inputTestId={buttonProps?.attach?.inputTestId}
            isCompact={isCompact}
            tooltipProps={buttonProps?.attach?.tooltipProps}
            {...buttonProps?.attach?.props}
          />
        )}
        {hasMicrophoneButton && (
          <MicrophoneButton
            isListening={isListeningMessage}
            onIsListeningChange={setIsListeningMessage}
            onSpeechRecognition={handleSpeechRecognition}
            tooltipContent={buttonProps?.microphone?.tooltipContent}
            language={buttonProps?.microphone?.language}
            isCompact={isCompact}
            tooltipProps={buttonProps?.microphone?.tooltipProps}
            {...buttonProps?.microphone?.props}
          />
        )}
        {(alwayShowSendButton || message) && (
          <SendButton
            value={message}
            onClick={() => handleSend(message)}
            isDisabled={isSendButtonDisabled}
            tooltipContent={buttonProps?.send?.tooltipContent}
            isCompact={isCompact}
            tooltipProps={buttonProps?.send?.tooltipProps}
            {...buttonProps?.send?.props}
          />
        )}
      </>
    );
  };

  const messageBarContents = (
    <>
      <div className={`pf-chatbot__message-bar-input ${isCompact ? 'pf-m-compact' : ''}`}>
        <TextArea
          className="pf-chatbot__message-textarea"
          value={message}
          onChange={handleChange}
          aria-label={isListeningMessage ? listeningText : placeholder}
          placeholder={isListeningMessage ? listeningText : placeholder}
          ref={textareaRef}
          onKeyDown={handleKeyDown}
          {...props}
        />
      </div>
      <div className="pf-chatbot__message-bar-actions">{renderButtons()}</div>
    </>
  );

  if (attachMenuProps) {
    return (
      <AttachMenu
        toggle={(toggleRef) => (
          <div ref={toggleRef} className={`pf-chatbot__message-bar ${className ?? ''}`}>
            {messageBarContents}
          </div>
        )}
        filteredItems={attachMenuProps?.attachMenuItems}
        {...(attachMenuProps && { isOpen: attachMenuProps.isAttachMenuOpen })}
        onOpenChange={(isAttachMenuOpen) => {
          attachButtonRef.current?.focus();
          attachMenuProps?.setIsAttachMenuOpen(isAttachMenuOpen);
          attachMenuProps?.onAttachMenuOpenChange && attachMenuProps?.onAttachMenuOpenChange(isAttachMenuOpen);
        }}
        onOpenChangeKeys={attachMenuProps?.onAttachMenuOnOpenChangeKeys}
        onSelect={attachMenuProps?.onAttachMenuSelect}
        {...(attachMenuProps && { handleTextInputChange: attachMenuProps.onAttachMenuInputChange })}
        popperProps={{ direction: 'up', distance: '8' }}
        searchInputPlaceholder={attachMenuProps?.attachMenuInputPlaceholder}
      />
    );
  }

  return <div className={`pf-chatbot__message-bar ${className ?? ''}`}>{messageBarContents}</div>;
};

export default MessageBar;



================================================
FILE: packages/module/src/MessageBar/MicrophoneButton.scss
================================================
// ============================================================================
// Chatbot Footer - Message Bar - Microphone
// ============================================================================
.pf-v6-c-button.pf-chatbot__button--microphone {
  border-radius: var(--pf-t--global--border--radius--pill);
  padding: var(--pf-t--global--spacer--md);
  width: 3rem;
  height: 3rem;

  .pf-v6-c-button__icon {
    color: var(--pf-t--global--icon--color--subtle);
  }

  // Interactive states
  &:hover,
  &:focus {
    .pf-v6-c-button__icon {
      color: var(--pf-t--global--icon--color--regular);
    }
  }

  // Active state (while recording voice)
  &--active {
    background-color: var(--pf-t--global--color--brand--clicked);
    animation: motionMicButton var(--pf-t--global--motion--timing-function--accelerate)
      calc(var(--pf-t--global--motion--duration--md) * 8) infinite;

    .pf-v6-c-button__icon {
      color: var(--pf-t--global--icon--color--on-brand--default);
    }

    &:hover,
    &:focus {
      .pf-v6-c-button__icon {
        color: var(--pf-t--global--icon--color--on-brand--default);
      }
    }
  }
}

@keyframes motionMicButton {
  0% {
    box-shadow: 0 0 0 0 rgba(0, 77, 153, 1);
  }
  100% {
    box-shadow: 0 0 0 16px rgba(0, 102, 204, 0);
  }
}

// ============================================================================
// Information density styles
// ============================================================================
.pf-v6-c-button.pf-chatbot__button--microphone.pf-m-compact {
  width: 1.5rem;
  height: 1.5rem;
  padding: var(--pf-t--global--spacer--sm);
  align-items: center;
}



================================================
FILE: packages/module/src/MessageBar/MicrophoneButton.tsx
================================================
// ============================================================================
// Chatbot Footer - Message Bar - Microphone
// ============================================================================
import React from 'react';

// Import PatternFly components
import { Button, ButtonProps, Tooltip, TooltipProps, Icon } from '@patternfly/react-core';

// Import FontAwesome icons
import { MicrophoneIcon } from '@patternfly/react-icons/dist/esm/icons/microphone-icon';

export interface MicrophoneButtonProps extends ButtonProps {
  /** Boolean check if the browser is listening to speech or not */
  isListening: boolean;
  /** Class name for MicrophoneButton */
  className?: string;
  /** Callback to update the value of isListening */
  onIsListeningChange: React.Dispatch<React.SetStateAction<boolean>>;
  /** Callback to update the message value once speech recognition is complete */
  onSpeechRecognition: React.Dispatch<React.SetStateAction<string>>;
  /** Props to control the PF Tooltip component */
  tooltipProps?: Omit<TooltipProps, 'content'>;
  /** English text "Use microphone" and "Stop listening" used in the tooltip */
  tooltipContent?: { active?: string; inactive?: string };
  /** Locale code for language speech recognition is conducted in. This should be in the format 'en-US', a.k.a. the ISO 639-1 code, a dash, and the ISO_3166-1 code. */
  language?: string;
  isCompact?: boolean;
}

export const MicrophoneButton: React.FunctionComponent<MicrophoneButtonProps> = ({
  isListening,
  onIsListeningChange,
  onSpeechRecognition,
  className,
  tooltipProps,
  tooltipContent = { active: 'Stop listening', inactive: 'Use microphone' },
  language = 'en-US',
  isCompact,
  ...props
}: MicrophoneButtonProps) => {
  // Microphone
  // --------------------------------------------------------------------------
  const [speechRecognition, setSpeechRecognition] = React.useState<SpeechRecognition>();

  // Listen for speech
  const startListening = React.useCallback(() => {
    if (speechRecognition) {
      speechRecognition.start();
      onIsListeningChange(true);
    }
  }, [onIsListeningChange, speechRecognition]);

  // Stop listening for speech
  const stopListening = React.useCallback(() => {
    if (speechRecognition && isListening) {
      speechRecognition.stop();
      onIsListeningChange(false);
    }
  }, [isListening, onIsListeningChange, speechRecognition]);

  // Detect speech recognition browser support
  React.useEffect(() => {
    if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
      // Initialize SpeechRecognition
      const recognition: SpeechRecognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
      recognition.continuous = false;
      recognition.interimResults = false;
      recognition.lang = language;

      recognition.onresult = (event) => {
        const result = event.results[0][0].transcript;
        onSpeechRecognition(result);
        recognition.stop();
        // turn button off
        onIsListeningChange(false);
      };

      recognition.onerror = (event) => {
        // eslint-disable-next-line no-console
        console.error('Speech recognition error:', event.error);
        recognition.stop();
      };

      setSpeechRecognition(recognition);
    }
  }, [onSpeechRecognition, language, onIsListeningChange]);

  if (!speechRecognition) {
    return null;
  }

  return (
    <Tooltip
      aria="none"
      aria-live="polite"
      id="pf-chatbot__tooltip--use-microphone"
      content={isListening ? tooltipContent.active : tooltipContent.inactive}
      position={tooltipProps?.position || 'top'}
      entryDelay={tooltipProps?.entryDelay || 0}
      exitDelay={tooltipProps?.exitDelay || 0}
      distance={tooltipProps?.distance || 8}
      animationDuration={tooltipProps?.animationDuration || 0}
      {...tooltipProps}
    >
      <Button
        variant="plain"
        className={`pf-chatbot__button--microphone ${isListening ? 'pf-chatbot__button--microphone--active' : ''} ${isCompact ? 'pf-m-compact' : ''} ${className ?? ''}`}
        aria-label={props['aria-label'] || (isListening ? 'Stop listening' : 'Use microphone')}
        aria-pressed={isListening}
        onClick={isListening ? stopListening : startListening}
        icon={
          <Icon iconSize={isCompact ? 'lg' : 'xl'} isInline>
            <MicrophoneIcon />
          </Icon>
        }
        size={isCompact ? 'sm' : undefined}
        {...props}
      />
    </Tooltip>
  );
};

export default MicrophoneButton;



================================================
FILE: packages/module/src/MessageBar/SendButton.scss
================================================
// ============================================================================
// Chatbot Footer - Message Bar - Send
// ============================================================================
.pf-v6-c-button.pf-chatbot__button--send {
  border-radius: var(--pf-t--global--border--radius--pill);
  padding: var(--pf-t--global--spacer--md);
  width: 3rem;
  height: 3rem;

  .pf-v6-c-button__icon {
    --pf-v6-c-button__icon--Color: var(--pf-t--global--color--brand--default);
  }

  &:hover,
  &:focus {
    background-color: var(--pf-t--chatbot--blue-icon--background--color--hover);
    color: var(--pf-t--global--color--brand--hover);

    .pf-v6-c-button__icon {
      color: var(--pf-t--chatbot--blue-icon--fill--hover);
    }
  }
}

.pf-v6-theme-dark {
  .pf-v6-c-button.pf-chatbot__button--send {
    background-color: var(--pf-t--global--color--brand--default);
    .pf-v6-c-button__icon {
      --pf-v6-c-button__icon--Color: var(--pf-t--global--icon--color--inverse);
    }
  }

  .pf-v6-c-button:disabled.pf-chatbot__button--send:disabled {
    --pf-v6-c-button--disabled--Color: var(--pf-t--global--icon--color--disabled);
    background-color: var(--pf-t--global--background--color--disabled--default);
  }

  .pf-v6-c-button.pf-chatbot__button--send:hover,
  .pf-v6-c-button.pf-chatbot__button--send:focus {
    background-color: var(--pf-t--chatbot--blue-icon--background--color--hover);
  }
}

@keyframes motionSendButton {
  0% {
    opacity: 0;
    transform: translate3d(-8px, 0, 0);
  }
  100% {
    opacity: 1;
    transform: translate3d(0, 0, 0);
  }
}

// ============================================================================
// Information density styles
// ============================================================================
.pf-v6-c-button.pf-chatbot__button--send.pf-m-compact {
  width: 1.5rem;
  height: 1.5rem;
  padding: var(--pf-t--global--spacer--sm);
  align-items: center;
}



================================================
FILE: packages/module/src/MessageBar/SendButton.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import userEvent from '@testing-library/user-event';
import { SendButton } from './SendButton';
import { TooltipProps } from '@patternfly/react-core';

const renderSend = (props?: { [key: string]: string | boolean | Omit<TooltipProps, 'content'> }) => {
  const spy = jest.fn();
  render(<SendButton onClick={spy} {...props} />);
};
describe('Send button', () => {
  it('should render button correctly', () => {
    renderSend();
    expect(screen.getByRole('button', { name: 'Send' })).toBeTruthy();
  });
  it('should handle onClick correctly', async () => {
    const spy = jest.fn();
    render(<SendButton onClick={spy} />);
    await userEvent.click(screen.getByRole('button', { name: 'Send' }));
    expect(screen.getByRole('tooltip', { name: 'Send' })).toBeTruthy();
    expect(spy).toHaveBeenCalledTimes(1);
  });
  it('should handle custom tooltip correctly', async () => {
    render(<SendButton onClick={jest.fn} tooltipContent="Test" />);
    await userEvent.click(screen.getByRole('button', { name: 'Send' }));
    expect(screen.getByRole('tooltip', { name: 'Test' })).toBeTruthy();
  });
  it('should handle className prop', () => {
    renderSend({ className: 'test' });
    expect(screen.getByRole('button', { name: 'Send' })).toHaveClass('test');
  });

  it('should handle spread props, including aria-label', () => {
    renderSend({ 'aria-label': 'test' });
    expect(screen.getByRole('button', { name: 'test' }));
  });
  it('should handle tooltipProps prop', async () => {
    renderSend({ tooltipProps: { id: 'test' } });
    await userEvent.click(screen.getByRole('button', { name: 'Send' }));
    expect(screen.getByRole('tooltip', { name: 'Send' })).toHaveAttribute('id', 'test');
  });
  it('should handle isCompact', () => {
    renderSend({ 'data-testid': 'button', isCompact: true });
    expect(screen.getByTestId('button')).toHaveClass('pf-m-compact');
  });
});



================================================
FILE: packages/module/src/MessageBar/SendButton.tsx
================================================
// ============================================================================
// Chatbot Footer - Message Bar - Send
// ============================================================================
import React from 'react';

// Import PatternFly components
import { Button, ButtonProps, Tooltip, TooltipProps, Icon } from '@patternfly/react-core';

import { PaperPlaneIcon } from '@patternfly/react-icons/dist/esm/icons/paper-plane-icon';

export interface SendButtonProps extends ButtonProps {
  /** Callback for when button is clicked */
  onClick: (event: React.MouseEvent<HTMLButtonElement>) => void;
  /** Class Name for SendButton */
  className?: string;
  /** Props to control the PF Tooltip component */
  tooltipProps?: Omit<TooltipProps, 'content'>;
  /** English text "Send" used in the tooltip */
  tooltipContent?: string;
  isCompact?: boolean;
}

export const SendButton: React.FunctionComponent<SendButtonProps> = ({
  className,
  onClick,
  tooltipProps,
  tooltipContent = 'Send',
  isCompact,
  ...props
}: SendButtonProps) => (
  <Tooltip
    id="pf-chatbot__tooltip--send"
    content={tooltipContent}
    position={tooltipProps?.position || 'top'}
    entryDelay={tooltipProps?.entryDelay || 0}
    exitDelay={tooltipProps?.exitDelay || 0}
    distance={tooltipProps?.distance || 8}
    animationDuration={tooltipProps?.animationDuration || 0}
    // prevents VO announcements of both aria label and tooltip
    aria="none"
    {...tooltipProps}
  >
    <Button
      variant="plain"
      className={`pf-chatbot__button--send ${isCompact ? 'pf-m-compact' : ''} ${className ?? ''}`}
      aria-label={props['aria-label'] || 'Send'}
      onClick={onClick}
      icon={
        <Icon iconSize={isCompact ? 'lg' : 'xl'} isInline>
          <PaperPlaneIcon />
        </Icon>
      }
      size={isCompact ? 'sm' : undefined}
      {...props}
    />
  </Tooltip>
);

export default SendButton;



================================================
FILE: packages/module/src/MessageBar/StopButton.scss
================================================
// ============================================================================
// Chatbot Footer - Message Bar - Stop
// ============================================================================
.pf-v6-c-button.pf-chatbot__button--stop {
  background-color: var(--pf-t--global--color--brand--default);
  border-radius: var(--pf-t--global--border--radius--pill);
  padding: var(--pf-t--global--spacer--md);
  width: 3rem;
  height: 3rem;
  display: flex;
  justify-content: center;
  align-items: center;

  .pf-v6-c-button__icon {
    color: var(--pf-t--global--icon--color--on-brand--default);
  }

  &:hover {
    background-color: var(--pf-t--global--color--brand--hover);
  }

  &:focus {
    background-color: var(--pf-t--global--color--brand--clicked);

    .pf-v6-c-button__icon {
      color: var(--pf-t--global--icon--color--on-brand--default);
    }

    &:hover,
    &:focus {
      .pf-v6-c-button__icon {
        color: var(--pf-t--global--icon--color--on-brand--default);
      }
    }
  }
}

// ============================================================================
// Information density styles
// ============================================================================
.pf-v6-c-button.pf-chatbot__button--stop.pf-m-compact {
  width: 1.5rem;
  height: 1.5rem;
  padding: var(--pf-t--global--spacer--sm);
  align-items: center;
}



================================================
FILE: packages/module/src/MessageBar/StopButton.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import userEvent from '@testing-library/user-event';
import { StopButton } from './StopButton';
import { TooltipProps } from '@patternfly/react-core';

const renderStop = (props?: { [key: string]: string | boolean | Omit<TooltipProps, 'content'> }) => {
  const spy = jest.fn();
  render(<StopButton onClick={spy} {...props} />);
};
describe('Stop button', () => {
  it('should render button correctly', () => {
    renderStop();
    expect(screen.getByRole('button', { name: 'Stop' })).toBeTruthy();
  });
  it('should handle onClick correctly', async () => {
    const spy = jest.fn();
    render(<StopButton onClick={spy} />);
    await userEvent.click(screen.getByRole('button', { name: 'Stop' }));
    expect(screen.getByRole('tooltip', { name: 'Stop' })).toBeTruthy();
    expect(spy).toHaveBeenCalledTimes(1);
  });
  it('should handle custom tooltip correctly', async () => {
    render(<StopButton onClick={jest.fn} tooltipContent="Test" />);
    await userEvent.click(screen.getByRole('button', { name: 'Stop' }));
    expect(screen.getByRole('tooltip', { name: 'Test' })).toBeTruthy();
  });
  it('should handle className prop', () => {
    renderStop({ className: 'test' });
    expect(screen.getByRole('button', { name: 'Stop' })).toHaveClass('test');
  });
  it('should handle spread props, including aria-label', () => {
    renderStop({ 'aria-label': 'test' });
    expect(screen.getByRole('button', { name: 'test' }));
  });
  it('should handle tooltipProps prop', async () => {
    renderStop({ tooltipProps: { id: 'test' } });
    await userEvent.click(screen.getByRole('button', { name: 'Stop' }));
    expect(screen.getByRole('tooltip', { name: 'Stop' })).toHaveAttribute('id', 'test');
  });
  it('should handle isCompact', () => {
    renderStop({ 'data-testid': 'button', isCompact: true });
    expect(screen.getByTestId('button')).toHaveClass('pf-m-compact');
  });
});



================================================
FILE: packages/module/src/MessageBar/StopButton.tsx
================================================
// ============================================================================
// Chatbot Footer - Message Bar - Stop
// ============================================================================
import React from 'react';

// Import PatternFly components
import { Button, ButtonProps, Tooltip, TooltipProps, Icon } from '@patternfly/react-core';

export interface StopButtonProps extends ButtonProps {
  /** Callback for when button is clicked */
  onClick: (event: React.MouseEvent<HTMLButtonElement>) => void;
  /** Class name for StopButton */
  className?: string;
  /** Props to control the PF Tooltip component */
  tooltipProps?: Omit<TooltipProps, 'content'>;
  /** English text "Stop" used in the tooltip */
  tooltipContent?: string;
  isCompact?: boolean;
}

export const StopButton: React.FunctionComponent<StopButtonProps> = ({
  className,
  onClick,
  tooltipProps,
  tooltipContent = 'Stop',
  isCompact,
  ...props
}: StopButtonProps) => (
  <Tooltip
    id="pf-chatbot__tooltip--stop"
    content={tooltipContent}
    position={tooltipProps?.position || 'top'}
    entryDelay={tooltipProps?.entryDelay || 0}
    exitDelay={tooltipProps?.exitDelay || 0}
    distance={tooltipProps?.distance || 8}
    animationDuration={tooltipProps?.animationDuration || 0}
    // prevents VO announcements of both aria label and tooltip
    aria="none"
    {...tooltipProps}
  >
    <Button
      className={`pf-chatbot__button--stop ${isCompact ? 'pf-m-compact' : ''} ${className ?? ''}`}
      variant="link"
      aria-label={props['aria-label'] || 'Stop'}
      onClick={onClick}
      icon={
        <Icon iconSize={isCompact ? 'lg' : 'xl'} isInline>
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path
              d="M0.5 3C0.5 1.62109 1.62109 0.5 3 0.5H13C14.3789 0.5 15.5 1.62109 15.5 3V13C15.5 14.3789 14.3789 15.5 13 15.5H3C1.62109 15.5 0.5 14.3789 0.5 13V3Z"
              fill="currentColor"
            />
          </svg>
        </Icon>
      }
      size={isCompact ? 'sm' : undefined}
      {...props}
    />
  </Tooltip>
);

export default StopButton;



================================================
FILE: packages/module/src/MessageBox/index.ts
================================================
export { default } from './MessageBox';

export * from './MessageBox';
export * from './JumpButton';



================================================
FILE: packages/module/src/MessageBox/JumpButton.scss
================================================
// ============================================================================
// Chatbot Jump Button
// ============================================================================
// importants are temporary until we can find a workaround for the way Backstage is pulling in style sheets
.pf-chatbot__jump {
  position: absolute !important;
  inset-inline-start: 75% !important;
  width: 2rem !important;
  height: 2rem !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  padding: var(--pf-t--global--spacer--md) !important;
  border-radius: var(--pf-t--global--border--radius--pill) !important;
  --pf-v6-c-button--MinWidth: 2rem !important;
  background-color: var(--pf-t--global--background--color--primary--default) !important;
  border: 1px solid var(--pf-t--chatbot--border) !important;
  box-shadow: var(--pf-t--global--box-shadow--sm);
  color: var(--pf-t--global--icon--color--subtle) !important;
  transform: translate3d(-50%, 0, 0) !important;
  transition:
    background-color var(--pf-t--global--motion--timing-function--accelerate) var(--pf-t--global--motion--duration--sm),
    box-shadow var(--pf-t--global--motion--timing-function--accelerate) var(--pf-t--global--motion--duration--sm),
    transform var(--pf-t--global--motion--timing-function--accelerate) var(--pf-t--global--motion--duration--md),
    opacity var(--pf-t--global--motion--timing-function--accelerate) var(--pf-t--global--motion--duration--md) !important;
  z-index: var(--pf-t--global--z-index--md) !important;

  .pf-v6-c-button__text {
    line-height: 1rem;
  }

  &:hover,
  &:focus {
    background-color: var(--pf-t--global--background--color--primary--hover) !important;
    box-shadow: var(--pf-t--global--box-shadow--md) !important;
    color: var(--pf-t--global--icon--color--regular) !important;
  }

  &--top {
    inset-block-start: var(--pf-t--global--spacer--md) !important;
  }

  &--bottom {
    inset-block-end: var(--pf-t--global--spacer--md) !important;
  }

  // allows for zoom conditions; try zooming to 200% to see
  @media screen and (max-height: 518px) {
    display: none;
  }
}



================================================
FILE: packages/module/src/MessageBox/JumpButton.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import JumpButton from './JumpButton';
import userEvent from '@testing-library/user-event';

describe('JumpButton', () => {
  it('should render top button correctly', () => {
    render(<JumpButton position="top" onClick={jest.fn()} />);
    expect(screen.getByRole('button', { name: /Jump top/i })).toBeTruthy();
  });
  it('should render bottom button correctly', () => {
    render(<JumpButton position="bottom" onClick={jest.fn()} />);
    expect(screen.getByRole('button', { name: /Jump bottom/i })).toBeTruthy();
  });
  it('should call onClick appropriately', async () => {
    const spy = jest.fn();
    render(<JumpButton position="bottom" onClick={spy} />);
    await userEvent.click(screen.getByRole('button', { name: /Jump bottom/i }));
    expect(spy).toHaveBeenCalledTimes(1);
  });
  it('should be hidden if isHidden prop is used', async () => {
    render(<JumpButton position="bottom" onClick={jest.fn()} isHidden />);
    expect(screen.queryByRole('button', { name: /Jump bottom/i })).toBeFalsy();
  });
});



================================================
FILE: packages/module/src/MessageBox/JumpButton.tsx
================================================
// ============================================================================
// Chatbot Main - Messages - Jump to Top
// ============================================================================
import React from 'react';

// Import PatternFly components
import { Button, Tooltip, Icon } from '@patternfly/react-core';

import { ArrowUpIcon } from '@patternfly/react-icons/dist/esm/icons/arrow-up-icon';
import { ArrowDownIcon } from '@patternfly/react-icons/dist/esm/icons/arrow-down-icon';

export interface JumpButtonProps {
  /** Position of the Jump Button(top/bottom) */
  position: 'top' | 'bottom';
  /** Callback for the onClick event */
  onClick: () => void;
  /** Flag to change the visibilty of the button */
  isHidden?: boolean;
}

const JumpButton: React.FunctionComponent<JumpButtonProps> = ({ position, isHidden, onClick }: JumpButtonProps) =>
  isHidden ? null : (
    <Tooltip id={`pf-chatbot__tooltip--jump-${position}`} content={`Back to ${position}`} position="top">
      <Button
        variant="plain"
        className={`pf-chatbot__jump pf-chatbot__jump--${position}`}
        aria-label={`Jump ${position}`}
        onClick={onClick}
      >
        <Icon iconSize="lg" isInline>
          {position === 'top' ? <ArrowUpIcon /> : <ArrowDownIcon />}
        </Icon>
      </Button>
    </Tooltip>
  );

export default JumpButton;



================================================
FILE: packages/module/src/MessageBox/MessageBox.scss
================================================
@import './JumpButton';

.pf-chatbot__messagebox {
  height: 100%;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  row-gap: var(--pf-t--global--spacer--sm);
  padding: var(--pf-t--global--spacer--lg);

  // 32 rem is the width of the overlay chatbot plus the insets
  // if the screen is smaller, we want to be 100%
  @media screen and (max-width: 32rem) {
    width: 100%;
  }
  // allows for zoom conditions; try zooming to 200% to see
  @media screen and (max-height: 518px) {
    overflow-y: visible;
  }
}

.pf-chatbot__messagebox--bottom > :first-child {
  margin-top: auto !important;
}

// hide from view but not assistive technologies
// https://css-tricks.com/inclusively-hidden/
.pf-chatbot__messagebox-announcement {
  clip: rect(0 0 0 0);
  clip-path: inset(50%);
  height: 1px;
  overflow: hidden;
  position: absolute;
  white-space: nowrap;
  width: 1px;
}

@media screen and (min-width: 64rem) {
  .pf-chatbot--embedded,
  .pf-chatbot--drawer,
  .pf-chatbot--fullscreen {
    .pf-chatbot__messagebox {
      max-width: 60rem;
      width: 100%;
    }
  }
}

.pf-chatbot.pf-m-compact {
  .pf-chatbot__messagebox {
    padding: var(--pf-t--global--spacer--md);
  }
}



================================================
FILE: packages/module/src/MessageBox/MessageBox.test.tsx
================================================
import React from 'react';
import { render, screen, waitFor } from '@testing-library/react';
import { MessageBox } from './MessageBox';
import userEvent from '@testing-library/user-event';

describe('MessageBox', () => {
  it('should render Message box', () => {
    render(
      <MessageBox>
        <>Chatbot Messages</>
      </MessageBox>
    );
    expect(screen.getByText('Chatbot Messages')).toBeTruthy();
  });

  it('should assign ref to Message box', () => {
    const ref = React.createRef<HTMLDivElement>();
    render(
      <MessageBox ref={ref}>
        <div>Test message content</div>
      </MessageBox>
    );

    expect(ref.current).not.toBeNull();
    expect(ref.current).toBeInstanceOf(HTMLDivElement);
  });
  it('should call onScrollToBottomClick when scroll to top button is clicked', async () => {
    const spy = jest.fn();
    render(
      <MessageBox onScrollToBottomClick={spy}>
        <div>Test message content</div>
      </MessageBox>
    );

    // this forces button to show
    const region = screen.getByRole('region');
    Object.defineProperty(region, 'scrollHeight', { configurable: true, value: 1000 });
    Object.defineProperty(region, 'clientHeight', { configurable: true, value: 500 });
    Object.defineProperty(region, 'scrollTop', { configurable: true, value: 0 });
    region.dispatchEvent(new Event('scroll'));

    await waitFor(() => {
      userEvent.click(screen.getByRole('button', { name: /Jump bottom/i }));
      expect(spy).toHaveBeenCalled();
    });
  });
  it('should call onScrollToTopClick when scroll to top button is clicked', async () => {
    const spy = jest.fn();
    render(
      <MessageBox onScrollToTopClick={spy}>
        <div>Test message content</div>
      </MessageBox>
    );

    // this forces button to show
    const region = screen.getByRole('region');
    Object.defineProperty(region, 'scrollHeight', { configurable: true, value: 1000 });
    Object.defineProperty(region, 'clientHeight', { configurable: true, value: 500 });
    Object.defineProperty(region, 'scrollTop', {
      configurable: true,
      value: 500
    });
    region.dispatchEvent(new Event('scroll'));

    await waitFor(() => {
      userEvent.click(screen.getByRole('button', { name: /Jump top/i }));
      expect(spy).toHaveBeenCalled();
    });
  });
});



================================================
FILE: packages/module/src/MessageBox/MessageBox.tsx
================================================
// ============================================================================
// Chatbot Main - Messages
// ============================================================================
import React from 'react';
import JumpButton from './JumpButton';

export interface MessageBoxProps extends React.HTMLProps<HTMLDivElement> {
  /** Content that can be announced, such as a new message, for screen readers */
  announcement?: string;
  /** Custom aria-label for scrollable portion of message box */
  ariaLabel?: string;
  /** Content to be displayed in the message box */
  children: React.ReactNode;
  /** Custom classname for the MessageBox component */
  className?: string;
  /** Ref applied to message box */
  innerRef?: React.Ref<HTMLDivElement>;
  /** Modifier that controls how content in MessageBox is positioned within the container */
  position?: 'top' | 'bottom';
  /** Click handler for additional logic for when scroll to top jump button is clicked */
  onScrollToTopClick?: () => void;
  /** Click handler for additional logic for when scroll to bottom jump button is clicked */
  onScrollToBottomClick?: () => void;
}

const MessageBoxBase: React.FunctionComponent<MessageBoxProps> = ({
  announcement,
  ariaLabel = 'Scrollable message log',
  children,
  innerRef,
  className,
  position = 'top',
  onScrollToTopClick,
  onScrollToBottomClick,
  ...props
}: MessageBoxProps) => {
  const [atTop, setAtTop] = React.useState(false);
  const [atBottom, setAtBottom] = React.useState(true);
  const [isOverflowing, setIsOverflowing] = React.useState(false);
  const defaultRef = React.useRef<HTMLDivElement>(null);
  let messageBoxRef;
  if (innerRef) {
    messageBoxRef = innerRef;
  } else {
    messageBoxRef = defaultRef;
  }

  // Configure handlers
  const handleScroll = React.useCallback(() => {
    const element = messageBoxRef.current;
    if (element) {
      const { scrollTop, scrollHeight, clientHeight } = element;
      setAtTop(scrollTop === 0);
      setAtBottom(Math.round(scrollTop) + Math.round(clientHeight) >= Math.round(scrollHeight) - 1); // rounding means it could be within a pixel of the bottom
    }
  }, [messageBoxRef]);

  const checkOverflow = React.useCallback(() => {
    const element = messageBoxRef.current;
    if (element) {
      const { scrollHeight, clientHeight } = element;
      setIsOverflowing(scrollHeight >= clientHeight);
    }
  }, [messageBoxRef]);

  const scrollToTop = React.useCallback(() => {
    const element = messageBoxRef.current;
    if (element) {
      element.scrollTo({ top: 0, behavior: 'smooth' });
    }
    onScrollToTopClick && onScrollToTopClick();
  }, [messageBoxRef]);

  const scrollToBottom = React.useCallback(() => {
    const element = messageBoxRef.current;
    if (element) {
      element.scrollTo({ top: element.scrollHeight, behavior: 'smooth' });
    }
    onScrollToBottomClick && onScrollToBottomClick();
  }, [messageBoxRef]);

  // Detect scroll position
  React.useEffect(() => {
    const element = messageBoxRef.current;
    if (element) {
      // Listen for scroll events
      element.addEventListener('scroll', handleScroll);

      // Check initial position and overflow
      handleScroll();
      checkOverflow();

      return () => {
        element.removeEventListener('scroll', handleScroll);
      };
    }
  }, [checkOverflow, handleScroll, messageBoxRef]);

  return (
    <>
      <JumpButton position="top" isHidden={isOverflowing && atTop} onClick={scrollToTop} />
      <div
        role="region"
        tabIndex={0}
        aria-label={ariaLabel}
        className={`pf-chatbot__messagebox ${position === 'bottom' && 'pf-chatbot__messagebox--bottom'} ${className ?? ''}`}
        ref={innerRef ?? messageBoxRef}
        {...props}
      >
        {children}
        <div className="pf-chatbot__messagebox-announcement" aria-live="polite">
          {announcement}
        </div>
      </div>
      <JumpButton position="bottom" isHidden={isOverflowing && atBottom} onClick={scrollToBottom} />
    </>
  );
};

export const MessageBox = React.forwardRef((props: MessageBoxProps, ref: React.Ref<any>) => (
  <MessageBoxBase innerRef={ref} {...props} />
));

export default MessageBox;



================================================
FILE: packages/module/src/PreviewAttachment/index.ts
================================================
export { default } from './PreviewAttachment';

export * from './PreviewAttachment';



================================================
FILE: packages/module/src/PreviewAttachment/PreviewAttachment.test.tsx
================================================
import React from 'react';
import { fireEvent, render, screen } from '@testing-library/react';
import { PreviewAttachment } from './PreviewAttachment';

describe('PreviewAttachment', () => {
  it('should render PreviewAttachment', () => {
    render(
      <PreviewAttachment
        code="Hello world"
        fileName="greetings.txt"
        isModalOpen={true}
        onEdit={jest.fn()}
        handleModalToggle={jest.fn()}
      />
    );
    expect(screen.getByText('Preview attachment')).toBeTruthy();
    expect(screen.getByText('greetings')).toBeTruthy();
    expect(screen.getAllByText('TEXT')).toBeTruthy();
  });

  it('should call onEdit handler when edit button is pressed', () => {
    const onEdit = jest.fn();
    render(
      <PreviewAttachment
        code="Hello world"
        fileName="greetings.txt"
        isModalOpen={true}
        onEdit={onEdit}
        handleModalToggle={jest.fn()}
      />
    );
    fireEvent.click(screen.getByText('Edit'));

    expect(onEdit).toHaveBeenCalled();
  });
  it('should call onDismiss handler when dismiss button is pressed', () => {
    const onDismiss = jest.fn();
    render(
      <PreviewAttachment
        code="Hello world"
        fileName="greetings.txt"
        isModalOpen={true}
        onEdit={jest.fn()}
        handleModalToggle={onDismiss}
      />
    );
    fireEvent.click(screen.getByText('Dismiss'));

    expect(onDismiss).toHaveBeenCalled();
  });
});



================================================
FILE: packages/module/src/PreviewAttachment/PreviewAttachment.tsx
================================================
// ============================================================================
// Preview Attachment - Chatbot Code Snippet Viewer
// ============================================================================
import React from 'react';
import CodeModal from '../CodeModal';
import { ChatbotDisplayMode } from '../Chatbot';

export interface PreviewAttachmentProps {
  /** Text shown in code editor */
  code: string;
  /** Filename, including extension, of file shown in modal */
  fileName: string;
  /** Function called when edit button is clicked */
  onEdit: (event: React.MouseEvent | MouseEvent | KeyboardEvent) => void;
  /** Function called when dismiss button is clicked */
  onDismiss?: (event: React.MouseEvent | MouseEvent | KeyboardEvent) => void;
  /** Function called when modal is toggled */
  handleModalToggle: (event: React.MouseEvent | MouseEvent | KeyboardEvent) => void;
  /** Whether modal is open */
  isModalOpen: boolean;
  /** Title of modal */
  title?: string;
  /** Display mode for the Chatbot parent; this influences the styles applied */
  displayMode?: ChatbotDisplayMode;
  /** Sets modal to compact styling. */
  isCompact?: boolean;
}

export const PreviewAttachment: React.FunctionComponent<PreviewAttachmentProps> = ({
  fileName,
  code,
  handleModalToggle,
  isModalOpen,
  onDismiss = undefined,
  onEdit,
  title = 'Preview attachment',
  displayMode = ChatbotDisplayMode.default,
  isCompact
}: PreviewAttachmentProps) => {
  const handleEdit = (_event: React.MouseEvent | MouseEvent | KeyboardEvent) => {
    handleModalToggle(_event);
    onEdit(_event);
  };

  const handleDismiss = (_event: React.MouseEvent | MouseEvent | KeyboardEvent) => {
    handleModalToggle(_event);
    onDismiss && onDismiss(_event);
  };

  return (
    <CodeModal
      codeEditorControlClassName="pf-chatbot__code-modal--controls"
      code={code}
      fileName={fileName}
      handleModalToggle={handleModalToggle}
      isCopyEnabled
      isLineNumbersVisible={false}
      isModalOpen={isModalOpen}
      onPrimaryAction={handleEdit}
      onSecondaryAction={handleDismiss}
      primaryActionBtn="Edit"
      secondaryActionBtn="Dismiss"
      title={title}
      isReadOnly
      displayMode={displayMode}
      isCompact={isCompact}
    />
  );
};

export default PreviewAttachment;



================================================
FILE: packages/module/src/ResponseActions/index.ts
================================================
export { default } from './ResponseActions';

export * from './ResponseActions';



================================================
FILE: packages/module/src/ResponseActions/ResponseActionButton.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import userEvent from '@testing-library/user-event';
import { DownloadIcon } from '@patternfly/react-icons';
import ResponseActionButton from './ResponseActionButton';

describe('ResponseActionButton', () => {
  it('renders aria-label correctly if not clicked', () => {
    render(<ResponseActionButton icon={<DownloadIcon />} ariaLabel="Download" clickedAriaLabel="Downloaded" />);
    expect(screen.getByRole('button', { name: 'Download' })).toBeTruthy();
  });
  it('renders aria-label correctly if clicked', () => {
    render(
      <ResponseActionButton icon={<DownloadIcon />} ariaLabel="Download" clickedAriaLabel="Downloaded" isClicked />
    );
    expect(screen.getByRole('button', { name: 'Downloaded' })).toBeTruthy();
  });
  it('renders tooltip correctly if not clicked', async () => {
    render(
      <ResponseActionButton icon={<DownloadIcon />} tooltipContent="Download" clickedTooltipContent="Downloaded" />
    );
    expect(screen.getByRole('button', { name: 'Download' })).toBeTruthy();
    // clicking here just triggers the tooltip; in this button, the logic is divorced from whether it is actually clicked
    await userEvent.click(screen.getByRole('button', { name: 'Download' }));
    expect(screen.getByRole('tooltip', { name: 'Download' })).toBeTruthy();
  });
  it('renders tooltip correctly if clicked', async () => {
    render(
      <ResponseActionButton
        icon={<DownloadIcon />}
        tooltipContent="Download"
        clickedTooltipContent="Downloaded"
        isClicked
      />
    );
    expect(screen.getByRole('button', { name: 'Downloaded' })).toBeTruthy();
    // clicking here just triggers the tooltip; in this button, the logic is divorced from whether it is actually clicked
    await userEvent.click(screen.getByRole('button', { name: 'Downloaded' }));
    expect(screen.getByRole('tooltip', { name: 'Downloaded' })).toBeTruthy();
  });
  it('if clicked variant for tooltip is not supplied, it uses the default', async () => {
    render(<ResponseActionButton icon={<DownloadIcon />} tooltipContent="Download" isClicked />);
    // clicking here just triggers the tooltip; in this button, the logic is divorced from whether it is actually clicked
    await userEvent.click(screen.getByRole('button', { name: 'Download' }));
    expect(screen.getByRole('button', { name: 'Download' })).toBeTruthy();
  });
  it('if clicked variant for aria label is not supplied, it uses the default', async () => {
    render(<ResponseActionButton icon={<DownloadIcon />} ariaLabel="Download" isClicked />);
    expect(screen.getByRole('button', { name: 'Download' })).toBeTruthy();
  });
});



================================================
FILE: packages/module/src/ResponseActions/ResponseActionButton.tsx
================================================
import React from 'react';
import { Button, ButtonProps, Icon, Tooltip, TooltipProps } from '@patternfly/react-core';

export interface ResponseActionButtonProps extends ButtonProps {
  /** Aria-label for the button. Defaults to the value of the tooltipContent if none provided */
  ariaLabel?: string;
  /** Aria-label for the button, shown when the button is clicked. Defaults to the value of ariaLabel or tooltipContent if not provided. */
  clickedAriaLabel?: string;
  /** Icon for the button */
  icon: React.ReactNode;
  /** On-click handler for the button */
  onClick?: ((event: MouseEvent | React.MouseEvent<Element, MouseEvent> | KeyboardEvent) => void) | undefined;
  /** Class name for the button */
  className?: string;
  /** Props to control if the attach button should be disabled */
  isDisabled?: boolean;
  /** Content shown in the tooltip */
  tooltipContent?: string;
  /** Content shown in the tooltip when the button is clicked. Defaults to the value of tooltipContent if not provided. */
  clickedTooltipContent?: string;
  /** Props to control the PF Tooltip component */
  tooltipProps?: TooltipProps;
  /** Whether button is in clicked state */
  isClicked?: boolean;
  /** Ref applied to button  */
  innerRef?: React.Ref<HTMLButtonElement>;
}

export const ResponseActionButtonBase: React.FunctionComponent<ResponseActionButtonProps> = ({
  ariaLabel,
  clickedAriaLabel = ariaLabel,
  className,
  icon,
  isDisabled,
  onClick,
  tooltipContent,
  clickedTooltipContent = tooltipContent,
  tooltipProps,
  isClicked = false,
  innerRef,
  ...props
}) => {
  const generateAriaLabel = () => {
    if (ariaLabel) {
      return isClicked ? clickedAriaLabel : ariaLabel;
    }
    return isClicked ? clickedTooltipContent : tooltipContent;
  };

  return (
    <Tooltip
      id={`pf-chatbot__tooltip-response-action-${tooltipContent}`}
      content={isClicked ? clickedTooltipContent : tooltipContent}
      aria-live="polite"
      position="bottom"
      entryDelay={tooltipProps?.entryDelay || 0}
      exitDelay={tooltipProps?.exitDelay || 0}
      distance={tooltipProps?.distance || 8}
      animationDuration={tooltipProps?.animationDuration || 0}
      // prevents VO announcements of both aria label and tooltip
      aria="none"
      {...tooltipProps}
    >
      <Button
        variant="plain"
        className={`pf-chatbot__button--response-action ${isClicked ? 'pf-chatbot__button--response-action-clicked' : ''} ${className ?? ''}`}
        aria-label={generateAriaLabel()}
        icon={
          <Icon isInline size="lg">
            {icon}
          </Icon>
        }
        isDisabled={isDisabled}
        onClick={onClick}
        size="sm"
        ref={innerRef}
        {...props}
      ></Button>
    </Tooltip>
  );
};

const ResponseActionButton = React.forwardRef((props: ResponseActionButtonProps, ref: React.Ref<HTMLButtonElement>) => (
  <ResponseActionButtonBase innerRef={ref} {...props} />
));

export default ResponseActionButton;



================================================
FILE: packages/module/src/ResponseActions/ResponseActions.scss
================================================
.pf-chatbot__response-actions {
  display: grid;
  gap: var(--pf-t--global--spacer--xs);
  grid-template-columns: repeat(auto-fit, minmax(0, max-content));

  .pf-chatbot__button--response-action.pf-v6-c-button.pf-m-plain.pf-m-small {
    --pf-v6-c-button__icon--Color: var(--pf-t--global--icon--color--subtle);
    border-radius: var(--pf-t--global--border--radius--pill);
    width: 2.3125rem;
    height: 2.3125rem;
    display: flex;
    align-items: center;
    justify-content: center;

    &:hover {
      --pf-v6-c-button__icon--Color: var(--pf-t--global--icon--color--subtle);
    }
    &:focus {
      --pf-v6-c-button--hover--BackgroundColor: var(--pf-t--global--background--color--action--plain--alt--clicked);
      --pf-v6-c-button__icon--Color: var(--pf-t--global--icon--color--regular);
    }
  }
}

.pf-v6-c-button.pf-chatbot__button--response-action-clicked.pf-v6-c-button.pf-m-plain.pf-m-small {
  --pf-v6-c-button--m-plain--BackgroundColor: var(--pf-t--global--background--color--action--plain--alt--clicked);
  --pf-v6-c-button__icon--Color: var(--pf-t--global--icon--color--regular);
}



================================================
FILE: packages/module/src/ResponseActions/ResponseActions.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import ResponseActions from './ResponseActions';
import userEvent from '@testing-library/user-event';
import { DownloadIcon, InfoCircleIcon, RedoIcon } from '@patternfly/react-icons';
import Message from '../Message';

const ALL_ACTIONS = [
  { type: 'positive', label: 'Good response', clickedLabel: 'Response recorded' },
  { type: 'negative', label: 'Bad response', clickedLabel: 'Response recorded' },
  { type: 'copy', label: 'Copy', clickedLabel: 'Copied' },
  { type: 'share', label: 'Share', clickedLabel: 'Shared' },
  { type: 'listen', label: 'Listen', clickedLabel: 'Listening' }
];

const CUSTOM_ACTIONS = [
  {
    regenerate: {
      ariaLabel: 'Regenerate',
      clickedAriaLabel: 'Regenerated',
      onClick: jest.fn(),
      tooltipContent: 'Regenerate',
      clickedTooltipContent: 'Regenerated',
      icon: <RedoIcon />
    },
    download: {
      ariaLabel: 'Download',
      clickedAriaLabel: 'Downloaded',
      onClick: jest.fn(),
      tooltipContent: 'Download',
      clickedTooltipContent: 'Downloaded',
      icon: <DownloadIcon />
    },
    info: {
      ariaLabel: 'Info',
      onClick: jest.fn(),
      tooltipContent: 'Info',
      icon: <InfoCircleIcon />
    }
  }
];

const ALL_ACTIONS_DATA_TEST = [
  { type: 'positive', label: 'Good response', dataTestId: 'positive' },
  { type: 'negative', label: 'Bad response', dataTestId: 'negative' },
  { type: 'copy', label: 'Copy', dataTestId: 'copy' },
  { type: 'share', label: 'Share', dataTestId: 'share' },
  { type: 'listen', label: 'Listen', dataTestId: 'listen' }
];

describe('ResponseActions', () => {
  afterEach(() => {
    jest.clearAllMocks();
  });
  it('should handle click within group of buttons correctly', async () => {
    render(
      <ResponseActions
        actions={{
          positive: { onClick: jest.fn() },
          negative: { onClick: jest.fn() },
          copy: { onClick: jest.fn() },
          share: { onClick: jest.fn() },
          listen: { onClick: jest.fn() }
        }}
      />
    );
    const goodBtn = screen.getByRole('button', { name: 'Good response' });
    const badBtn = screen.getByRole('button', { name: 'Bad response' });
    const copyBtn = screen.getByRole('button', { name: 'Copy' });
    const shareBtn = screen.getByRole('button', { name: 'Share' });
    const listenBtn = screen.getByRole('button', { name: 'Listen' });
    const buttons = [goodBtn, badBtn, copyBtn, shareBtn, listenBtn];
    buttons.forEach((button) => {
      expect(button).toBeTruthy();
    });
    await userEvent.click(goodBtn);
    expect(screen.getByRole('button', { name: 'Response recorded' })).toHaveClass(
      'pf-chatbot__button--response-action-clicked'
    );
    let unclickedButtons = buttons.filter((button) => button !== goodBtn);
    unclickedButtons.forEach((button) => {
      expect(button).not.toHaveClass('pf-chatbot__button--response-action-clicked');
    });
    await userEvent.click(badBtn);
    expect(screen.getByRole('button', { name: 'Response recorded' })).toHaveClass(
      'pf-chatbot__button--response-action-clicked'
    );
    unclickedButtons = buttons.filter((button) => button !== badBtn);
    unclickedButtons.forEach((button) => {
      expect(button).not.toHaveClass('pf-chatbot__button--response-action-clicked');
    });
  });
  it('should handle click outside of group of buttons correctly', async () => {
    // using message just so we have something outside the group that's rendered
    render(
      <Message
        name="Bot"
        role="bot"
        avatar=""
        content="I updated your account with those settings. You're ready to set up your first dashboard!"
        actions={{
          positive: {},
          negative: {}
        }}
      />
    );
    const goodBtn = screen.getByRole('button', { name: 'Good response' });
    const badBtn = screen.getByRole('button', { name: 'Bad response' });
    expect(goodBtn).toBeTruthy();
    expect(badBtn).toBeTruthy();

    await userEvent.click(goodBtn);
    expect(screen.getByRole('button', { name: 'Response recorded' })).toHaveClass(
      'pf-chatbot__button--response-action-clicked'
    );
    expect(badBtn).not.toHaveClass('pf-chatbot__button--response-action-clicked');

    await userEvent.click(badBtn);
    expect(screen.getByRole('button', { name: 'Response recorded' })).toHaveClass(
      'pf-chatbot__button--response-action-clicked'
    );
    expect(goodBtn).not.toHaveClass('pf-chatbot__button--response-action-clicked');
    await userEvent.click(
      screen.getByText("I updated your account with those settings. You're ready to set up your first dashboard!")
    );
    expect(goodBtn).not.toHaveClass('pf-chatbot__button--response-action-clicked');
    expect(badBtn).not.toHaveClass('pf-chatbot__button--response-action-clicked');
  });
  it('should render buttons correctly', () => {
    ALL_ACTIONS.forEach(({ type, label }) => {
      render(<ResponseActions actions={{ [type]: { onClick: jest.fn() } }} />);
      expect(screen.getByRole('button', { name: label })).toBeTruthy();
    });
  });

  it('should be able to call onClick correctly', async () => {
    ALL_ACTIONS.forEach(async ({ type, label }) => {
      const spy = jest.fn();
      render(<ResponseActions actions={{ [type]: { onClick: spy } }} />);
      await userEvent.click(screen.getByRole('button', { name: label }));
      expect(spy).toHaveBeenCalledTimes(1);
    });
  });

  it('should swap clicked and non-clicked aria labels on click', async () => {
    ALL_ACTIONS.forEach(async ({ type, label, clickedLabel }) => {
      render(<ResponseActions actions={{ [type]: { onClick: jest.fn() } }} />);
      expect(screen.getByRole('button', { name: label })).toBeTruthy();
      await userEvent.click(screen.getByRole('button', { name: label }));
      expect(screen.getByRole('button', { name: clickedLabel })).toBeTruthy();
    });
  });

  it('should swap clicked and non-clicked tooltips on click', async () => {
    ALL_ACTIONS.forEach(async ({ type, label, clickedLabel }) => {
      render(<ResponseActions actions={{ [type]: { onClick: jest.fn() } }} />);
      expect(screen.getByRole('button', { name: label })).toBeTruthy();
      await userEvent.click(screen.getByRole('button', { name: label }));
      expect(screen.getByRole('tooltip', { name: clickedLabel })).toBeTruthy();
    });
  });

  it('should be able to change aria labels', () => {
    const actions = [
      { type: 'positive', ariaLabel: 'Thumbs up' },
      { type: 'negative', ariaLabel: 'Thumbs down' },
      { type: 'copy', ariaLabel: 'Copy the message' },
      { type: 'share', ariaLabel: 'Share it with friends' },
      { type: 'listen', ariaLabel: 'Listen up' }
    ];
    actions.forEach(({ type, ariaLabel }) => {
      render(<ResponseActions actions={{ [type]: { onClick: jest.fn(), ariaLabel } }} />);
      expect(screen.getByRole('button', { name: ariaLabel })).toBeTruthy();
    });
  });

  it('should be able to disable buttons', () => {
    ALL_ACTIONS.forEach(({ type, label }) => {
      render(<ResponseActions actions={{ [type]: { onClick: jest.fn(), isDisabled: true } }} />);
      expect(screen.getByRole('button', { name: label })).toBeDisabled();
    });
  });

  it('should be able to add class to buttons', () => {
    ALL_ACTIONS.forEach(({ type, label }) => {
      render(<ResponseActions actions={{ [type]: { onClick: jest.fn(), className: 'test' } }} />);
      expect(screen.getByRole('button', { name: label })).toHaveClass('test');
    });
  });

  it('should be able to add custom attributes to buttons', () => {
    ALL_ACTIONS_DATA_TEST.forEach(({ type, dataTestId }) => {
      render(<ResponseActions actions={{ [type]: { onClick: jest.fn(), 'data-testid': dataTestId } }} />);
      expect(screen.getByTestId(dataTestId)).toBeTruthy();
    });
  });

  it('should be able to add custom actions', () => {
    CUSTOM_ACTIONS.forEach((action) => {
      const key = Object.keys(action)[0];
      render(
        <ResponseActions
          actions={{
            [key]: {
              tooltipContent: action[key].tooltipContent,
              onClick: action[key].onClick,
              // doing this just because it's easier to test without a regex for the button name
              ariaLabel: action[key].ariaLabel.toLowerCase(),
              icon: action[key].icon,
              'data-testid': action[key]
            }
          }}
        />
      );
      expect(screen.getByRole('button', { name: key })).toBeTruthy();
      expect(screen.getByTestId(action[key])).toBeTruthy();
    });
  });
});



================================================
FILE: packages/module/src/ResponseActions/ResponseActions.tsx
================================================
import React from 'react';
import {
  ExternalLinkAltIcon,
  VolumeUpIcon,
  OutlinedThumbsUpIcon,
  OutlinedThumbsDownIcon,
  OutlinedCopyIcon
} from '@patternfly/react-icons';
import ResponseActionButton from './ResponseActionButton';
import { ButtonProps, TooltipProps } from '@patternfly/react-core';

export interface ActionProps extends Omit<ButtonProps, 'ref'> {
  /** Aria-label for the button */
  ariaLabel?: string;
  /** Aria-label for the button, shown when the button is clicked. */
  clickedAriaLabel?: string;
  /** On-click handler for the button */
  onClick?: ((event: MouseEvent | React.MouseEvent<Element, MouseEvent> | KeyboardEvent) => void) | undefined;
  /** Class name for the button */
  className?: string;
  /** Props to control if the attach button should be disabled */
  isDisabled?: boolean;
  /** Content shown in the tooltip */
  tooltipContent?: string;
  /** Content shown in the tooltip when the button is clicked. */
  clickedTooltipContent?: string;
  /** Props to control the PF Tooltip component */
  tooltipProps?: TooltipProps;
  /** Icon for custom response action */
  icon?: React.ReactNode;
  /** Ref for response action button */
  ref?: React.Ref<HTMLButtonElement>;
  /** Whether content launched by button, such as the feedback form, is expanded */
  'aria-expanded'?: boolean;
  /** Id for content controlled by the button, such as the feedback form */
  'aria-controls'?: string;
}

type ExtendedActionProps = ActionProps & {
  [key: string]: any;
};
export interface ResponseActionProps {
  /** Props for message actions, such as feedback (positive or negative), copy button, share, and listen */
  actions: Record<string, ExtendedActionProps | undefined> & {
    positive?: ActionProps;
    negative?: ActionProps;
    copy?: ActionProps;
    share?: ActionProps;
    listen?: ActionProps;
  };
}

export const ResponseActions: React.FunctionComponent<ResponseActionProps> = ({ actions }) => {
  const [activeButton, setActiveButton] = React.useState<string>();
  const { positive, negative, copy, share, listen, ...additionalActions } = actions;
  const responseActions = React.useRef<HTMLDivElement>(null);

  React.useEffect(() => {
    const handleClickOutside = (e) => {
      if (responseActions.current && !responseActions.current.contains(e.target)) {
        setActiveButton(undefined);
      }
    };
    window.addEventListener('click', handleClickOutside);

    return () => {
      window.removeEventListener('click', handleClickOutside);
    };
  }, []);

  const handleClick = (
    e: MouseEvent | React.MouseEvent<Element, MouseEvent> | KeyboardEvent,
    id: string,
    onClick?: (event: MouseEvent | React.MouseEvent<Element, MouseEvent> | KeyboardEvent) => void
  ) => {
    setActiveButton(id);
    onClick && onClick(e);
  };

  return (
    <div ref={responseActions} className="pf-chatbot__response-actions">
      {positive && (
        <ResponseActionButton
          {...positive}
          ariaLabel={positive.ariaLabel ?? 'Good response'}
          clickedAriaLabel={positive.ariaLabel ?? 'Response recorded'}
          onClick={(e) => handleClick(e, 'positive', positive.onClick)}
          className={positive.className}
          isDisabled={positive.isDisabled}
          tooltipContent={positive.tooltipContent ?? 'Good response'}
          clickedTooltipContent={positive.clickedTooltipContent ?? 'Response recorded'}
          tooltipProps={positive.tooltipProps}
          icon={<OutlinedThumbsUpIcon />}
          isClicked={activeButton === 'positive'}
          ref={positive.ref}
          aria-expanded={positive['aria-expanded']}
          aria-controls={positive['aria-controls']}
        ></ResponseActionButton>
      )}
      {negative && (
        <ResponseActionButton
          {...negative}
          ariaLabel={negative.ariaLabel ?? 'Bad response'}
          clickedAriaLabel={negative.ariaLabel ?? 'Response recorded'}
          onClick={(e) => handleClick(e, 'negative', negative.onClick)}
          className={negative.className}
          isDisabled={negative.isDisabled}
          tooltipContent={negative.tooltipContent ?? 'Bad response'}
          clickedTooltipContent={negative.clickedTooltipContent ?? 'Response recorded'}
          tooltipProps={negative.tooltipProps}
          icon={<OutlinedThumbsDownIcon />}
          isClicked={activeButton === 'negative'}
          ref={negative.ref}
          aria-expanded={negative['aria-expanded']}
          aria-controls={negative['aria-controls']}
        ></ResponseActionButton>
      )}
      {copy && (
        <ResponseActionButton
          {...copy}
          ariaLabel={copy.ariaLabel ?? 'Copy'}
          clickedAriaLabel={copy.ariaLabel ?? 'Copied'}
          onClick={(e) => handleClick(e, 'copy', copy.onClick)}
          className={copy.className}
          isDisabled={copy.isDisabled}
          tooltipContent={copy.tooltipContent ?? 'Copy'}
          clickedTooltipContent={copy.clickedTooltipContent ?? 'Copied'}
          tooltipProps={copy.tooltipProps}
          icon={<OutlinedCopyIcon />}
          isClicked={activeButton === 'copy'}
          ref={copy.ref}
          aria-expanded={copy['aria-expanded']}
          aria-controls={copy['aria-controls']}
        ></ResponseActionButton>
      )}
      {share && (
        <ResponseActionButton
          {...share}
          ariaLabel={share.ariaLabel ?? 'Share'}
          clickedAriaLabel={share.ariaLabel ?? 'Shared'}
          onClick={(e) => handleClick(e, 'share', share.onClick)}
          className={share.className}
          isDisabled={share.isDisabled}
          tooltipContent={share.tooltipContent ?? 'Share'}
          clickedTooltipContent={share.clickedTooltipContent ?? 'Shared'}
          tooltipProps={share.tooltipProps}
          icon={<ExternalLinkAltIcon />}
          isClicked={activeButton === 'share'}
          ref={share.ref}
          aria-expanded={share['aria-expanded']}
          aria-controls={share['aria-controls']}
        ></ResponseActionButton>
      )}
      {listen && (
        <ResponseActionButton
          {...listen}
          ariaLabel={listen.ariaLabel ?? 'Listen'}
          clickedAriaLabel={listen.ariaLabel ?? 'Listening'}
          onClick={(e) => handleClick(e, 'listen', listen.onClick)}
          className={listen.className}
          isDisabled={listen.isDisabled}
          tooltipContent={listen.tooltipContent ?? 'Listen'}
          clickedTooltipContent={listen.clickedTooltipContent ?? 'Listening'}
          tooltipProps={listen.tooltipProps}
          icon={<VolumeUpIcon />}
          isClicked={activeButton === 'listen'}
          ref={listen.ref}
          aria-expanded={listen['aria-expanded']}
          aria-controls={listen['aria-controls']}
        ></ResponseActionButton>
      )}
      {Object.keys(additionalActions).map((action) => (
        <ResponseActionButton
          {...additionalActions[action]}
          key={action}
          ariaLabel={additionalActions[action]?.ariaLabel}
          clickedAriaLabel={additionalActions[action]?.clickedAriaLabel}
          onClick={(e) => handleClick(e, action, additionalActions[action]?.onClick)}
          className={additionalActions[action]?.className}
          isDisabled={additionalActions[action]?.isDisabled}
          tooltipContent={additionalActions[action]?.tooltipContent}
          tooltipProps={additionalActions[action]?.tooltipProps}
          clickedTooltipContent={additionalActions[action]?.clickedTooltipContent}
          icon={additionalActions[action]?.icon}
          isClicked={activeButton === action}
          ref={additionalActions[action]?.ref}
          aria-expanded={additionalActions[action]?.['aria-expanded']}
          aria-controls={additionalActions[action]?.['aria-controls']}
        />
      ))}
    </div>
  );
};

export default ResponseActions;



================================================
FILE: packages/module/src/Settings/index.ts
================================================
export { default } from './SettingsForm';

export * from './SettingsForm';



================================================
FILE: packages/module/src/Settings/Settings.scss
================================================
.pf-chatbot__settings-form-container {
  width: 100%;
  display: flex;
  justify-content: center;
  overflow: scroll;
}

.pf-chatbot__settings-form {
  display: flex;
  flex-direction: column;
  max-width: 60rem;
  flex: 1;
}

.pf-chatbot__settings-form-row {
  font-size: var(--pf-t--global--font--size--body--lg);
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid var(--pf-t--global--border--color--default);
  padding: var(--pf-t--global--spacer--lg);
  font-weight: var(--pf-t--global--font--weight--body--bold);
}

.pf-chatbot__settings-form-row:last-of-type {
  border-bottom: 0px;
}

.pf-chatbot__settings--title {
  font-family: var(--pf-t--global--font--family--heading);
  font-size: var(--pf-t--global--font--size--xl);
  font-weight: var(--pf-t--global--font--weight--body--bold);
  text-align: center;
}

.pf-chatbot__settings-form-container.pf-m-compact {
  .pf-chatbot__settings-form-row {
    padding: var(--pf-t--global--spacer--md);
    font-size: var(--pf-t--global--font--size--body--md);
  }
}

.pf-chatbot__header.pf-m-compact {
  padding-inline-start: var(--pf-t--global--spacer--md);
}



================================================
FILE: packages/module/src/Settings/SettingsForm.test.tsx
================================================
import React from 'react';
import { Button } from '@patternfly/react-core';
import { render, screen } from '@testing-library/react';
import { SettingsForm } from './SettingsForm';
import '@testing-library/jest-dom';

describe('SettingsForm', () => {
  it('should render settingsForm with custom classname', () => {
    const { container } = render(<SettingsForm className="custom-settings" />);
    expect(container.querySelector('.custom-settings')).toBeTruthy();
  });

  it('should render settingsForm with fields', () => {
    const fields = [
      {
        id: 'archived-chat',
        label: 'Archive chat',
        field: (
          <Button id="archived-chat" variant="secondary">
            Archive chat
          </Button>
        )
      }
    ];
    render(<SettingsForm fields={fields} />);

    expect(screen.getByRole('button', { name: 'Archive chat' })).toBeTruthy();
  });

  it('should render settingsForm with isCompact', () => {
    const fields = [
      {
        id: 'archived-chat',
        label: 'Archive chat',
        field: (
          <Button id="archived-chat" variant="secondary">
            Archive chat
          </Button>
        )
      }
    ];
    render(<SettingsForm data-testid="settings-form" fields={fields} isCompact />);
    expect(screen.getByTestId('settings-form')).toHaveClass('pf-m-compact');
  });
});



================================================
FILE: packages/module/src/Settings/SettingsForm.tsx
================================================
import React from 'react';

export interface SettingsFormProps {
  /** Class applied to form container */
  className?: string;
  /** Array of fields to display in the settings layout */
  fields?: { id: string; label: string; field: React.ReactElement }[];
  /** Sets form to compact styling. */
  isCompact?: boolean;
}

export const SettingsForm: React.FunctionComponent<SettingsFormProps> = ({
  className,
  fields = [],
  isCompact,
  ...props
}) => (
  <div
    className={`pf-chatbot__settings-form-container ${isCompact ? 'pf-m-compact' : ''} ${className ? ` ${className}` : ''}`}
    {...props}
  >
    <form className="pf-chatbot__settings-form">
      {fields.map((field) => (
        <div className="pf-chatbot__settings-form-row" key={field.label}>
          <label className="pf-chatbot__settings-label" htmlFor={field.id}>
            {field.label}
          </label>
          {field.field}
        </div>
      ))}
    </form>
  </div>
);

export default SettingsForm;



================================================
FILE: packages/module/src/SourceDetailsMenuItem/index.ts
================================================
export { default } from './SourceDetailsMenuItem';
export * from './SourceDetailsMenuItem';



================================================
FILE: packages/module/src/SourceDetailsMenuItem/SourceDetailsMenuItem.scss
================================================
.pf-chatbot__source-details-subhead {
  color: var(--pf-t--global--text--color--subtle);
  font-size: var(--pf-t--global--icon--size--font--xs);
  font-weight: var(--pf-t--global--font--weight--body--bold);
}

.pf-chatbot__source-details-heading {
  font-size: var(--pf-t--global--font--size--body--default);
  word-wrap: break-word;
}

.pf-chatbot__source-details-icon {
  width: 100% !important;
}

// this is only used in demo code
.pf-chatbot__source-details-icon > .pf-v6-c-icon__content > svg {
  width: 24px;
  color: var(--pf-t--global--icon--color--status--custom--default);
}
.pf-chatbot-source-details-dropdown-item:hover {
  .pf-chatbot__source-details-icon > .pf-v6-c-icon__content > svg {
    color: var(--pf-t--global--icon--color--status--custom--hover);
  }
}

.pf-chatbot__source-details {
  flex-direction: row;
}

.pf-chatbot__source-details-text {
  max-width: 20rem;
}



================================================
FILE: packages/module/src/SourceDetailsMenuItem/SourceDetailsMenuItem.tsx
================================================
import React from 'react';
import { Icon, Flex, Stack, StackItem } from '@patternfly/react-core';

export interface SourceDetailsMenuItemProps extends React.HTMLProps<HTMLDivElement> {
  /** Icon */
  icon: React.ReactNode;
  /** Name of source */
  name: string;
  /** Description of source */
  type?: string;
}

export const SourceDetailsMenuItem: React.FunctionComponent<SourceDetailsMenuItemProps> = ({
  icon,
  name,
  type,
  ...props
}: SourceDetailsMenuItemProps) => (
  <Flex className="pf-chatbot__source-details" gap={{ default: 'gapSm' }} {...props}>
    <Flex
      justifyContent={{ default: 'justifyContentCenter' }}
      alignItems={{ default: 'alignItemsCenter' }}
      alignSelf={{ default: 'alignSelfCenter' }}
    >
      <Icon className="pf-chatbot__source-details-icon">{icon}</Icon>
    </Flex>
    <Stack className="pf-chatbot__source-details-text">
      <StackItem>
        <span className="pf-chatbot__source-details-heading">{name}</span>
      </StackItem>
      {type && <StackItem className="pf-chatbot__source-details-subhead">{type}</StackItem>}
    </Stack>
  </Flex>
);

export default SourceDetailsMenuItem;



================================================
FILE: packages/module/src/SourcesCard/index.ts
================================================
export { default } from './SourcesCard';

export * from './SourcesCard';



================================================
FILE: packages/module/src/SourcesCard/SourcesCard.scss
================================================
.pf-chatbot__source {
  display: flex;
  flex-direction: column;
  gap: var(--pf-t--global--spacer--sm);
  padding-block-start: var(--pf-t--global--spacer--sm);
  max-width: 22.5rem;

  a {
    color: var(--pf-t--global--text--color--link--default) !important;
    -webkit-text-decoration: var(--pf-t--global--text-decoration--link--line--default) !important;
    text-decoration: var(--pf-t--global--text-decoration--link--line--default) !important;
  }
}

.pf-chatbot__sources-card {
  box-shadow: var(--pf-t--global--box-shadow--sm);
}

.pf-chatbot__sources-card-body-text {
  display: block;
  display: -webkit-box;
  height: 2.8125rem;
  -webkit-line-clamp: 2;
  line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
  text-overflow: ellipsis;
}

.pf-chatbot__sources-card-footer-container {
  border-top: var(--pf-t--global--border--width--regular) solid var(--pf-t--global--border--color--default);
  padding: var(--pf-t--global--spacer--sm) var(--pf-t--global--spacer--md) var(--pf-t--global--spacer--sm)
    var(--pf-t--global--spacer--sm) !important;
  .pf-chatbot__sources-card-footer {
    display: flex;
    align-items: center;

    &-buttons {
      display: flex;
      gap: var(--pf-t--global--spacer--xs);
      align-items: center;
      justify-content: space-between;
      flex: 1;

      .pf-v6-c-button {
        border-radius: var(--pf-t--global--border--radius--pill);
        padding: var(--pf-t--global--spacer--sm);
        width: 2.31rem;
        height: 2.31rem;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      button:disabled,
      button[disabled] {
        .pf-v6-c-icon__content {
          color: var(--pf-t--global--icon--color--disabled);
        }
      }
      .pf-v6-c-button__text {
        display: flex;
        align-items: center;
      }
      // Interactive states
      .pf-v6-c-button:hover,
      .pf-v6-c-button:focus {
        .pf-v6-c-button__icon {
          color: var(--pf-t--global--icon--color--regular);
        }
      }
      .pf-v6-c-button__icon {
        color: var(--pf-t--global--icon--color--subtle);
      }
    }
  }
}

.pf-v6-c-card.pf-m-compact.pf-chatbot__sources-card {
  .pf-v6-c-card__footer.pf-chatbot__sources-card-footer-container {
    border-top: var(--pf-t--global--border--width--regular) solid var(--pf-t--global--border--color--default);
    padding: var(--pf-t--global--spacer--xs) var(--pf-t--global--spacer--sm) var(--pf-t--global--spacer--xs)
      var(--pf-t--global--spacer--xs) !important;
  }
}



================================================
FILE: packages/module/src/SourcesCard/SourcesCard.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import '@testing-library/jest-dom';
import SourcesCard from './SourcesCard';

describe('SourcesCard', () => {
  it('should render card correctly if one source with only a link is passed in', () => {
    render(<SourcesCard sources={[{ link: '' }]} />);
    expect(screen.getByText('1 source')).toBeTruthy();
    expect(screen.getByText('Source 1')).toBeTruthy();
    // no buttons or navigation when there is only 1 source
    expect(screen.queryByRole('button')).toBeFalsy();
    expect(screen.queryByText('1/1')).toBeFalsy();
  });

  it('should render card correctly if one source with a title is passed in', () => {
    render(<SourcesCard sources={[{ title: 'How to make an apple pie', link: '' }]} />);
    expect(screen.getByText('1 source')).toBeTruthy();
    expect(screen.getByText('How to make an apple pie')).toBeTruthy();
  });

  it('should render card correctly if one source with a body is passed in', () => {
    render(<SourcesCard sources={[{ link: '', body: 'To make an apple pie, you must first...' }]} />);
    expect(screen.getByText('1 source')).toBeTruthy();
    expect(screen.getByText('To make an apple pie, you must first...')).toBeTruthy();
  });

  it('should render card correctly if one source with a title and body is passed in', () => {
    render(
      <SourcesCard
        sources={[{ title: 'How to make an apple pie', link: '', body: 'To make an apple pie, you must first...' }]}
      />
    );
    expect(screen.getByText('1 source')).toBeTruthy();
    expect(screen.getByText('How to make an apple pie')).toBeTruthy();
    expect(screen.getByText('To make an apple pie, you must first...')).toBeTruthy();
  });

  it('should render multiple cards correctly', () => {
    render(
      <SourcesCard
        sources={[
          { title: 'How to make an apple pie', link: '' },
          { title: 'How to make cookies', link: '' }
        ]}
      />
    );
    expect(screen.getByText('2 sources')).toBeTruthy();
    expect(screen.getByText('How to make an apple pie')).toBeTruthy();
    expect(screen.getByText('1/2')).toBeTruthy();
    screen.getByRole('button', { name: /Go to previous page/i });
    screen.getByRole('button', { name: /Go to next page/i });
  });

  it('should navigate between cards correctly', async () => {
    render(
      <SourcesCard
        sources={[
          { title: 'How to make an apple pie', link: '' },
          { title: 'How to make cookies', link: '' }
        ]}
      />
    );
    expect(screen.getByText('How to make an apple pie')).toBeTruthy();
    expect(screen.getByText('1/2')).toBeTruthy();
    expect(screen.getByRole('button', { name: /Go to previous page/i })).toBeDisabled();
    await userEvent.click(screen.getByRole('button', { name: /Go to next page/i }));
    expect(screen.queryByText('How to make an apple pie')).toBeFalsy();
    expect(screen.getByText('How to make cookies')).toBeTruthy();
    expect(screen.getByText('2/2')).toBeTruthy();
    expect(screen.getByRole('button', { name: /Go to previous page/i })).toBeEnabled();
    expect(screen.getByRole('button', { name: /Go to next page/i })).toBeDisabled();
  });

  it('should apply className appropriately', () => {
    render(
      <SourcesCard
        sources={[
          { title: 'How to make an apple pie', link: '' },
          { title: 'How to make cookies', link: '' }
        ]}
        className="test"
      />
    );
    const element = screen.getByRole('navigation');
    expect(element).toHaveClass('test');
  });

  it('should disable pagination appropriately', () => {
    render(
      <SourcesCard
        sources={[
          { title: 'How to make an apple pie', link: '' },
          { title: 'How to make cookies', link: '' }
        ]}
        isDisabled
      />
    );
    expect(screen.getByRole('button', { name: /Go to previous page/i })).toBeDisabled();
    expect(screen.getByRole('button', { name: /Go to next page/i })).toBeDisabled();
  });

  it('should render navigation aria label appropriately', () => {
    render(
      <SourcesCard
        sources={[
          { title: 'How to make an apple pie', link: '' },
          { title: 'How to make cookies', link: '' }
        ]}
      />
    );
    expect(screen.getByRole('navigation', { name: /Pagination/i })).toBeTruthy();
  });

  it('should change paginationAriaLabel appropriately', () => {
    render(
      <SourcesCard
        sources={[
          { title: 'How to make an apple pie', link: '' },
          { title: 'How to make cookies', link: '' }
        ]}
        paginationAriaLabel="Navegación"
      />
    );
    expect(screen.getByRole('navigation', { name: /Navegación/i })).toBeTruthy();
  });

  it('should change sourceWord appropriately', () => {
    render(<SourcesCard sources={[{ title: 'How to make an apple pie', link: '' }]} sourceWord={'fuente'} />);
    expect(screen.getByText('1 fuente')).toBeTruthy();
  });

  it('should sourceWordPlural appropriately', () => {
    render(
      <SourcesCard
        sources={[
          { title: 'How to make an apple pie', link: '' },
          { title: 'How to make cookies', link: '' }
        ]}
        sourceWordPlural={'fuentes'}
      />
    );
    expect(screen.getByText('2 fuentes')).toBeTruthy();
  });

  it('should change toNextPageAriaLabel appropriately', () => {
    render(
      <SourcesCard
        sources={[
          { title: 'How to make an apple pie', link: '' },
          { title: 'How to make cookies', link: '' }
        ]}
        toNextPageAriaLabel="Pase a la siguiente página"
      />
    );
    expect(screen.getByRole('button', { name: /Pase a la siguiente página/i })).toBeTruthy();
  });

  it('should change toPreviousPageAriaLabel appropriately', () => {
    render(
      <SourcesCard
        sources={[
          { title: 'How to make an apple pie', link: '' },
          { title: 'How to make cookies', link: '' }
        ]}
        toPreviousPageAriaLabel="Presione para regresar a la página anterior"
      />
    );
    expect(screen.getByRole('button', { name: /Presione para regresar a la página anterior/i })).toBeTruthy();
  });

  it('should call onNextClick appropriately', async () => {
    const spy = jest.fn();
    render(
      <SourcesCard
        sources={[
          { title: 'How to make an apple pie', link: '' },
          { title: 'How to make cookies', link: '' }
        ]}
        onNextClick={spy}
      />
    );
    await userEvent.click(screen.getByRole('button', { name: /Go to next page/i }));
    expect(spy).toHaveBeenCalled();
  });

  it('should call onPreviousClick appropriately', async () => {
    const spy = jest.fn();
    render(
      <SourcesCard
        sources={[
          { title: 'How to make an apple pie', link: '' },
          { title: 'How to make cookies', link: '' }
        ]}
        onPreviousClick={spy}
      />
    );
    await userEvent.click(screen.getByRole('button', { name: /Go to next page/i }));
    await userEvent.click(screen.getByRole('button', { name: /Go to previous page/i }));
    expect(spy).toHaveBeenCalled();
  });

  it('should call onSetPage appropriately', async () => {
    const spy = jest.fn();
    render(
      <SourcesCard
        sources={[
          { title: 'How to make an apple pie', link: '' },
          { title: 'How to make cookies', link: '' }
        ]}
        onSetPage={spy}
      />
    );
    await userEvent.click(screen.getByRole('button', { name: /Go to next page/i }));
    expect(spy).toHaveBeenCalledTimes(1);
    await userEvent.click(screen.getByRole('button', { name: /Go to previous page/i }));
    expect(spy).toHaveBeenCalledTimes(2);
  });

  it('should handle showMore appropriately', async () => {
    render(
      <SourcesCard
        sources={[
          {
            title: 'Getting started with Red Hat OpenShift',
            link: '#',
            body: 'Red Hat OpenShift on IBM Cloud is a managed offering to create your own cluster of compute hosts where you can deploy and manage containerized apps on IBM Cloud ...',
            hasShowMore: true
          },
          {
            title: 'Azure Red Hat OpenShift documentation',
            link: '#',
            body: 'Microsoft Azure Red Hat OpenShift allows you to deploy a production ready Red Hat OpenShift cluster in Azure ...'
          },
          {
            title: 'OKD Documentation: Home',
            link: '#',
            body: 'OKD is a distribution of Kubernetes optimized for continuous application development and multi-tenant deployment. OKD also serves as the upstream code base upon ...'
          }
        ]}
      />
    );
    expect(screen.getByRole('region')).toHaveAttribute('class', 'pf-v6-c-expandable-section__content');
  });
});



================================================
FILE: packages/module/src/SourcesCard/SourcesCard.tsx
================================================
// ============================================================================
// Chatbot Main - Messages - Sources Card
// ============================================================================
import React from 'react';

// Import PatternFly components
import {
  Button,
  ButtonVariant,
  Card,
  CardBody,
  CardFooter,
  CardProps,
  CardTitle,
  ExpandableSection,
  ExpandableSectionVariant,
  Icon,
  pluralize,
  Truncate
} from '@patternfly/react-core';
import { ExternalLinkSquareAltIcon } from '@patternfly/react-icons';

export interface SourcesCardProps extends CardProps {
  /** Additional classes for the pagination navigation container. */
  className?: string;
  /** Flag indicating if the pagination is disabled. */
  isDisabled?: boolean;
  /** @deprecated ofWord has been deprecated. Label for the English word "of." */
  ofWord?: string;
  /** Accessible label for the pagination component. */
  paginationAriaLabel?: string;
  /** Content rendered inside the paginated card */
  sources: {
    title?: string;
    link: string;
    body?: React.ReactNode | string;
    isExternal?: boolean;
    hasShowMore?: boolean;
  }[];
  /** Label for the English word "source" */
  sourceWord?: string;
  /** Plural for sourceWord */
  sourceWordPlural?: string;
  /** Accessible label for the button which moves to the next page. */
  toNextPageAriaLabel?: string;
  /** Accessible label for the button which moves to the previous page. */
  toPreviousPageAriaLabel?: string;
  /** Function called when user clicks to navigate to next page. */
  onNextClick?: (event: React.SyntheticEvent<HTMLButtonElement>, page: number) => void;
  /** Function called when user clicks to navigate to previous page. */
  onPreviousClick?: (event: React.SyntheticEvent<HTMLButtonElement>, page: number) => void;
  /** Function called when page is changed. */
  onSetPage?: (event: React.MouseEvent | React.KeyboardEvent | MouseEvent, newPage: number) => void;
  /** Label for English words "show more" */
  showMoreWords?: string;
  /** Label for English words "show less" */
  showLessWords?: string;
}

const SourcesCard: React.FunctionComponent<SourcesCardProps> = ({
  className,
  isDisabled,
  paginationAriaLabel = 'Pagination',
  sources,
  sourceWord = 'source',
  sourceWordPlural = 'sources',
  toNextPageAriaLabel = 'Go to next page',
  toPreviousPageAriaLabel = 'Go to previous page',
  onNextClick,
  onPreviousClick,
  onSetPage,
  showMoreWords = 'show more',
  showLessWords = 'show less',
  isCompact,
  ...props
}: SourcesCardProps) => {
  const [page, setPage] = React.useState(1);
  const [isExpanded, setIsExpanded] = React.useState(false);

  const onToggle = (_event: React.MouseEvent, isExpanded: boolean) => {
    setIsExpanded(isExpanded);
  };

  const handleNewPage = (_evt: React.MouseEvent | React.KeyboardEvent | MouseEvent, newPage: number) => {
    setPage(newPage);
    onSetPage && onSetPage(_evt, newPage);
  };

  const renderTitle = (title?: string) => {
    if (title) {
      return <Truncate content={title} />;
    }
    return `Source ${page}`;
  };

  return (
    <div className="pf-chatbot__source">
      <span>{pluralize(sources.length, sourceWord, sourceWordPlural)}</span>
      <Card isCompact={isCompact} className="pf-chatbot__sources-card" {...props}>
        <CardTitle className="pf-chatbot__sources-card-title">
          <Button
            component="a"
            variant={ButtonVariant.link}
            href={sources[page - 1].link}
            icon={sources[page - 1].isExternal ? <ExternalLinkSquareAltIcon /> : undefined}
            iconPosition="end"
            isInline
            rel={sources[page - 1].isExternal ? 'noreferrer' : undefined}
            target={sources[page - 1].isExternal ? '_blank' : undefined}
          >
            {renderTitle(sources[page - 1].title)}
          </Button>
        </CardTitle>
        {sources[page - 1].body && (
          <CardBody className={`pf-chatbot__sources-card-body`}>
            {sources[page - 1].hasShowMore ? (
              // prevents extra VO announcements of button text - parent Message has aria-live
              <div aria-live="off">
                <ExpandableSection
                  variant={ExpandableSectionVariant.truncate}
                  toggleText={isExpanded ? showLessWords : showMoreWords}
                  onToggle={onToggle}
                  isExpanded={isExpanded}
                  truncateMaxLines={2}
                >
                  {sources[page - 1].body}
                </ExpandableSection>
              </div>
            ) : (
              <div className="pf-chatbot__sources-card-body-text">{sources[page - 1].body}</div>
            )}
          </CardBody>
        )}
        {sources.length > 1 && (
          <CardFooter className="pf-chatbot__sources-card-footer-container">
            <div className="pf-chatbot__sources-card-footer">
              <nav className={`pf-chatbot__sources-card-footer-buttons ${className}`} aria-label={paginationAriaLabel}>
                <Button
                  variant={ButtonVariant.plain}
                  isDisabled={isDisabled || page === 1}
                  data-action="previous"
                  onClick={(event) => {
                    const newPage = page >= 1 ? page - 1 : 1;
                    onPreviousClick && onPreviousClick(event, newPage);
                    handleNewPage(event, newPage);
                  }}
                  aria-label={toPreviousPageAriaLabel}
                >
                  <Icon iconSize="lg">
                    {/* these are inline because the viewBox that works in a round icon is different than the PatternFly default */}
                    <svg
                      className="pf-v6-svg"
                      viewBox="0 0 280 500"
                      fill="currentColor"
                      aria-hidden="true"
                      role="img"
                      width="1em"
                      height="1em"
                    >
                      <path d="M31.7 239l136-136c9.4-9.4 24.6-9.4 33.9 0l22.6 22.6c9.4 9.4 9.4 24.6 0 33.9L127.9 256l96.4 96.4c9.4 9.4 9.4 24.6 0 33.9L201.7 409c-9.4 9.4-24.6 9.4-33.9 0l-136-136c-9.5-9.4-9.5-24.6-.1-34z"></path>
                    </svg>
                  </Icon>
                </Button>
                <span aria-hidden="true">
                  {page}/{sources.length}
                </span>
                <Button
                  variant={ButtonVariant.plain}
                  isDisabled={isDisabled || page === sources.length}
                  aria-label={toNextPageAriaLabel}
                  data-action="next"
                  onClick={(event) => {
                    const newPage = page + 1 <= sources.length ? page + 1 : sources.length;
                    onNextClick && onNextClick(event, newPage);
                    handleNewPage(event, newPage);
                  }}
                >
                  <Icon isInline iconSize="lg">
                    {/* these are inline because the viewBox that works in a round icon is different than the PatternFly default */}
                    <svg
                      className="pf-v6-svg"
                      viewBox="0 0 180 500"
                      fill="currentColor"
                      aria-hidden="true"
                      role="img"
                      width="1em"
                      height="1em"
                    >
                      <path d="M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9 0l-22.6-22.6c-9.4-9.4-9.4-24.6 0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6 0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9 0l136 136c9.5 9.4 9.5 24.6.1 34z"></path>
                    </svg>
                  </Icon>
                </Button>
              </nav>
            </div>
          </CardFooter>
        )}
      </Card>
    </div>
  );
};

export default SourcesCard;



================================================
FILE: packages/module/src/TermsOfUse/index.ts
================================================
export { default } from './TermsOfUse';

export * from './TermsOfUse';



================================================
FILE: packages/module/src/TermsOfUse/TermsOfUse.scss
================================================
.pf-chatbot__terms-of-use-modal {
  .pf-v6-c-content {
    font-size: var(--pf-t--global--font--size--body--lg);

    h2 {
      font-size: var(--pf-t--global--icon--size--font--heading--h2);
      font-family: var(--pf-t--global--font--family--heading);
      margin-bottom: var(--pf-t--global--spacer--md);
      margin-top: var(--pf-t--global--spacer--md);
      font-weight: var(--pf-t--global--font--weight--heading--default);
    }
    h2:first-of-type {
      margin-top: 0;
    }
  }

  .pf-chatbot__terms-of-use--header {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: var(--pf-t--global--spacer--xl);
    margin-block-start: var(--pf-t--global--spacer--xl);
  }

  .pf-chatbot__terms-of-use--title {
    font-size: var(--pf-t--global--font--size--heading--h1);
    font-family: var(--pf-t--global--font--family--heading);
    font-weight: var(--pf-t--global--font--weight--heading--bold);
  }

  .pf-chatbot__terms-of-use--footer {
    margin-block-start: var(--pf-t--global--spacer--md);
  }

  .pf-chatbot__terms-of-use--section {
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 100%;
  }

  // for handling zoom conditions; zoom to 125% or higher to see this
  @media screen and (max-height: 620px) {
    .pf-v6-c-modal-box__body {
      --pf-v6-c-modal-box__body--MinHeight: auto;
      overflow: visible;
    }
  }
}

.pf-chatbot__chatbot-modal.pf-chatbot__chatbot-modal--fullscreen.pf-chatbot__terms-of-use-modal.pf-chatbot__terms-of-use-modal--fullscreen,
.pf-chatbot__chatbot-modal.pf-chatbot__chatbot-modal--embedded.pf-chatbot__terms-of-use-modal.pf-chatbot__terms-of-use-modal--embedded {
  // override parent modal style
  height: inherit !important;

  .pf-v6-c-content {
    h2 {
      font-size: var(--pf-t--global--icon--size--font--heading--h1);
    }
  }

  .pf-chatbot__terms-of-use--title {
    font-size: var(--pf-t--global--font--size--heading--2xl);
  }
}

.pf-chatbot__terms-of-use-modal.pf-m-compact {
  .pf-chatbot__terms-of-use--header {
    gap: var(--pf-t--global--spacer--md);
    align-items: flex-start;
    margin-block-start: var(--pf-t--global--spacer--lg);
  }

  .pf-chatbot__terms-of-use--modal-header {
    --pf-v6-c-modal-box__header--PaddingBlockStart: var(--pf-t--global--spacer--md);
    --pf-v6-c-modal-box__header--PaddingBlockEnd: var(--pf-t--global--spacer--md);
    --pf-v6-c-modal-box__header--PaddingInlineStart: var(--pf-t--global--spacer--md);
    --pf-v6-c-modal-box__header--PaddingInlineEnd: var(--pf-t--global--spacer--md);
  }

  .pf-chatbot__terms-of-use--modal-body {
    --pf-v6-c-modal-box__body--PaddingInlineStart: var(--pf-t--global--spacer--md);
    --pf-v6-c-modal-box__body--PaddingInlineEnd: var(--pf-t--global--spacer--md);
  }
}



================================================
FILE: packages/module/src/TermsOfUse/TermsOfUse.test.tsx
================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import userEvent from '@testing-library/user-event';
import TermsOfUse from './TermsOfUse';
import { Content } from '@patternfly/react-core';

const handleModalToggle = jest.fn();
const onPrimaryAction = jest.fn();
const onSecondaryAction = jest.fn();

const body = (
  <Content>
    <h1>Heading 1</h1>
    <p>Legal text</p>
  </Content>
);
describe('TermsOfUse', () => {
  afterEach(() => {
    jest.clearAllMocks();
  });
  it('should render modal correctly', () => {
    render(
      <TermsOfUse
        isModalOpen
        onSecondaryAction={onSecondaryAction}
        handleModalToggle={handleModalToggle}
        ouiaId="Terms"
      >
        {body}
      </TermsOfUse>
    );
    expect(screen.getByRole('heading', { name: /Terms of use/i })).toBeTruthy();
    expect(screen.getByRole('button', { name: /Accept/i })).toBeTruthy();
    expect(screen.getByRole('button', { name: /Decline/i })).toBeTruthy();
    expect(screen.getByRole('heading', { name: /Heading 1/i })).toBeTruthy();
    expect(screen.getByText(/Legal text/i)).toBeTruthy();
    expect(screen.getByRole('dialog')).toHaveClass('pf-chatbot__terms-of-use-modal');
    expect(screen.getByRole('dialog')).toHaveClass('pf-chatbot__terms-of-use-modal--default');
  });
  it('should handle image and altText props', () => {
    render(
      <TermsOfUse
        isModalOpen
        onSecondaryAction={onSecondaryAction}
        handleModalToggle={handleModalToggle}
        image="./image.png"
        altText="Test image"
      >
        {body}
      </TermsOfUse>
    );
    expect(screen.getByRole('img')).toBeTruthy();
    expect(screen.getByRole('img')).toHaveAttribute('alt', 'Test image');
  });
  it('should handle className prop', () => {
    render(
      <TermsOfUse
        isModalOpen
        onSecondaryAction={onSecondaryAction}
        handleModalToggle={handleModalToggle}
        className="test"
      >
        {body}
      </TermsOfUse>
    );
    expect(screen.getByRole('dialog')).toHaveClass('pf-chatbot__terms-of-use-modal');
    expect(screen.getByRole('dialog')).toHaveClass('pf-chatbot__terms-of-use-modal--default');
    expect(screen.getByRole('dialog')).toHaveClass('test');
  });
  it('should handle title prop', () => {
    render(
      <TermsOfUse
        isModalOpen
        onSecondaryAction={onSecondaryAction}
        handleModalToggle={handleModalToggle}
        title="Updated title"
      >
        {body}
      </TermsOfUse>
    );
    expect(screen.getByRole('heading', { name: /Updated title/i })).toBeTruthy();
    expect(screen.queryByRole('heading', { name: /Terms of use/i })).toBeFalsy();
  });
  it('should handle primary button prop', () => {
    render(
      <TermsOfUse
        isModalOpen
        onSecondaryAction={onSecondaryAction}
        handleModalToggle={handleModalToggle}
        primaryActionBtn="First"
      >
        {body}
      </TermsOfUse>
    );
    expect(screen.getByRole('button', { name: /First/i })).toBeTruthy();
    expect(screen.queryByRole('button', { name: /Accept/i })).toBeFalsy();
  });
  it('should handle secondary button prop', () => {
    render(
      <TermsOfUse
        isModalOpen
        onSecondaryAction={onSecondaryAction}
        handleModalToggle={handleModalToggle}
        secondaryActionBtn="Second"
      >
        {body}
      </TermsOfUse>
    );
    expect(screen.getByRole('button', { name: /Second/i })).toBeTruthy();
    expect(screen.queryByRole('button', { name: /Deny/i })).toBeFalsy();
  });
  it('should handle primary button click', async () => {
    render(
      <TermsOfUse
        isModalOpen
        onPrimaryAction={onPrimaryAction}
        onSecondaryAction={onSecondaryAction}
        handleModalToggle={handleModalToggle}
      >
        {body}
      </TermsOfUse>
    );
    await userEvent.click(screen.getByRole('button', { name: /Accept/i }));
    expect(onPrimaryAction).toHaveBeenCalledTimes(1);
    expect(handleModalToggle).toHaveBeenCalledTimes(1);
  });
  it('should handle secondary button click', async () => {
    render(
      <TermsOfUse isModalOpen onSecondaryAction={onSecondaryAction} handleModalToggle={handleModalToggle}>
        {body}
      </TermsOfUse>
    );
    await userEvent.click(screen.getByRole('button', { name: /Decline/i }));
    expect(onSecondaryAction).toHaveBeenCalledTimes(1);
    expect(handleModalToggle).not.toHaveBeenCalled();
  });
});



================================================
FILE: packages/module/src/TermsOfUse/TermsOfUse.tsx
================================================
// ============================================================================
// Terms of Use Modal - Chatbot Modal Extension
// ============================================================================
import React from 'react';
import { Button, Content, ModalBody, ModalFooter, ModalHeader, ModalProps } from '@patternfly/react-core';
import { ChatbotDisplayMode } from '../Chatbot';
import ChatbotModal from '../ChatbotModal/ChatbotModal';

export interface TermsOfUseProps extends ModalProps {
  /** Class applied to modal */
  className?: string;
  /** Action assigned to primary modal button */
  onPrimaryAction?: (event: React.MouseEvent | MouseEvent | KeyboardEvent) => void;
  /** Action assigned to secondary modal button */
  onSecondaryAction: (event: React.MouseEvent | MouseEvent | KeyboardEvent) => void;
  /** Name of primary modal button */
  primaryActionBtn?: string;
  /** Name of secondary modal button */
  secondaryActionBtn?: string;
  /** Function that handles modal toggle */
  handleModalToggle: (event: React.MouseEvent | MouseEvent | KeyboardEvent) => void;
  /** Whether modal is open */
  isModalOpen: boolean;
  /** Title of modal */
  title?: string;
  /** Display mode for the Chatbot parent; this influences the styles applied */
  displayMode?: ChatbotDisplayMode;
  /** Optional image displayed in header */
  image?: string;
  /** Alt text for optional image displayed in header */
  altText?: string;
  /** Ref applied to modal */
  innerRef?: React.Ref<HTMLDivElement>;
  /** OuiaID applied to modal */
  ouiaId?: string;
  /** Sets modal to compact styling. */
  isCompact?: boolean;
}

export const TermsOfUseBase: React.FunctionComponent<TermsOfUseProps> = ({
  handleModalToggle,
  isModalOpen,
  onPrimaryAction,
  onSecondaryAction,
  primaryActionBtn = 'Accept',
  secondaryActionBtn = 'Decline',
  title = 'Terms of use',
  image,
  altText,
  displayMode = ChatbotDisplayMode.default,
  className,
  children,
  innerRef,
  ouiaId = 'TermsOfUse',
  isCompact,
  ...props
}: TermsOfUseProps) => {
  const handlePrimaryAction = (_event: React.MouseEvent | MouseEvent | KeyboardEvent) => {
    handleModalToggle(_event);
    onPrimaryAction && onPrimaryAction(_event);
  };

  const handleSecondaryAction = (_event: React.MouseEvent | MouseEvent | KeyboardEvent) => {
    onSecondaryAction(_event);
  };

  const modal = (
    <ChatbotModal
      isOpen={isModalOpen}
      ouiaId={ouiaId}
      aria-labelledby="terms-of-use-title"
      aria-describedby="terms-of-use-modal"
      className={`pf-chatbot__terms-of-use-modal pf-chatbot__terms-of-use-modal--${displayMode} ${isCompact ? 'pf-m-compact' : ''} ${className ? className : ''}`}
      displayMode={displayMode}
      {...props}
    >
      {/* This is a workaround since the PatternFly modal doesn't have ref forwarding */}
      <section className={`pf-chatbot__terms-of-use--section`} aria-label={title} tabIndex={-1} ref={innerRef}>
        <ModalHeader className="pf-chatbot__terms-of-use--modal-header">
          <div className="pf-chatbot__terms-of-use--header">
            {!isCompact && image && altText && (
              <img src={image} className="pf-chatbot__terms-of-use--image" alt={altText} />
            )}
            <h1 className="pf-chatbot__terms-of-use--title">{title}</h1>
          </div>
        </ModalHeader>
        <ModalBody className="pf-chatbot__terms-of-use--modal-body">
          <Content>{children}</Content>
        </ModalBody>
        <ModalFooter className="pf-chatbot__terms-of-use--footer">
          <Button
            isBlock
            key="terms-of-use-modal-primary"
            variant="primary"
            onClick={handlePrimaryAction}
            form="terms-of-use-form"
            size="lg"
          >
            {primaryActionBtn}
          </Button>
          <Button
            isBlock
            key="terms-of-use-modal-secondary"
            variant="secondary"
            onClick={handleSecondaryAction}
            size="lg"
          >
            {secondaryActionBtn}
          </Button>
        </ModalFooter>
      </section>
    </ChatbotModal>
  );

  return modal;
};

const TermsOfUse = React.forwardRef((props: TermsOfUseProps, ref: React.Ref<HTMLDivElement>) => (
  <TermsOfUseBase innerRef={ref} {...props} />
));

export default TermsOfUse;



================================================
FILE: packages/module/src/tracking/console_tracking_provider.ts
================================================
import { InitProps, TrackingSpi } from './tracking_spi';
import { TrackingApi, TrackingEventProperties } from './tracking_api';

export class ConsoleTrackingProvider implements TrackingSpi, TrackingApi {
  private verbose = false;
  trackPageView(url: string | undefined) {
    if (this.verbose) {
      // eslint-disable-next-line no-console
      console.log('ConsoleProvider pageView ', url);
    }
  }

  initialize(props: InitProps): void {
    this.verbose = props.verbose;
    if (this.verbose) {
      // eslint-disable-next-line no-console
      console.log('ConsoleProvider initialize');
    }
  }

  identify(userID: string, userProperties: TrackingEventProperties = {}): void {
    if (this.verbose) {
      // eslint-disable-next-line no-console
      console.log('ConsoleProvider identify ', userID, userProperties);
    }
  }

  trackSingleItem(item: string, properties?: TrackingEventProperties): void {
    if (this.verbose) {
      // eslint-disable-next-line no-console
      console.log('ConsoleProvider: ' + item, properties);
    }
  }
}



================================================
FILE: packages/module/src/tracking/index.ts
================================================
export { default } from './tracking_registry';

export * from './tracking_registry';



================================================
FILE: packages/module/src/tracking/posthog_tracking_provider.ts
================================================
import { posthog } from 'posthog-js';

import { TrackingApi, TrackingEventProperties } from './tracking_api';
import { InitProps, TrackingSpi } from './tracking_spi';

export class PosthogTrackingProvider implements TrackingSpi, TrackingApi {
  private verbose = false;

  initialize(props: InitProps): void {
    this.verbose = props.verbose;
    if (this.verbose) {
      // eslint-disable-next-line no-console
      console.log('PosthogProvider initialize');
    }
    const posthogKey = props.posthogKey as string;

    posthog.init(posthogKey, {
      // eslint-disable-next-line camelcase
      api_host: 'https://us.i.posthog.com',
      // eslint-disable-next-line camelcase
      person_profiles: 'identified_only' // or 'always' to create profiles for anonymous users as well
    });
  }

  identify(userID: string, userProperties: TrackingEventProperties = {}): void {
    if (this.verbose) {
      // eslint-disable-next-line no-console
      console.log('PosthogProvider userID: ' + userID);
    }
    posthog.identify(userID, userProperties);
  }

  trackPageView(url: string | undefined): void {
    if (this.verbose) {
      // eslint-disable-next-line no-console
      console.log('PostHogProvider url ', url);
    }
    // TODO posthog seems to record that automatically.
    //  How to not clash with this here? Just leave as no-op?
  }

  trackSingleItem(item: string, properties?: TrackingEventProperties): void {
    if (this.verbose) {
      // eslint-disable-next-line no-console
      console.log('PosthogProvider: trackSingleItem ' + item, properties);
    }
    posthog.capture(item, { properties });
  }
}



================================================
FILE: packages/module/src/tracking/segment_tracking_provider.ts
================================================
import { AnalyticsBrowser } from '@segment/analytics-next';

import { TrackingApi, TrackingEventProperties } from './tracking_api';
import { InitProps, TrackingSpi } from './tracking_spi';

export class SegmentTrackingProvider implements TrackingSpi, TrackingApi {
  private analytics: AnalyticsBrowser | undefined;
  private verbose = false;

  initialize(props: InitProps): void {
    this.verbose = props.verbose;
    if (this.verbose) {
      // eslint-disable-next-line no-console
      console.log('SegmentProvider initialize');
    }
    const segmentKey = props.segmentKey as string;

    // We need to create an object here, as ts lint is unhappy otherwise
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const integrations = props.segmentIntegrations as any;

    this.analytics = AnalyticsBrowser.load(
      {
        writeKey: segmentKey,
        cdnURL: props.segmentCdn as string
      },

      {
        integrations: {
          ...integrations
        }
      }
    );
  }

  identify(userID: string, userProperties: TrackingEventProperties = {}): void {
    if (this.verbose) {
      // eslint-disable-next-line no-console
      console.log('SegmentProvider userID: ' + userID);
    }
    if (this.analytics) {
      this.analytics.identify(userID, userProperties);
    }
  }

  trackPageView(url: string | undefined): void {
    if (this.verbose) {
      // eslint-disable-next-line no-console
      console.log('SegmentProvider url ', url);
    }
    if (this.analytics) {
      if (url) {
        this.analytics.page(url);
      } else {
        this.analytics.page(); // Uses window.url
      }
    }
  }

  trackSingleItem(item: string, properties?: TrackingEventProperties): void {
    if (this.verbose) {
      // eslint-disable-next-line no-console
      console.log('SegmentProvider: trackSingleItem ' + item, properties);
    }
    if (this.analytics) {
      this.analytics.track(item, { properties });
    }
  }
}



================================================
FILE: packages/module/src/tracking/tracking_api.ts
================================================
export interface TrackingEventProperties {
  [key: string]: string | number | boolean | undefined;
}

export interface TrackingApi {
  identify: (userID: string, userProperties: TrackingEventProperties) => void;

  trackPageView: (url: string | undefined) => void;

  trackSingleItem: (eventName: string, properties: TrackingEventProperties | undefined) => void;
}



================================================
FILE: packages/module/src/tracking/tracking_registry.ts
================================================
import { InitProps, Providers, TrackingSpi } from './tracking_spi';
import { TrackingApi } from './tracking_api';
import TrackingProviderProxy from './trackingProviderProxy';
import { ConsoleTrackingProvider } from './console_tracking_provider';
import { SegmentTrackingProvider } from './segment_tracking_provider';
import { PosthogTrackingProvider } from './posthog_tracking_provider';
import { UmamiTrackingProvider } from './umami_tracking_provider';

export const getTrackingProviders = (initProps: InitProps): TrackingApi => {
  const providers: TrackingSpi[] = [];

  if (initProps.activeProviders) {
    let tmpProps: string[] = initProps.activeProviders;

    // Theoretically we get an array of provider names, but it could also be a CSV string...
    if (!Array.isArray(initProps.activeProviders)) {
      const tmpString = initProps.activeProviders as string;
      if (tmpString && tmpString.indexOf(',') !== -1) {
        tmpProps = tmpString.split(',');
      } else {
        tmpProps = [tmpString];
      }
    }

    tmpProps.forEach((provider) => {
      switch (Providers[provider]) {
        case Providers.Segment:
          providers.push(new SegmentTrackingProvider());
          break;
        case Providers.Umami:
          providers.push(new UmamiTrackingProvider());
          break;
        case Providers.Posthog:
          providers.push(new PosthogTrackingProvider());
          break;
        case Providers.Console:
          providers.push(new ConsoleTrackingProvider());
          break;
        case Providers.None: // Do nothing, just a placeholder
          break;
        default:
          if (providers.length > 1) {
            if (initProps.verbose) {
              // eslint-disable-next-line no-console
              console.error("Unknown provider '" + provider);
            }
          }
          break;
      }
    });
  }

  // Initialize them
  for (const provider of providers) {
    try {
      provider.initialize(initProps);
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error(e);
    }
  }

  return new TrackingProviderProxy(providers);
};

export default getTrackingProviders;



================================================
FILE: packages/module/src/tracking/tracking_spi.ts
================================================
import { TrackingApi } from './tracking_api';

export enum Providers {
  None,
  Segment,
  Umami,
  Posthog,
  Console
}

export type ProviderAsString = keyof typeof Providers;

export interface BaseProps {
  verbose: boolean;
  activeProviders: [ProviderAsString];
}

export type InitProps = {
  [key: string]: string | number | boolean;
} & BaseProps;

export interface TrackingSpi extends TrackingApi {
  // Initialize the provider
  initialize: (props: InitProps) => void;
}



================================================
FILE: packages/module/src/tracking/trackingProviderProxy.ts
================================================
import { TrackingApi, TrackingEventProperties } from './tracking_api';
class TrackingProviderProxy implements TrackingApi {
  providers: TrackingApi[] = [];

  constructor(providers: TrackingApi[]) {
    this.providers = providers;
  }

  identify(userID: string, userProperties: TrackingEventProperties = {}): void {
    for (const provider of this.providers) {
      provider.identify(userID, userProperties);
    }
  }

  trackSingleItem(eventName: string, properties?: TrackingEventProperties): void {
    for (const provider of this.providers) {
      provider.trackSingleItem(eventName, properties);
    }
  }

  trackPageView(url: string | undefined) {
    for (const provider of this.providers) {
      provider.trackPageView(url);
    }
  }
}

export default TrackingProviderProxy;



================================================
FILE: packages/module/src/tracking/umami_tracking_provider.ts
================================================
import { InitProps, TrackingSpi } from './tracking_spi';
import { TrackingApi, TrackingEventProperties } from './tracking_api';

declare global {
  interface Window {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    umami: any;
  }
}

// Items in a queue.
// We need to queue up requests until the script is fully loaded
interface queueT {
  what: 'i' | 't' | 'p'; // identify, track, pageview
  name: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  payload?: any;
}

export class UmamiTrackingProvider implements TrackingSpi, TrackingApi {
  private verbose = false;
  private websiteId: string | undefined;
  private queue: queueT[] = [];

  initialize(props: InitProps): void {
    this.verbose = props.verbose;
    this.log('UmamiProvider initialize');

    this.websiteId = props.umamiKey as string;
    const hostUrl = props.umamiHostUrl as string;

    const script = document.createElement('script');
    script.src = hostUrl + '/script.js';
    script.async = true;
    script.defer = true;

    // Configure Umami properties
    script.setAttribute('data-website-id', this.websiteId);
    script.setAttribute('data-host-url', hostUrl);
    script.setAttribute('data-auto-track', 'false');
    script.setAttribute('data-exclude-search', 'false');

    // Now get from config, which may override some of the above.
    const UMAMI_PREFIX = 'umami-';
    for (const prop in props) {
      if (prop.startsWith(UMAMI_PREFIX)) {
        const att = 'data-' + prop.substring(UMAMI_PREFIX.length);
        const val = props[prop];
        script.setAttribute(att, String(val));
      }
    }
    script.onload = () => {
      this.log('UmamiProvider script loaded');
      this.flushQueue();
    };

    document.body.appendChild(script);
  }

  identify(userID: string, userProperties: TrackingEventProperties = {}): void {
    this.log('UmamiProvider userID: ' + userID + ' => ' + JSON.stringify(userProperties));
    if (window.umami) {
      window.umami.identify({ userID, userProperties });
    } else {
      this.queue.push({ what: 'i', name: userID, payload: userProperties });
    }
  }

  trackPageView(url: string | undefined): void {
    this.log('UmamiProvider url ' + url);
    if (window.umami) {
      window.umami.track({ url, website: this.websiteId });
    } else {
      this.queue.push({ what: 'p', name: String(url) });
    }
  }

  trackSingleItem(item: string, properties?: TrackingEventProperties): void {
    this.log('UmamiProvider: trackSingleItem ' + item + JSON.stringify(properties));
    if (window.umami) {
      window.umami.track(item, properties);
    } else {
      this.queue.push({ what: 't', name: item, payload: properties });
    }
  }

  flushQueue(): void {
    for (const item of this.queue) {
      this.log('Queue flush ' + JSON.stringify(item));
      switch (item.what) {
        case 'i':
          this.identify(item.name, item.payload);
          break;
        case 't':
          this.trackSingleItem(item.name, item.payload);
          break;
        case 'p':
          this.trackPageView(item.name);
          break;
      }
    }
  }

  log(msg: string): void {
    if (this.verbose) {
      // eslint-disable-next-line no-console
      console.debug('UmamiProvider: ', msg);
    }
  }
}



================================================
FILE: scripts/build-packages.js
================================================
const fse = require('fs-extra');
const glob = require('glob');
const path = require('path');

const root = process.cwd();

const foldersBlackList = [ '__snapshots__', '__mocks__' ];
const sourceFiles = glob
  .sync(`${root}/src/*/`)
  .filter((item) => !foldersBlackList.some((name) => item.includes(name)))
  .map((name) => name.replace(/\/$/, ''));
const indexTypings = glob.sync(`${root}/src/index.d.ts`);

async function copyTypings(files, dest) {
  const cmds = [];
  files.forEach((file) => {
    const fileName = file.split('/').pop();
    cmds.push(fse.copyFile(file, `${dest}/${fileName}`));
  });
  return Promise.all(cmds);
}

async function createPackage(file, forceTypes) {
  const fileName = file.split('/').pop();
  const esmSource = glob.sync(`${root}/esm/${fileName}/**/index.js`)[0];
  /**
   * Prevent creating package.json for directories with no JS files (like CSS directories)
   */
  if (!esmSource) {
    return;
  }

  const destFile = `${path.resolve(root, file.split('/src/').pop())}/package.json`;

  const esmRelative = path.relative(file.replace('/src', ''), esmSource);
  const content = {
    main: 'index.js',
    module: esmRelative,
  };
  const typings = glob.sync(`${root}/src/${fileName}/*.d.ts`);
  const cmds = [];
  if (forceTypes) {
    content.typings = 'index.d.ts';
  } else if (typings.length > 0) {
    const hasIndex = glob.sync(`${root}/src/${fileName}/index.d.ts`).length > 0;
    if (hasIndex) {
      content.typings = 'index.d.ts';
    }

    cmds.push(copyTypings(typings, `${root}/${fileName}`));
  }

  cmds.push(fse.writeJSON(destFile, content));

  return Promise.all(cmds);
}

async function generatePackages(files, forceTypes) {
  const cmds = files.map((file) => createPackage(file, forceTypes));
  return Promise.all(cmds);
}

async function run(files, forceTypes) {
  try {
    await generatePackages(files, forceTypes);
    if (indexTypings.length === 1) {
      copyTypings(indexTypings, root);
    }
  } catch (error) {
    console.error(error);
    process.exit(1);
  }
}

const forceTypes = !!process.argv.includes('--forceTypes');

run(sourceFiles, forceTypes);



================================================
FILE: .github/upload-preview.js
================================================
const fs = require('fs');
const path = require('path');
const { Octokit } = require('@octokit/rest');
const octokit = new Octokit({ auth: process.env.GH_PR_TOKEN });
const surge = require('surge');
const publishFn = surge().publish();

// From github actions
const ghrepo = process.env.GITHUB_REPOSITORY || '';

const owner = process.env.CIRCLE_PROJECT_USERNAME || ghrepo.split('/')[0]; // patternfly
const repo = process.env.CIRCLE_PROJECT_REPONAME || ghrepo.split('/')[1];
const prnum = process.env.CIRCLE_PR_NUMBER || process.env.GH_PR_NUM;
const prbranch = process.env.CIRCLE_BRANCH || process.env.GITHUB_REF.split('/').pop();

const uploadFolder = process.argv[2];
if (!uploadFolder) {
  console.log('Usage: upload-preview uploadFolder');
  process.exit(1);
}

const uploadFolderName = path.basename(uploadFolder);
let uploadURL = `${repo}-${prnum ? `pr-chatbot-${prnum}` : prbranch}`.replace(/[\/|\.]/g, '-');

switch (uploadFolderName) {
  case 'coverage':
    uploadURL += '-a11y.surge.sh';
    break;
  case 'public':
    if (!prnum && prbranch === 'main') {
      uploadURL = 'https://pf-extensions.surge.sh/';
    } else {
      uploadURL += '.surge.sh';
    }
    break;
  default:
    uploadURL += `-${uploadFolderName}`;
    uploadURL += '.surge.sh';
    break;
}

publishFn({
  project: uploadFolder,
  p: uploadFolder,
  domain: uploadURL,
  d: uploadURL,
  e: 'https://surge.surge.sh',
  endpoint: 'https://surge.surge.sh'
});

function tryAddComment(comment, commentBody) {
  if (!commentBody.includes(comment)) {
    return comment;
  }
  return '';
}

if (prnum) {
  octokit.issues
    .listComments({
      owner,
      repo,
      issue_number: prnum
    })
    .then((res) => res.data)
    .then((comments) => {
      let commentBody = '';
      const existingComment = comments.find((comment) => comment.user.login === 'patternfly-build');
      if (existingComment) {
        commentBody += existingComment.body.trim();
        commentBody += '\n\n';
      }

      if (uploadFolderName === 'public') {
        commentBody += tryAddComment(`Preview: https://${uploadURL}`, commentBody);
      } else if (uploadFolderName === 'coverage') {
        commentBody += tryAddComment(`A11y report: https://${uploadURL}`, commentBody);
      }

      if (existingComment) {
        octokit.issues
          .updateComment({
            owner,
            repo,
            comment_id: existingComment.id,
            body: commentBody
          })
          .then(() => console.log('Updated comment!'));
      } else {
        octokit.issues
          .createComment({
            owner,
            repo,
            issue_number: prnum,
            body: commentBody
          })
          .then(() => console.log('Created comment!'));
      }
    });
}



================================================
FILE: .github/workflows/build-lint-test.yml
================================================
name: build-lint-test
on:
  workflow_call:
jobs:
  build:
    runs-on: ubuntu-latest
    env:
      GH_PR_NUM: ${{ github.event.number }}
    steps:
      - uses: actions/checkout@v4
      - run: |
          if [[ ! -z "${GH_PR_NUM}" ]]; then 
            echo "Checking out PR"
            git fetch origin pull/$GH_PR_NUM/head:tmp
            git checkout tmp
          fi
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - uses: actions/cache@v4
        id: npm-cache
        name: Cache npm deps
        with:
          path: |
            node_modules
            **/node_modules
          key: ${{ runner.os }}-npm-14-${{ secrets.CACHE_VERSION }}-${{ hashFiles('package-lock.json') }}
      - run: npm install --frozen-lockfile
        if: steps.npm-cache.outputs.cache-hit != 'true'
      - uses: actions/cache@v4
        id: dist
        name: Cache dist
        with:
          path: |
            packages/*/dist
          key: ${{ runner.os }}-dist-14-${{ secrets.CACHE_VERSION }}-${{ hashFiles('package-lock.json', 'package.json', 'packages/*/*', '!packages/*/dist', '!packages/*/node_modules') }}
      - name: Build dist
        run: npm run build
        if: steps.dist.outputs.cache-hit != 'true'
  lint:
    runs-on: ubuntu-latest
    env:
      GH_PR_NUM: ${{ github.event.number }}
    needs: build
    steps:
      - uses: actions/checkout@v4
      - run: |
          if [[ ! -z "${GH_PR_NUM}" ]]; then 
            echo "Checking out PR"
            git fetch origin pull/$GH_PR_NUM/head:tmp
            git checkout tmp
          fi
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - uses: actions/cache@v4
        id: npm-cache
        name: Cache npm deps
        with:
          path: |
            node_modules
            **/node_modules
          key: ${{ runner.os }}-yarn-14-${{ secrets.CACHE_VERSION }}-${{ hashFiles('package-lock.json') }}
      - run: npm install --frozen-lockfile
        if: steps.npm-cache.outputs.cache-hit != 'true'
      - uses: actions/cache@v4
        id: lint-cache
        name: Load lint cache
        with:
          path: '.eslintcache'
          key: ${{ runner.os }}-lint-14-${{ secrets.CACHE_VERSION }}-${{ hashFiles('package-lock.json') }}
      - name: ESLint
        run: npm run lint:js
      - name: MDLint
        run: npm run lint:md
  test_jest:
    runs-on: ubuntu-latest
    env:
      GH_PR_NUM: ${{ github.event.number }}
    needs: build
    steps:
      - uses: actions/checkout@v4
      # Yes, we really want to checkout the PR
      - run: |
          if [[ ! -z "${GH_PR_NUM}" ]]; then 
            echo "Checking out PR"
            git fetch origin pull/$GH_PR_NUM/head:tmp
            git checkout tmp
          fi
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - uses: actions/cache@v4
        id: npm-cache
        name: Cache npm deps
        with:
          path: |
            node_modules
            **/node_modules
            ~/.cache/Cypress
          key: ${{ runner.os }}-yarn-14-${{ secrets.CACHE_VERSION }}-${{ hashFiles('package-lock.json') }}
      - run: npm install --frozen-lockfile
        if: steps.npm-cache.outputs.cache-hit != 'true'
      - uses: actions/cache@v4
        id: dist
        name: Cache dist
        with:
          path: |
            packages/*/dist
            packages/react-styles/css
          key: ${{ runner.os }}-dist-14-${{ secrets.CACHE_VERSION }}-${{ hashFiles('package-lock.json', 'package.json', 'packages/*/*', '!packages/*/dist', '!packages/*/node_modules') }}
      - name: Build dist
        run: npm run build
        if: steps.dist.outputs.cache-hit != 'true'
      - name: PF4 Jest Tests
        run: npm run test --maxWorkers=2
  test_a11y:
    runs-on: ubuntu-latest
    env:
      GH_PR_NUM: ${{ github.event.number }}
    needs: build
    steps:
      - uses: actions/checkout@v4
      # Yes, we really want to checkout the PR
      - run: |
          if [[ ! -z "${GH_PR_NUM}" ]]; then 
            echo "Checking out PR"
            git fetch origin pull/$GH_PR_NUM/head:tmp
            git checkout tmp
          fi
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - uses: actions/cache@v4
        id: npm-cache
        name: Cache npm deps
        with:
          path: |
            node_modules
            **/node_modules
            ~/.cache/Cypress
          key: ${{ runner.os }}-yarn-14-${{ secrets.CACHE_VERSION }}-${{ hashFiles('package-lock.json') }}
      - run: npm install --frozen-lockfile
        if: steps.npm-cache.outputs.cache-hit != 'true'
      - uses: actions/cache@v4
        id: dist
        name: Cache dist
        with:
          path: |
            packages/*/dist
            packages/react-styles/css
          key: ${{ runner.os }}-dist-14-${{ secrets.CACHE_VERSION }}-${{ hashFiles('package-lock.json', 'package.json', 'packages/*/*', '!packages/*/dist', '!packages/*/node_modules') }}
      - name: Build dist
        run: npm run build
        if: steps.dist.outputs.cache-hit != 'true'
      - name: Build docs
        run: npm run build:docs
      - name: Install Chrome for Puppeteer
        run: npx puppeteer browsers install chrome
      - name: A11y tests
        run: npm run serve:docs & npm run test:a11y



================================================
FILE: .github/workflows/build.yml
================================================
name: build
on:
  workflow_call:
jobs:
  build:
    runs-on: ubuntu-latest
    env:
      GH_PR_NUM: ${{ github.event.number }}
    steps:
      - uses: actions/checkout@v4
      - run: |
          if [[ ! -z "${GH_PR_NUM}" ]]; then 
            echo "Checking out PR"
            git fetch origin pull/$GH_PR_NUM/head:tmp
            git checkout tmp
          fi
      - uses: actions/cache@v4
        id: setup-cache
        name: Cache setup
        with:
          path: |
            README.md
            package.json
            .tmplr.yml
            packages/*/package.json
            packages/*/patternfly-docs/content/**
            packages/*/patternfly-docs/generated/**
          key: ${{ runner.os }}-setup-14-${{ secrets.CACHE_VERSION }}-${{ hashFiles('package.json', 'packages/module/package.json') }}
      - name: Run build script
        run: ./devSetup.sh
        shell: bash
        if: steps.setup-cache.outputs.cache-hit != 'true'
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - uses: actions/cache@v4
        id: npm-cache
        name: Cache npm deps
        with:
          path: |
           node_modules
           **/node_modules
          key: ${{ runner.os }}-yarn-14-${{ secrets.CACHE_VERSION }}-${{ hashFiles('package-lock.json') }}
      - run: npm install --frozen-lockfile
        if: steps.npm-cache.outputs.cache-hit != 'true'
      - uses: actions/cache@v4
        id: dist
        name: Cache dist
        with:
          path: |
            packages/*/dist
          key: ${{ runner.os }}-dist-14-${{ secrets.CACHE_VERSION }}-${{ hashFiles('package-lock.json', 'package.json', 'packages/*/*', '!packages/*/dist', '!packages/*/node_modules') }}
      - name: Build dist
        run: npm run build
        if: steps.dist.outputs.cache-hit != 'true'


================================================
FILE: .github/workflows/check-pr.yml
================================================
name: check-pr
on:
  pull_request:
    branches:
      - main
jobs:
  call-build-lint-test-workflow:
    uses: ./.github/workflows/build-lint-test.yml



================================================
FILE: .github/workflows/extensions.yml
================================================
name: Add new issues to PatternFly Extensions project

on:
  issues:
    types:
      - opened

jobs:
  add-to-project:
    name: Add issue to project
    runs-on: ubuntu-latest
    steps:
      - uses: actions/add-to-project@v0.3.0
        with:
          project-url: https://github.com/orgs/patternfly/projects/7
          github-token: ${{ secrets.GH_PROJECTS }}



================================================
FILE: .github/workflows/pr-preview.yml
================================================
### WARNING -- this file was generated by generate-workflows
name: pr-preview
on: pull_request_target
jobs:
  build-upload:
    runs-on: ubuntu-latest
    env:
      SURGE_LOGIN: ${{ secrets.SURGE_LOGIN }}
      SURGE_TOKEN: ${{ secrets.SURGE_TOKEN }}
      GH_PR_TOKEN: ${{ secrets.GH_PR_TOKEN }}
      GH_PR_NUM: ${{ github.event.number }}
    steps:
      - uses: actions/checkout@v4
      # Yes, we really want to checkout the PR
      - run: |
          git fetch origin pull/$GH_PR_NUM/head:tmp
          git checkout tmp

      - run: |
          git rev-parse origin/main
          git rev-parse HEAD
          git rev-parse origin/main..HEAD
          git log origin/main..HEAD --format="%b"

      # Yes, we really want to checkout the PR
      # Injected by generate-workflows.js
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - uses: actions/cache@v4
        id: npm-cache
        name: Load npm deps from cache
        with:
          path: '**/node_modules'
          key: ${{ runner.os }}-npm-14-${{ secrets.CACHE_VERSION }}-${{ hashFiles('package-lock.json') }}
      - run: npm install --frozen-lockfile
        if: steps.yarn-cache.outputs.cache-hit != 'true'
      - run: npm run build
        name: Build virtual assistant
      - uses: actions/cache@v4
        id: docs-cache
        name: Load webpack cache
        with:
          path: '.cache'
          key: ${{ runner.os }}-v4-${{ hashFiles('yarn.lock') }}
      - run: npm run build:docs
        name: Build docs
      - run: node .github/upload-preview.js packages/module/public
        name: Upload docs
        if: always()
      - run: npx puppeteer browsers install chrome
        name: Install Chrome for Puppeteer
      - run: npm run serve:docs & npm run test:a11y
        name: a11y tests
      - run: node .github/upload-preview.js packages/module/coverage
        name: Upload a11y report
        if: always()



================================================
FILE: .github/workflows/promote.yml
================================================
name: promote
on:
  workflow_dispatch:
    inputs:
      new_tag_name:
        description: Name of tag created to be associated with this promotion.
        required: true
jobs:
  build-and-promote:
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
      NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
      NEW_TAG_NAME: ${{ github.event.inputs.new_tag_name }}
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: '20.18.3'
          registry-url: 'https://registry.npmjs.org'
      - uses: actions/checkout@v4
      - name: Build for promotion
        run: npm install --frozen-lockfile && npm run build
      - name: GitHub Tag Name example
        run: |
          echo "Tag name from GITHUB_REF_NAME: $GITHUB_REF_NAME"
          echo "Tag name from github.ref_name: ${{  github.ref_name }}"
      - name: Manual publish
        run: |
          cd packages/module
          npm version "$NEW_TAG_NAME" --git-tag-version false
          npm publish --tag=latest



================================================
FILE: .github/workflows/release.yml
================================================
name: release
on:
  push:
    branches:
      - main
jobs:
  call-build-lint-test-workflow:
    uses: ./.github/workflows/build-lint-test.yml
  deploy:
    runs-on: ubuntu-latest
    needs: [call-build-lint-test-workflow]
    env:
      NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - uses: actions/cache@v4
        id: npm-cache
        name: Cache npm deps
        with:
          path: |
            node_modules
            **/node_modules
            ~/.cache/Cypress
          key: ${{ runner.os }}-yarn-14-${{ secrets.CACHE_VERSION }}-${{ hashFiles('package-lock.json') }}
      - run: npm install --frozen-lockfile
        if: steps.npm-cache.outputs.cache-hit != 'true'
      - uses: actions/cache@v4
        id: dist
        name: Cache dist
        with:
          path: |
            packages/*/dist
            packages/react-styles/css
          key: ${{ runner.os }}-dist-14-${{ secrets.CACHE_VERSION }}-${{ hashFiles('package-lock.json', 'package.json', 'packages/*/*', '!packages/*/dist', '!packages/*/node_modules') }}
      - name: Build dist
        run: npm run build
        if: steps.dist.outputs.cache-hit != 'true'
      - name: Release to NPM
        run: cd packages/module && npx semantic-release@19.0.5


